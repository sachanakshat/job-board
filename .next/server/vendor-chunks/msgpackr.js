"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/msgpackr";
exports.ids = ["vendor-chunks/msgpackr"];
exports.modules = {

/***/ "(rsc)/./node_modules/msgpackr/dist/node.cjs":
/*!*********************************************!*\
  !*** ./node_modules/msgpackr/dist/node.cjs ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar stream = __webpack_require__(/*! stream */ \"stream\");\nvar module$1 = __webpack_require__(/*! module */ \"module\");\nvar decoder;\ntry {\n    decoder = new TextDecoder();\n} catch (error) {}\nvar src;\nvar srcEnd;\nvar position$1 = 0;\nconst EMPTY_ARRAY = [];\nvar strings = EMPTY_ARRAY;\nvar stringPosition = 0;\nvar currentUnpackr = {};\nvar currentStructures;\nvar srcString;\nvar srcStringStart = 0;\nvar srcStringEnd = 0;\nvar bundledStrings$1;\nvar referenceMap;\nvar currentExtensions = [];\nvar dataView;\nvar defaultOptions = {\n    useRecords: false,\n    mapsAsObjects: true\n};\nclass C1Type {\n}\nconst C1 = new C1Type();\nC1.name = \"MessagePack 0xC1\";\nvar sequentialMode = false;\nvar inlineObjectReadThreshold = 2;\nvar readStruct$1, onLoadedStructures$1, onSaveState;\n// no-eval build\ntry {\n    new Function(\"\");\n} catch (error) {\n    // if eval variants are not supported, do not create inline object readers ever\n    inlineObjectReadThreshold = Infinity;\n}\nclass Unpackr {\n    constructor(options){\n        if (options) {\n            if (options.useRecords === false && options.mapsAsObjects === undefined) options.mapsAsObjects = true;\n            if (options.sequential && options.trusted !== false) {\n                options.trusted = true;\n                if (!options.structures && options.useRecords != false) {\n                    options.structures = [];\n                    if (!options.maxSharedStructures) options.maxSharedStructures = 0;\n                }\n            }\n            if (options.structures) options.structures.sharedLength = options.structures.length;\n            else if (options.getStructures) {\n                (options.structures = []).uninitialized = true; // this is what we use to denote an uninitialized structures\n                options.structures.sharedLength = 0;\n            }\n            if (options.int64AsNumber) {\n                options.int64AsType = \"number\";\n            }\n        }\n        Object.assign(this, options);\n    }\n    unpack(source, options) {\n        if (src) {\n            // re-entrant execution, save the state and restore it after we do this unpack\n            return saveState$1(()=>{\n                clearSource();\n                return this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options);\n            });\n        }\n        if (!source.buffer && source.constructor === ArrayBuffer) source = typeof Buffer !== \"undefined\" ? Buffer.from(source) : new Uint8Array(source);\n        if (typeof options === \"object\") {\n            srcEnd = options.end || source.length;\n            position$1 = options.start || 0;\n        } else {\n            position$1 = 0;\n            srcEnd = options > -1 ? options : source.length;\n        }\n        stringPosition = 0;\n        srcStringEnd = 0;\n        srcString = null;\n        strings = EMPTY_ARRAY;\n        bundledStrings$1 = null;\n        src = source;\n        // this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n        // technique for getting data from a database where it can be copied into an existing buffer instead of creating\n        // new ones\n        try {\n            dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));\n        } catch (error) {\n            // if it doesn't have a buffer, maybe it is the wrong type of object\n            src = null;\n            if (source instanceof Uint8Array) throw error;\n            throw new Error(\"Source must be a Uint8Array or Buffer but was a \" + (source && typeof source == \"object\" ? source.constructor.name : typeof source));\n        }\n        if (this instanceof Unpackr) {\n            currentUnpackr = this;\n            if (this.structures) {\n                currentStructures = this.structures;\n                return checkedRead(options);\n            } else if (!currentStructures || currentStructures.length > 0) {\n                currentStructures = [];\n            }\n        } else {\n            currentUnpackr = defaultOptions;\n            if (!currentStructures || currentStructures.length > 0) currentStructures = [];\n        }\n        return checkedRead(options);\n    }\n    unpackMultiple(source, forEach) {\n        let values, lastPosition = 0;\n        try {\n            sequentialMode = true;\n            let size = source.length;\n            let value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size);\n            if (forEach) {\n                if (forEach(value, lastPosition, position$1) === false) return;\n                while(position$1 < size){\n                    lastPosition = position$1;\n                    if (forEach(checkedRead(), lastPosition, position$1) === false) {\n                        return;\n                    }\n                }\n            } else {\n                values = [\n                    value\n                ];\n                while(position$1 < size){\n                    lastPosition = position$1;\n                    values.push(checkedRead());\n                }\n                return values;\n            }\n        } catch (error) {\n            error.lastPosition = lastPosition;\n            error.values = values;\n            throw error;\n        } finally{\n            sequentialMode = false;\n            clearSource();\n        }\n    }\n    _mergeStructures(loadedStructures, existingStructures) {\n        if (onLoadedStructures$1) loadedStructures = onLoadedStructures$1.call(this, loadedStructures);\n        loadedStructures = loadedStructures || [];\n        if (Object.isFrozen(loadedStructures)) loadedStructures = loadedStructures.map((structure)=>structure.slice(0));\n        for(let i = 0, l = loadedStructures.length; i < l; i++){\n            let structure = loadedStructures[i];\n            if (structure) {\n                structure.isShared = true;\n                if (i >= 32) structure.highByte = i - 32 >> 5;\n            }\n        }\n        loadedStructures.sharedLength = loadedStructures.length;\n        for(let id in existingStructures || []){\n            if (id >= 0) {\n                let structure = loadedStructures[id];\n                let existing = existingStructures[id];\n                if (existing) {\n                    if (structure) (loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure;\n                    loadedStructures[id] = existing;\n                }\n            }\n        }\n        return this.structures = loadedStructures;\n    }\n    decode(source, options) {\n        return this.unpack(source, options);\n    }\n}\nfunction checkedRead(options) {\n    try {\n        if (!currentUnpackr.trusted && !sequentialMode) {\n            let sharedLength = currentStructures.sharedLength || 0;\n            if (sharedLength < currentStructures.length) currentStructures.length = sharedLength;\n        }\n        let result;\n        if (currentUnpackr.randomAccessStructure && src[position$1] < 0x40 && src[position$1] >= 0x20 && readStruct$1) {\n            result = readStruct$1(src, position$1, srcEnd, currentUnpackr);\n            src = null; // dispose of this so that recursive unpack calls don't save state\n            if (!(options && options.lazy) && result) result = result.toJSON();\n            position$1 = srcEnd;\n        } else result = read();\n        if (bundledStrings$1) {\n            position$1 = bundledStrings$1.postBundlePosition;\n            bundledStrings$1 = null;\n        }\n        if (sequentialMode) // we only need to restore the structures if there was an error, but if we completed a read,\n        // we can clear this out and keep the structures we read\n        currentStructures.restoreStructures = null;\n        if (position$1 == srcEnd) {\n            // finished reading this source, cleanup references\n            if (currentStructures && currentStructures.restoreStructures) restoreStructures();\n            currentStructures = null;\n            src = null;\n            if (referenceMap) referenceMap = null;\n        } else if (position$1 > srcEnd) {\n            // over read\n            throw new Error(\"Unexpected end of MessagePack data\");\n        } else if (!sequentialMode) {\n            let jsonView;\n            try {\n                jsonView = JSON.stringify(result, (_, value)=>typeof value === \"bigint\" ? `${value}n` : value).slice(0, 100);\n            } catch (error) {\n                jsonView = \"(JSON view not available \" + error + \")\";\n            }\n            throw new Error(\"Data read, but end of buffer not reached \" + jsonView);\n        }\n        // else more to read, but we are reading sequentially, so don't clear source yet\n        return result;\n    } catch (error) {\n        if (currentStructures && currentStructures.restoreStructures) restoreStructures();\n        clearSource();\n        if (error instanceof RangeError || error.message.startsWith(\"Unexpected end of buffer\") || position$1 > srcEnd) {\n            error.incomplete = true;\n        }\n        throw error;\n    }\n}\nfunction restoreStructures() {\n    for(let id in currentStructures.restoreStructures){\n        currentStructures[id] = currentStructures.restoreStructures[id];\n    }\n    currentStructures.restoreStructures = null;\n}\nfunction read() {\n    let token = src[position$1++];\n    if (token < 0xa0) {\n        if (token < 0x80) {\n            if (token < 0x40) return token;\n            else {\n                let structure = currentStructures[token & 0x3f] || currentUnpackr.getStructures && loadStructures()[token & 0x3f];\n                if (structure) {\n                    if (!structure.read) {\n                        structure.read = createStructureReader(structure, token & 0x3f);\n                    }\n                    return structure.read();\n                } else return token;\n            }\n        } else if (token < 0x90) {\n            // map\n            token -= 0x80;\n            if (currentUnpackr.mapsAsObjects) {\n                let object = {};\n                for(let i = 0; i < token; i++){\n                    let key = readKey();\n                    if (key === \"__proto__\") key = \"__proto_\";\n                    object[key] = read();\n                }\n                return object;\n            } else {\n                let map = new Map();\n                for(let i = 0; i < token; i++){\n                    map.set(read(), read());\n                }\n                return map;\n            }\n        } else {\n            token -= 0x90;\n            let array = new Array(token);\n            for(let i = 0; i < token; i++){\n                array[i] = read();\n            }\n            if (currentUnpackr.freezeData) return Object.freeze(array);\n            return array;\n        }\n    } else if (token < 0xc0) {\n        // fixstr\n        let length = token - 0xa0;\n        if (srcStringEnd >= position$1) {\n            return srcString.slice(position$1 - srcStringStart, (position$1 += length) - srcStringStart);\n        }\n        if (srcStringEnd == 0 && srcEnd < 140) {\n            // for small blocks, avoiding the overhead of the extract call is helpful\n            let string = length < 16 ? shortStringInJS(length) : longStringInJS(length);\n            if (string != null) return string;\n        }\n        return readFixedString(length);\n    } else {\n        let value;\n        switch(token){\n            case 0xc0:\n                return null;\n            case 0xc1:\n                if (bundledStrings$1) {\n                    value = read(); // followed by the length of the string in characters (not bytes!)\n                    if (value > 0) return bundledStrings$1[1].slice(bundledStrings$1.position1, bundledStrings$1.position1 += value);\n                    else return bundledStrings$1[0].slice(bundledStrings$1.position0, bundledStrings$1.position0 -= value);\n                }\n                return C1; // \"never-used\", return special object to denote that\n            case 0xc2:\n                return false;\n            case 0xc3:\n                return true;\n            case 0xc4:\n                // bin 8\n                value = src[position$1++];\n                if (value === undefined) throw new Error(\"Unexpected end of buffer\");\n                return readBin(value);\n            case 0xc5:\n                // bin 16\n                value = dataView.getUint16(position$1);\n                position$1 += 2;\n                return readBin(value);\n            case 0xc6:\n                // bin 32\n                value = dataView.getUint32(position$1);\n                position$1 += 4;\n                return readBin(value);\n            case 0xc7:\n                // ext 8\n                return readExt(src[position$1++]);\n            case 0xc8:\n                // ext 16\n                value = dataView.getUint16(position$1);\n                position$1 += 2;\n                return readExt(value);\n            case 0xc9:\n                // ext 32\n                value = dataView.getUint32(position$1);\n                position$1 += 4;\n                return readExt(value);\n            case 0xca:\n                value = dataView.getFloat32(position$1);\n                if (currentUnpackr.useFloat32 > 2) {\n                    // this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n                    let multiplier = mult10[(src[position$1] & 0x7f) << 1 | src[position$1 + 1] >> 7];\n                    position$1 += 4;\n                    return (multiplier * value + (value > 0 ? 0.5 : -0.5) >> 0) / multiplier;\n                }\n                position$1 += 4;\n                return value;\n            case 0xcb:\n                value = dataView.getFloat64(position$1);\n                position$1 += 8;\n                return value;\n            // uint handlers\n            case 0xcc:\n                return src[position$1++];\n            case 0xcd:\n                value = dataView.getUint16(position$1);\n                position$1 += 2;\n                return value;\n            case 0xce:\n                value = dataView.getUint32(position$1);\n                position$1 += 4;\n                return value;\n            case 0xcf:\n                if (currentUnpackr.int64AsType === \"number\") {\n                    value = dataView.getUint32(position$1) * 0x100000000;\n                    value += dataView.getUint32(position$1 + 4);\n                } else if (currentUnpackr.int64AsType === \"string\") {\n                    value = dataView.getBigUint64(position$1).toString();\n                } else if (currentUnpackr.int64AsType === \"auto\") {\n                    value = dataView.getBigUint64(position$1);\n                    if (value <= BigInt(2) << BigInt(52)) value = Number(value);\n                } else value = dataView.getBigUint64(position$1);\n                position$1 += 8;\n                return value;\n            // int handlers\n            case 0xd0:\n                return dataView.getInt8(position$1++);\n            case 0xd1:\n                value = dataView.getInt16(position$1);\n                position$1 += 2;\n                return value;\n            case 0xd2:\n                value = dataView.getInt32(position$1);\n                position$1 += 4;\n                return value;\n            case 0xd3:\n                if (currentUnpackr.int64AsType === \"number\") {\n                    value = dataView.getInt32(position$1) * 0x100000000;\n                    value += dataView.getUint32(position$1 + 4);\n                } else if (currentUnpackr.int64AsType === \"string\") {\n                    value = dataView.getBigInt64(position$1).toString();\n                } else if (currentUnpackr.int64AsType === \"auto\") {\n                    value = dataView.getBigInt64(position$1);\n                    if (value >= BigInt(-2) << BigInt(52) && value <= BigInt(2) << BigInt(52)) value = Number(value);\n                } else value = dataView.getBigInt64(position$1);\n                position$1 += 8;\n                return value;\n            case 0xd4:\n                // fixext 1\n                value = src[position$1++];\n                if (value == 0x72) {\n                    return recordDefinition(src[position$1++] & 0x3f);\n                } else {\n                    let extension = currentExtensions[value];\n                    if (extension) {\n                        if (extension.read) {\n                            position$1++; // skip filler byte\n                            return extension.read(read());\n                        } else if (extension.noBuffer) {\n                            position$1++; // skip filler byte\n                            return extension();\n                        } else return extension(src.subarray(position$1, ++position$1));\n                    } else throw new Error(\"Unknown extension \" + value);\n                }\n            case 0xd5:\n                // fixext 2\n                value = src[position$1];\n                if (value == 0x72) {\n                    position$1++;\n                    return recordDefinition(src[position$1++] & 0x3f, src[position$1++]);\n                } else return readExt(2);\n            case 0xd6:\n                // fixext 4\n                return readExt(4);\n            case 0xd7:\n                // fixext 8\n                return readExt(8);\n            case 0xd8:\n                // fixext 16\n                return readExt(16);\n            case 0xd9:\n                // str 8\n                value = src[position$1++];\n                if (srcStringEnd >= position$1) {\n                    return srcString.slice(position$1 - srcStringStart, (position$1 += value) - srcStringStart);\n                }\n                return readString8(value);\n            case 0xda:\n                // str 16\n                value = dataView.getUint16(position$1);\n                position$1 += 2;\n                if (srcStringEnd >= position$1) {\n                    return srcString.slice(position$1 - srcStringStart, (position$1 += value) - srcStringStart);\n                }\n                return readString16(value);\n            case 0xdb:\n                // str 32\n                value = dataView.getUint32(position$1);\n                position$1 += 4;\n                if (srcStringEnd >= position$1) {\n                    return srcString.slice(position$1 - srcStringStart, (position$1 += value) - srcStringStart);\n                }\n                return readString32(value);\n            case 0xdc:\n                // array 16\n                value = dataView.getUint16(position$1);\n                position$1 += 2;\n                return readArray(value);\n            case 0xdd:\n                // array 32\n                value = dataView.getUint32(position$1);\n                position$1 += 4;\n                return readArray(value);\n            case 0xde:\n                // map 16\n                value = dataView.getUint16(position$1);\n                position$1 += 2;\n                return readMap(value);\n            case 0xdf:\n                // map 32\n                value = dataView.getUint32(position$1);\n                position$1 += 4;\n                return readMap(value);\n            default:\n                if (token >= 0xe0) return token - 0x100;\n                if (token === undefined) {\n                    let error = new Error(\"Unexpected end of MessagePack data\");\n                    error.incomplete = true;\n                    throw error;\n                }\n                throw new Error(\"Unknown MessagePack token \" + token);\n        }\n    }\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/;\nfunction createStructureReader(structure, firstId) {\n    function readObject() {\n        // This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n        if (readObject.count++ > inlineObjectReadThreshold) {\n            let readObject = structure.read = new Function(\"r\", \"return function(){return \" + (currentUnpackr.freezeData ? \"Object.freeze\" : \"\") + \"({\" + structure.map((key)=>key === \"__proto__\" ? \"__proto_:r()\" : validName.test(key) ? key + \":r()\" : \"[\" + JSON.stringify(key) + \"]:r()\").join(\",\") + \"})}\")(read);\n            if (structure.highByte === 0) structure.read = createSecondByteReader(firstId, structure.read);\n            return readObject() // second byte is already read, if there is one so immediately read object\n            ;\n        }\n        let object = {};\n        for(let i = 0, l = structure.length; i < l; i++){\n            let key = structure[i];\n            if (key === \"__proto__\") key = \"__proto_\";\n            object[key] = read();\n        }\n        if (currentUnpackr.freezeData) return Object.freeze(object);\n        return object;\n    }\n    readObject.count = 0;\n    if (structure.highByte === 0) {\n        return createSecondByteReader(firstId, readObject);\n    }\n    return readObject;\n}\nconst createSecondByteReader = (firstId, read0)=>{\n    return function() {\n        let highByte = src[position$1++];\n        if (highByte === 0) return read0();\n        let id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5);\n        let structure = currentStructures[id] || loadStructures()[id];\n        if (!structure) {\n            throw new Error(\"Record id is not defined for \" + id);\n        }\n        if (!structure.read) structure.read = createStructureReader(structure, firstId);\n        return structure.read();\n    };\n};\nfunction loadStructures() {\n    let loadedStructures = saveState$1(()=>{\n        // save the state in case getStructures modifies our buffer\n        src = null;\n        return currentUnpackr.getStructures();\n    });\n    return currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures);\n}\nvar readFixedString = readStringJS;\nvar readString8 = readStringJS;\nvar readString16 = readStringJS;\nvar readString32 = readStringJS;\nexports.isNativeAccelerationEnabled = false;\nfunction setExtractor(extractStrings) {\n    exports.isNativeAccelerationEnabled = true;\n    readFixedString = readString(1);\n    readString8 = readString(2);\n    readString16 = readString(3);\n    readString32 = readString(5);\n    function readString(headerLength) {\n        return function readString(length) {\n            let string = strings[stringPosition++];\n            if (string == null) {\n                if (bundledStrings$1) return readStringJS(length);\n                let byteOffset = src.byteOffset;\n                let extraction = extractStrings(position$1 - headerLength + byteOffset, srcEnd + byteOffset, src.buffer);\n                if (typeof extraction == \"string\") {\n                    string = extraction;\n                    strings = EMPTY_ARRAY;\n                } else {\n                    strings = extraction;\n                    stringPosition = 1;\n                    srcStringEnd = 1; // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n                    string = strings[0];\n                    if (string === undefined) throw new Error(\"Unexpected end of buffer\");\n                }\n            }\n            let srcStringLength = string.length;\n            if (srcStringLength <= length) {\n                position$1 += length;\n                return string;\n            }\n            srcString = string;\n            srcStringStart = position$1;\n            srcStringEnd = position$1 + srcStringLength;\n            position$1 += length;\n            return string.slice(0, length) // we know we just want the beginning\n            ;\n        };\n    }\n}\nfunction readStringJS(length) {\n    let result;\n    if (length < 16) {\n        if (result = shortStringInJS(length)) return result;\n    }\n    if (length > 64 && decoder) return decoder.decode(src.subarray(position$1, position$1 += length));\n    const end = position$1 + length;\n    const units = [];\n    result = \"\";\n    while(position$1 < end){\n        const byte1 = src[position$1++];\n        if ((byte1 & 0x80) === 0) {\n            // 1 byte\n            units.push(byte1);\n        } else if ((byte1 & 0xe0) === 0xc0) {\n            // 2 bytes\n            const byte2 = src[position$1++] & 0x3f;\n            units.push((byte1 & 0x1f) << 6 | byte2);\n        } else if ((byte1 & 0xf0) === 0xe0) {\n            // 3 bytes\n            const byte2 = src[position$1++] & 0x3f;\n            const byte3 = src[position$1++] & 0x3f;\n            units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);\n        } else if ((byte1 & 0xf8) === 0xf0) {\n            // 4 bytes\n            const byte2 = src[position$1++] & 0x3f;\n            const byte3 = src[position$1++] & 0x3f;\n            const byte4 = src[position$1++] & 0x3f;\n            let unit = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;\n            if (unit > 0xffff) {\n                unit -= 0x10000;\n                units.push(unit >>> 10 & 0x3ff | 0xd800);\n                unit = 0xdc00 | unit & 0x3ff;\n            }\n            units.push(unit);\n        } else {\n            units.push(byte1);\n        }\n        if (units.length >= 0x1000) {\n            result += fromCharCode.apply(String, units);\n            units.length = 0;\n        }\n    }\n    if (units.length > 0) {\n        result += fromCharCode.apply(String, units);\n    }\n    return result;\n}\nfunction readString(source, start, length) {\n    let existingSrc = src;\n    src = source;\n    position$1 = start;\n    try {\n        return readStringJS(length);\n    } finally{\n        src = existingSrc;\n    }\n}\nfunction readArray(length) {\n    let array = new Array(length);\n    for(let i = 0; i < length; i++){\n        array[i] = read();\n    }\n    if (currentUnpackr.freezeData) return Object.freeze(array);\n    return array;\n}\nfunction readMap(length) {\n    if (currentUnpackr.mapsAsObjects) {\n        let object = {};\n        for(let i = 0; i < length; i++){\n            let key = readKey();\n            if (key === \"__proto__\") key = \"__proto_\";\n            object[key] = read();\n        }\n        return object;\n    } else {\n        let map = new Map();\n        for(let i = 0; i < length; i++){\n            map.set(read(), read());\n        }\n        return map;\n    }\n}\nvar fromCharCode = String.fromCharCode;\nfunction longStringInJS(length) {\n    let start = position$1;\n    let bytes = new Array(length);\n    for(let i = 0; i < length; i++){\n        const byte = src[position$1++];\n        if ((byte & 0x80) > 0) {\n            position$1 = start;\n            return;\n        }\n        bytes[i] = byte;\n    }\n    return fromCharCode.apply(String, bytes);\n}\nfunction shortStringInJS(length) {\n    if (length < 4) {\n        if (length < 2) {\n            if (length === 0) return \"\";\n            else {\n                let a = src[position$1++];\n                if ((a & 0x80) > 1) {\n                    position$1 -= 1;\n                    return;\n                }\n                return fromCharCode(a);\n            }\n        } else {\n            let a = src[position$1++];\n            let b = src[position$1++];\n            if ((a & 0x80) > 0 || (b & 0x80) > 0) {\n                position$1 -= 2;\n                return;\n            }\n            if (length < 3) return fromCharCode(a, b);\n            let c = src[position$1++];\n            if ((c & 0x80) > 0) {\n                position$1 -= 3;\n                return;\n            }\n            return fromCharCode(a, b, c);\n        }\n    } else {\n        let a = src[position$1++];\n        let b = src[position$1++];\n        let c = src[position$1++];\n        let d = src[position$1++];\n        if ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n            position$1 -= 4;\n            return;\n        }\n        if (length < 6) {\n            if (length === 4) return fromCharCode(a, b, c, d);\n            else {\n                let e = src[position$1++];\n                if ((e & 0x80) > 0) {\n                    position$1 -= 5;\n                    return;\n                }\n                return fromCharCode(a, b, c, d, e);\n            }\n        } else if (length < 8) {\n            let e = src[position$1++];\n            let f = src[position$1++];\n            if ((e & 0x80) > 0 || (f & 0x80) > 0) {\n                position$1 -= 6;\n                return;\n            }\n            if (length < 7) return fromCharCode(a, b, c, d, e, f);\n            let g = src[position$1++];\n            if ((g & 0x80) > 0) {\n                position$1 -= 7;\n                return;\n            }\n            return fromCharCode(a, b, c, d, e, f, g);\n        } else {\n            let e = src[position$1++];\n            let f = src[position$1++];\n            let g = src[position$1++];\n            let h = src[position$1++];\n            if ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n                position$1 -= 8;\n                return;\n            }\n            if (length < 10) {\n                if (length === 8) return fromCharCode(a, b, c, d, e, f, g, h);\n                else {\n                    let i = src[position$1++];\n                    if ((i & 0x80) > 0) {\n                        position$1 -= 9;\n                        return;\n                    }\n                    return fromCharCode(a, b, c, d, e, f, g, h, i);\n                }\n            } else if (length < 12) {\n                let i = src[position$1++];\n                let j = src[position$1++];\n                if ((i & 0x80) > 0 || (j & 0x80) > 0) {\n                    position$1 -= 10;\n                    return;\n                }\n                if (length < 11) return fromCharCode(a, b, c, d, e, f, g, h, i, j);\n                let k = src[position$1++];\n                if ((k & 0x80) > 0) {\n                    position$1 -= 11;\n                    return;\n                }\n                return fromCharCode(a, b, c, d, e, f, g, h, i, j, k);\n            } else {\n                let i = src[position$1++];\n                let j = src[position$1++];\n                let k = src[position$1++];\n                let l = src[position$1++];\n                if ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n                    position$1 -= 12;\n                    return;\n                }\n                if (length < 14) {\n                    if (length === 12) return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l);\n                    else {\n                        let m = src[position$1++];\n                        if ((m & 0x80) > 0) {\n                            position$1 -= 13;\n                            return;\n                        }\n                        return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m);\n                    }\n                } else {\n                    let m = src[position$1++];\n                    let n = src[position$1++];\n                    if ((m & 0x80) > 0 || (n & 0x80) > 0) {\n                        position$1 -= 14;\n                        return;\n                    }\n                    if (length < 15) return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n);\n                    let o = src[position$1++];\n                    if ((o & 0x80) > 0) {\n                        position$1 -= 15;\n                        return;\n                    }\n                    return fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o);\n                }\n            }\n        }\n    }\n}\nfunction readOnlyJSString() {\n    let token = src[position$1++];\n    let length;\n    if (token < 0xc0) {\n        // fixstr\n        length = token - 0xa0;\n    } else {\n        switch(token){\n            case 0xd9:\n                // str 8\n                length = src[position$1++];\n                break;\n            case 0xda:\n                // str 16\n                length = dataView.getUint16(position$1);\n                position$1 += 2;\n                break;\n            case 0xdb:\n                // str 32\n                length = dataView.getUint32(position$1);\n                position$1 += 4;\n                break;\n            default:\n                throw new Error(\"Expected string\");\n        }\n    }\n    return readStringJS(length);\n}\nfunction readBin(length) {\n    return currentUnpackr.copyBuffers ? // specifically use the copying slice (not the node one)\n    Uint8Array.prototype.slice.call(src, position$1, position$1 += length) : src.subarray(position$1, position$1 += length);\n}\nfunction readExt(length) {\n    let type = src[position$1++];\n    if (currentExtensions[type]) {\n        let end;\n        return currentExtensions[type](src.subarray(position$1, end = position$1 += length), (readPosition)=>{\n            position$1 = readPosition;\n            try {\n                return read();\n            } finally{\n                position$1 = end;\n            }\n        });\n    } else throw new Error(\"Unknown extension type \" + type);\n}\nvar keyCache = new Array(4096);\nfunction readKey() {\n    let length = src[position$1++];\n    if (length >= 0xa0 && length < 0xc0) {\n        // fixstr, potentially use key cache\n        length = length - 0xa0;\n        if (srcStringEnd >= position$1) return srcString.slice(position$1 - srcStringStart, (position$1 += length) - srcStringStart);\n        else if (!(srcStringEnd == 0 && srcEnd < 180)) return readFixedString(length);\n    } else {\n        position$1--;\n        return asSafeString(read());\n    }\n    let key = (length << 5 ^ (length > 1 ? dataView.getUint16(position$1) : length > 0 ? src[position$1] : 0)) & 0xfff;\n    let entry = keyCache[key];\n    let checkPosition = position$1;\n    let end = position$1 + length - 3;\n    let chunk;\n    let i = 0;\n    if (entry && entry.bytes == length) {\n        while(checkPosition < end){\n            chunk = dataView.getUint32(checkPosition);\n            if (chunk != entry[i++]) {\n                checkPosition = 0x70000000;\n                break;\n            }\n            checkPosition += 4;\n        }\n        end += 3;\n        while(checkPosition < end){\n            chunk = src[checkPosition++];\n            if (chunk != entry[i++]) {\n                checkPosition = 0x70000000;\n                break;\n            }\n        }\n        if (checkPosition === end) {\n            position$1 = checkPosition;\n            return entry.string;\n        }\n        end -= 3;\n        checkPosition = position$1;\n    }\n    entry = [];\n    keyCache[key] = entry;\n    entry.bytes = length;\n    while(checkPosition < end){\n        chunk = dataView.getUint32(checkPosition);\n        entry.push(chunk);\n        checkPosition += 4;\n    }\n    end += 3;\n    while(checkPosition < end){\n        chunk = src[checkPosition++];\n        entry.push(chunk);\n    }\n    // for small blocks, avoiding the overhead of the extract call is helpful\n    let string = length < 16 ? shortStringInJS(length) : longStringInJS(length);\n    if (string != null) return entry.string = string;\n    return entry.string = readFixedString(length);\n}\nfunction asSafeString(property) {\n    // protect against expensive (DoS) string conversions\n    if (typeof property === \"string\") return property;\n    if (typeof property === \"number\" || typeof property === \"boolean\" || typeof property === \"bigint\") return property.toString();\n    if (property == null) return property + \"\";\n    throw new Error(\"Invalid property type for record\", typeof property);\n}\n// the registration of the record definition extension (as \"r\")\nconst recordDefinition = (id, highByte)=>{\n    let structure = read().map(asSafeString); // ensure that all keys are strings and\n    // that the array is mutable\n    let firstByte = id;\n    if (highByte !== undefined) {\n        id = id < 32 ? -((highByte << 5) + id) : (highByte << 5) + id;\n        structure.highByte = highByte;\n    }\n    let existingStructure = currentStructures[id];\n    // If it is a shared structure, we need to restore any changes after reading.\n    // Also in sequential mode, we may get incomplete reads and thus errors, and we need to restore\n    // to the state prior to an incomplete read in order to properly resume.\n    if (existingStructure && (existingStructure.isShared || sequentialMode)) {\n        (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;\n    }\n    currentStructures[id] = structure;\n    structure.read = createStructureReader(structure, firstByte);\n    return structure.read();\n};\ncurrentExtensions[0] = ()=>{}; // notepack defines extension 0 to mean undefined, so use that as the default here\ncurrentExtensions[0].noBuffer = true;\ncurrentExtensions[0x42] = (data)=>{\n    // decode bigint\n    let length = data.length;\n    let value = BigInt(data[0] & 0x80 ? data[0] - 0x100 : data[0]);\n    for(let i = 1; i < length; i++){\n        value <<= BigInt(8);\n        value += BigInt(data[i]);\n    }\n    return value;\n};\nlet errors = {\n    Error,\n    TypeError,\n    ReferenceError\n};\ncurrentExtensions[0x65] = ()=>{\n    let data = read();\n    return (errors[data[0]] || Error)(data[1], {\n        cause: data[2]\n    });\n};\ncurrentExtensions[0x69] = (data)=>{\n    // id extension (for structured clones)\n    if (currentUnpackr.structuredClone === false) throw new Error(\"Structured clone extension is disabled\");\n    let id = dataView.getUint32(position$1 - 4);\n    if (!referenceMap) referenceMap = new Map();\n    let token = src[position$1];\n    let target;\n    // TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n    // ahead past references to record structure definitions\n    if (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd) target = [];\n    else target = {};\n    let refEntry = {\n        target\n    }; // a placeholder object\n    referenceMap.set(id, refEntry);\n    let targetProperties = read(); // read the next value as the target object to id\n    if (refEntry.used) return Object.assign(target, targetProperties);\n    refEntry.target = targetProperties; // the placeholder wasn't used, replace with the deserialized one\n    return targetProperties // no cycle, can just use the returned read object\n    ;\n};\ncurrentExtensions[0x70] = (data)=>{\n    // pointer extension (for structured clones)\n    if (currentUnpackr.structuredClone === false) throw new Error(\"Structured clone extension is disabled\");\n    let id = dataView.getUint32(position$1 - 4);\n    let refEntry = referenceMap.get(id);\n    refEntry.used = true;\n    return refEntry.target;\n};\ncurrentExtensions[0x73] = ()=>new Set(read());\nconst typedArrays = [\n    \"Int8\",\n    \"Uint8\",\n    \"Uint8Clamped\",\n    \"Int16\",\n    \"Uint16\",\n    \"Int32\",\n    \"Uint32\",\n    \"Float32\",\n    \"Float64\",\n    \"BigInt64\",\n    \"BigUint64\"\n].map((type)=>type + \"Array\");\nlet glbl = typeof globalThis === \"object\" ? globalThis : window;\ncurrentExtensions[0x74] = (data)=>{\n    let typeCode = data[0];\n    let typedArrayName = typedArrays[typeCode];\n    if (!typedArrayName) {\n        if (typeCode === 16) {\n            let ab = new ArrayBuffer(data.length - 1);\n            let u8 = new Uint8Array(ab);\n            u8.set(data.subarray(1));\n            return ab;\n        }\n        throw new Error(\"Could not find typed array for code \" + typeCode);\n    }\n    // we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n    return new glbl[typedArrayName](Uint8Array.prototype.slice.call(data, 1).buffer);\n};\ncurrentExtensions[0x78] = ()=>{\n    let data = read();\n    return new RegExp(data[0], data[1]);\n};\nconst TEMP_BUNDLE = [];\ncurrentExtensions[0x62] = (data)=>{\n    let dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3];\n    let dataPosition = position$1;\n    position$1 += dataSize - data.length;\n    bundledStrings$1 = TEMP_BUNDLE;\n    bundledStrings$1 = [\n        readOnlyJSString(),\n        readOnlyJSString()\n    ];\n    bundledStrings$1.position0 = 0;\n    bundledStrings$1.position1 = 0;\n    bundledStrings$1.postBundlePosition = position$1;\n    position$1 = dataPosition;\n    return read();\n};\ncurrentExtensions[0xff] = (data)=>{\n    // 32-bit date extension\n    if (data.length == 4) return new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000);\n    else if (data.length == 8) return new Date(((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 + ((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000);\n    else if (data.length == 12) return new Date(((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 + ((data[4] & 0x80 ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000);\n    else return new Date(\"invalid\");\n}; // notepack defines extension 0 to mean undefined, so use that as the default here\n// registration of bulk record definition?\n// currentExtensions[0x52] = () =>\nfunction saveState$1(callback) {\n    if (onSaveState) onSaveState();\n    let savedSrcEnd = srcEnd;\n    let savedPosition = position$1;\n    let savedStringPosition = stringPosition;\n    let savedSrcStringStart = srcStringStart;\n    let savedSrcStringEnd = srcStringEnd;\n    let savedSrcString = srcString;\n    let savedStrings = strings;\n    let savedReferenceMap = referenceMap;\n    let savedBundledStrings = bundledStrings$1;\n    // TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n    let savedSrc = new Uint8Array(src.slice(0, srcEnd)); // we copy the data in case it changes while external data is processed\n    let savedStructures = currentStructures;\n    let savedStructuresContents = currentStructures.slice(0, currentStructures.length);\n    let savedPackr = currentUnpackr;\n    let savedSequentialMode = sequentialMode;\n    let value = callback();\n    srcEnd = savedSrcEnd;\n    position$1 = savedPosition;\n    stringPosition = savedStringPosition;\n    srcStringStart = savedSrcStringStart;\n    srcStringEnd = savedSrcStringEnd;\n    srcString = savedSrcString;\n    strings = savedStrings;\n    referenceMap = savedReferenceMap;\n    bundledStrings$1 = savedBundledStrings;\n    src = savedSrc;\n    sequentialMode = savedSequentialMode;\n    currentStructures = savedStructures;\n    currentStructures.splice(0, currentStructures.length, ...savedStructuresContents);\n    currentUnpackr = savedPackr;\n    dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);\n    return value;\n}\nfunction clearSource() {\n    src = null;\n    referenceMap = null;\n    currentStructures = null;\n}\nfunction addExtension$1(extension) {\n    if (extension.unpack) currentExtensions[extension.type] = extension.unpack;\n    else currentExtensions[extension.type] = extension;\n}\nconst mult10 = new Array(147); // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor(let i = 0; i < 256; i++){\n    mult10[i] = +(\"1e\" + Math.floor(45.15 - i * 0.30103));\n}\nconst Decoder = Unpackr;\nvar defaultUnpackr = new Unpackr({\n    useRecords: false\n});\nconst unpack = defaultUnpackr.unpack;\nconst unpackMultiple = defaultUnpackr.unpackMultiple;\nconst decode = defaultUnpackr.unpack;\nconst FLOAT32_OPTIONS = {\n    NEVER: 0,\n    ALWAYS: 1,\n    DECIMAL_ROUND: 3,\n    DECIMAL_FIT: 4\n};\nlet f32Array = new Float32Array(1);\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4);\nfunction roundFloat32(float32Number) {\n    f32Array[0] = float32Number;\n    let multiplier = mult10[(u8Array[3] & 0x7f) << 1 | u8Array[2] >> 7];\n    return (multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5) >> 0) / multiplier;\n}\nfunction setReadStruct(updatedReadStruct, loadedStructs, saveState) {\n    readStruct$1 = updatedReadStruct;\n    onLoadedStructures$1 = loadedStructs;\n    onSaveState = saveState;\n}\nlet textEncoder$1;\ntry {\n    textEncoder$1 = new TextEncoder();\n} catch (error) {}\nlet extensions, extensionClasses;\nconst hasNodeBuffer$1 = typeof Buffer !== \"undefined\";\nconst ByteArrayAllocate = hasNodeBuffer$1 ? function(length) {\n    return Buffer.allocUnsafeSlow(length);\n} : Uint8Array;\nconst ByteArray = hasNodeBuffer$1 ? Buffer : Uint8Array;\nconst MAX_BUFFER_SIZE = hasNodeBuffer$1 ? 0x100000000 : 0x7fd00000;\nlet target, keysTarget;\nlet targetView;\nlet position = 0;\nlet safeEnd;\nlet bundledStrings = null;\nlet writeStructSlots;\nconst MAX_BUNDLE_SIZE = 0x5500; // maximum characters such that the encoded bytes fits in 16 bits.\nconst hasNonLatin = /[\\u0080-\\uFFFF]/;\nconst RECORD_SYMBOL = Symbol(\"record-id\");\nclass Packr extends Unpackr {\n    constructor(options){\n        super(options);\n        this.offset = 0;\n        let start;\n        let hasSharedUpdate;\n        let structures;\n        let referenceMap;\n        let encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {\n            return target.utf8Write(string, position, target.byteLength - position);\n        } : textEncoder$1 && textEncoder$1.encodeInto ? function(string, position) {\n            return textEncoder$1.encodeInto(string, target.subarray(position)).written;\n        } : false;\n        let packr = this;\n        if (!options) options = {};\n        let isSequential = options && options.sequential;\n        let hasSharedStructures = options.structures || options.saveStructures;\n        let maxSharedStructures = options.maxSharedStructures;\n        if (maxSharedStructures == null) maxSharedStructures = hasSharedStructures ? 32 : 0;\n        if (maxSharedStructures > 8160) throw new Error(\"Maximum maxSharedStructure is 8160\");\n        if (options.structuredClone && options.moreTypes == undefined) {\n            this.moreTypes = true;\n        }\n        let maxOwnStructures = options.maxOwnStructures;\n        if (maxOwnStructures == null) maxOwnStructures = hasSharedStructures ? 32 : 64;\n        if (!this.structures && options.useRecords != false) this.structures = [];\n        // two byte record ids for shared structures\n        let useTwoByteRecords = maxSharedStructures > 32 || maxOwnStructures + maxSharedStructures > 64;\n        let sharedLimitId = maxSharedStructures + 0x40;\n        let maxStructureId = maxSharedStructures + maxOwnStructures + 0x40;\n        if (maxStructureId > 8256) {\n            throw new Error(\"Maximum maxSharedStructure + maxOwnStructure is 8192\");\n        }\n        let recordIdsToRemove = [];\n        let transitionsCount = 0;\n        let serializationsSinceTransitionRebuild = 0;\n        this.pack = this.encode = function(value, encodeOptions) {\n            if (!target) {\n                target = new ByteArrayAllocate(8192);\n                targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192));\n                position = 0;\n            }\n            safeEnd = target.length - 10;\n            if (safeEnd - position < 0x800) {\n                // don't start too close to the end,\n                target = new ByteArrayAllocate(target.length);\n                targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length));\n                safeEnd = target.length - 10;\n                position = 0;\n            } else position = position + 7 & 0x7ffffff8; // Word align to make any future copying of this buffer faster\n            start = position;\n            if (encodeOptions & RESERVE_START_SPACE) position += encodeOptions & 0xff;\n            referenceMap = packr.structuredClone ? new Map() : null;\n            if (packr.bundleStrings && typeof value !== \"string\") {\n                bundledStrings = [];\n                bundledStrings.size = Infinity; // force a new bundle start on first string\n            } else bundledStrings = null;\n            structures = packr.structures;\n            if (structures) {\n                if (structures.uninitialized) structures = packr._mergeStructures(packr.getStructures());\n                let sharedLength = structures.sharedLength || 0;\n                if (sharedLength > maxSharedStructures) {\n                    //if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids\n                    throw new Error(\"Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to \" + structures.sharedLength);\n                }\n                if (!structures.transitions) {\n                    // rebuild our structure transitions\n                    structures.transitions = Object.create(null);\n                    for(let i = 0; i < sharedLength; i++){\n                        let keys = structures[i];\n                        if (!keys) continue;\n                        let nextTransition, transition = structures.transitions;\n                        for(let j = 0, l = keys.length; j < l; j++){\n                            let key = keys[j];\n                            nextTransition = transition[key];\n                            if (!nextTransition) {\n                                nextTransition = transition[key] = Object.create(null);\n                            }\n                            transition = nextTransition;\n                        }\n                        transition[RECORD_SYMBOL] = i + 0x40;\n                    }\n                    this.lastNamedStructuresLength = sharedLength;\n                }\n                if (!isSequential) {\n                    structures.nextId = sharedLength + 0x40;\n                }\n            }\n            if (hasSharedUpdate) hasSharedUpdate = false;\n            let encodingError;\n            try {\n                if (packr.randomAccessStructure && value && value.constructor && value.constructor === Object) writeStruct(value);\n                else pack(value);\n                let lastBundle = bundledStrings;\n                if (bundledStrings) writeBundles(start, pack, 0);\n                if (referenceMap && referenceMap.idsToInsert) {\n                    let idsToInsert = referenceMap.idsToInsert.sort((a, b)=>a.offset > b.offset ? 1 : -1);\n                    let i = idsToInsert.length;\n                    let incrementPosition = -1;\n                    while(lastBundle && i > 0){\n                        let insertionPoint = idsToInsert[--i].offset + start;\n                        if (insertionPoint < lastBundle.stringsPosition + start && incrementPosition === -1) incrementPosition = 0;\n                        if (insertionPoint > lastBundle.position + start) {\n                            if (incrementPosition >= 0) incrementPosition += 6;\n                        } else {\n                            if (incrementPosition >= 0) {\n                                // update the bundle reference now\n                                targetView.setUint32(lastBundle.position + start, targetView.getUint32(lastBundle.position + start) + incrementPosition);\n                                incrementPosition = -1; // reset\n                            }\n                            lastBundle = lastBundle.previous;\n                            i++;\n                        }\n                    }\n                    if (incrementPosition >= 0 && lastBundle) {\n                        // update the bundle reference now\n                        targetView.setUint32(lastBundle.position + start, targetView.getUint32(lastBundle.position + start) + incrementPosition);\n                    }\n                    position += idsToInsert.length * 6;\n                    if (position > safeEnd) makeRoom(position);\n                    packr.offset = position;\n                    let serialized = insertIds(target.subarray(start, position), idsToInsert);\n                    referenceMap = null;\n                    return serialized;\n                }\n                packr.offset = position; // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n                if (encodeOptions & REUSE_BUFFER_MODE) {\n                    target.start = start;\n                    target.end = position;\n                    return target;\n                }\n                return target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\n                ;\n            } catch (error) {\n                encodingError = error;\n                throw error;\n            } finally{\n                if (structures) {\n                    resetStructures();\n                    if (hasSharedUpdate && packr.saveStructures) {\n                        let sharedLength = structures.sharedLength || 0;\n                        // we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n                        let returnBuffer = target.subarray(start, position);\n                        let newSharedData = prepareStructures$1(structures, packr);\n                        if (!encodingError) {\n                            if (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {\n                                // get updated structures and try again if the update failed\n                                return packr.pack(value, encodeOptions);\n                            }\n                            packr.lastNamedStructuresLength = sharedLength;\n                            // don't keep large buffers around\n                            if (target.length > 0x40000000) target = null;\n                            return returnBuffer;\n                        }\n                    }\n                }\n                // don't keep large buffers around, they take too much memory and cause problems (limit at 1GB)\n                if (target.length > 0x40000000) target = null;\n                if (encodeOptions & RESET_BUFFER_MODE) position = start;\n            }\n        };\n        const resetStructures = ()=>{\n            if (serializationsSinceTransitionRebuild < 10) serializationsSinceTransitionRebuild++;\n            let sharedLength = structures.sharedLength || 0;\n            if (structures.length > sharedLength && !isSequential) structures.length = sharedLength;\n            if (transitionsCount > 10000) {\n                // force a rebuild occasionally after a lot of transitions so it can get cleaned up\n                structures.transitions = null;\n                serializationsSinceTransitionRebuild = 0;\n                transitionsCount = 0;\n                if (recordIdsToRemove.length > 0) recordIdsToRemove = [];\n            } else if (recordIdsToRemove.length > 0 && !isSequential) {\n                for(let i = 0, l = recordIdsToRemove.length; i < l; i++){\n                    recordIdsToRemove[i][RECORD_SYMBOL] = 0;\n                }\n                recordIdsToRemove = [];\n            }\n        };\n        const packArray = (value)=>{\n            var length = value.length;\n            if (length < 0x10) {\n                target[position++] = 0x90 | length;\n            } else if (length < 0x10000) {\n                target[position++] = 0xdc;\n                target[position++] = length >> 8;\n                target[position++] = length & 0xff;\n            } else {\n                target[position++] = 0xdd;\n                targetView.setUint32(position, length);\n                position += 4;\n            }\n            for(let i = 0; i < length; i++){\n                pack(value[i]);\n            }\n        };\n        const pack = (value)=>{\n            if (position > safeEnd) target = makeRoom(position);\n            var type = typeof value;\n            var length;\n            if (type === \"string\") {\n                let strLength = value.length;\n                if (bundledStrings && strLength >= 4 && strLength < 0x1000) {\n                    if ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n                        let extStart;\n                        let maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10;\n                        if (position + maxBytes > safeEnd) target = makeRoom(position + maxBytes);\n                        let lastBundle;\n                        if (bundledStrings.position) {\n                            lastBundle = bundledStrings;\n                            target[position] = 0xc8; // ext 16\n                            position += 3; // reserve for the writing bundle size\n                            target[position++] = 0x62; // 'b'\n                            extStart = position - start;\n                            position += 4; // reserve for writing bundle reference\n                            writeBundles(start, pack, 0); // write the last bundles\n                            targetView.setUint16(extStart + start - 3, position - start - extStart);\n                        } else {\n                            target[position++] = 0xd6; // fixext 4\n                            target[position++] = 0x62; // 'b'\n                            extStart = position - start;\n                            position += 4; // reserve for writing bundle reference\n                        }\n                        bundledStrings = [\n                            \"\",\n                            \"\"\n                        ]; // create new ones\n                        bundledStrings.previous = lastBundle;\n                        bundledStrings.size = 0;\n                        bundledStrings.position = extStart;\n                    }\n                    let twoByte = hasNonLatin.test(value);\n                    bundledStrings[twoByte ? 0 : 1] += value;\n                    target[position++] = 0xc1;\n                    pack(twoByte ? -strLength : strLength);\n                    return;\n                }\n                let headerSize;\n                // first we estimate the header size, so we can write to the correct location\n                if (strLength < 0x20) {\n                    headerSize = 1;\n                } else if (strLength < 0x100) {\n                    headerSize = 2;\n                } else if (strLength < 0x10000) {\n                    headerSize = 3;\n                } else {\n                    headerSize = 5;\n                }\n                let maxBytes = strLength * 3;\n                if (position + maxBytes > safeEnd) target = makeRoom(position + maxBytes);\n                if (strLength < 0x40 || !encodeUtf8) {\n                    let i, c1, c2, strPosition = position + headerSize;\n                    for(i = 0; i < strLength; i++){\n                        c1 = value.charCodeAt(i);\n                        if (c1 < 0x80) {\n                            target[strPosition++] = c1;\n                        } else if (c1 < 0x800) {\n                            target[strPosition++] = c1 >> 6 | 0xc0;\n                            target[strPosition++] = c1 & 0x3f | 0x80;\n                        } else if ((c1 & 0xfc00) === 0xd800 && ((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00) {\n                            c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n                            i++;\n                            target[strPosition++] = c1 >> 18 | 0xf0;\n                            target[strPosition++] = c1 >> 12 & 0x3f | 0x80;\n                            target[strPosition++] = c1 >> 6 & 0x3f | 0x80;\n                            target[strPosition++] = c1 & 0x3f | 0x80;\n                        } else {\n                            target[strPosition++] = c1 >> 12 | 0xe0;\n                            target[strPosition++] = c1 >> 6 & 0x3f | 0x80;\n                            target[strPosition++] = c1 & 0x3f | 0x80;\n                        }\n                    }\n                    length = strPosition - position - headerSize;\n                } else {\n                    length = encodeUtf8(value, position + headerSize);\n                }\n                if (length < 0x20) {\n                    target[position++] = 0xa0 | length;\n                } else if (length < 0x100) {\n                    if (headerSize < 2) {\n                        target.copyWithin(position + 2, position + 1, position + 1 + length);\n                    }\n                    target[position++] = 0xd9;\n                    target[position++] = length;\n                } else if (length < 0x10000) {\n                    if (headerSize < 3) {\n                        target.copyWithin(position + 3, position + 2, position + 2 + length);\n                    }\n                    target[position++] = 0xda;\n                    target[position++] = length >> 8;\n                    target[position++] = length & 0xff;\n                } else {\n                    if (headerSize < 5) {\n                        target.copyWithin(position + 5, position + 3, position + 3 + length);\n                    }\n                    target[position++] = 0xdb;\n                    targetView.setUint32(position, length);\n                    position += 4;\n                }\n                position += length;\n            } else if (type === \"number\") {\n                if (value >>> 0 === value) {\n                    // positive uint\n                    if (value < 0x20 || value < 0x80 && this.useRecords === false || value < 0x40 && !this.randomAccessStructure) {\n                        target[position++] = value;\n                    } else if (value < 0x100) {\n                        target[position++] = 0xcc;\n                        target[position++] = value;\n                    } else if (value < 0x10000) {\n                        target[position++] = 0xcd;\n                        target[position++] = value >> 8;\n                        target[position++] = value & 0xff;\n                    } else {\n                        target[position++] = 0xce;\n                        targetView.setUint32(position, value);\n                        position += 4;\n                    }\n                } else if (value >> 0 === value) {\n                    if (value >= -0x20) {\n                        target[position++] = 0x100 + value;\n                    } else if (value >= -0x80) {\n                        target[position++] = 0xd0;\n                        target[position++] = value + 0x100;\n                    } else if (value >= -0x8000) {\n                        target[position++] = 0xd1;\n                        targetView.setInt16(position, value);\n                        position += 2;\n                    } else {\n                        target[position++] = 0xd2;\n                        targetView.setInt32(position, value);\n                        position += 4;\n                    }\n                } else {\n                    let useFloat32;\n                    if ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n                        target[position++] = 0xca;\n                        targetView.setFloat32(position, value);\n                        let xShifted;\n                        if (useFloat32 < 4 || (xShifted = value * mult10[(target[position] & 0x7f) << 1 | target[position + 1] >> 7]) >> 0 === xShifted) {\n                            position += 4;\n                            return;\n                        } else position--; // move back into position for writing a double\n                    }\n                    target[position++] = 0xcb;\n                    targetView.setFloat64(position, value);\n                    position += 8;\n                }\n            } else if (type === \"object\" || type === \"function\") {\n                if (!value) target[position++] = 0xc0;\n                else {\n                    if (referenceMap) {\n                        let referee = referenceMap.get(value);\n                        if (referee) {\n                            if (!referee.id) {\n                                let idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = []);\n                                referee.id = idsToInsert.push(referee);\n                            }\n                            target[position++] = 0xd6; // fixext 4\n                            target[position++] = 0x70; // \"p\" for pointer\n                            targetView.setUint32(position, referee.id);\n                            position += 4;\n                            return;\n                        } else referenceMap.set(value, {\n                            offset: position - start\n                        });\n                    }\n                    let constructor = value.constructor;\n                    if (constructor === Object) {\n                        writeObject(value);\n                    } else if (constructor === Array) {\n                        packArray(value);\n                    } else if (constructor === Map) {\n                        if (this.mapAsEmptyObject) target[position++] = 0x80;\n                        else {\n                            length = value.size;\n                            if (length < 0x10) {\n                                target[position++] = 0x80 | length;\n                            } else if (length < 0x10000) {\n                                target[position++] = 0xde;\n                                target[position++] = length >> 8;\n                                target[position++] = length & 0xff;\n                            } else {\n                                target[position++] = 0xdf;\n                                targetView.setUint32(position, length);\n                                position += 4;\n                            }\n                            for (let [key, entryValue] of value){\n                                pack(key);\n                                pack(entryValue);\n                            }\n                        }\n                    } else {\n                        for(let i = 0, l = extensions.length; i < l; i++){\n                            let extensionClass = extensionClasses[i];\n                            if (value instanceof extensionClass) {\n                                let extension = extensions[i];\n                                if (extension.write) {\n                                    if (extension.type) {\n                                        target[position++] = 0xd4; // one byte \"tag\" extension\n                                        target[position++] = extension.type;\n                                        target[position++] = 0;\n                                    }\n                                    let writeResult = extension.write.call(this, value);\n                                    if (writeResult === value) {\n                                        if (Array.isArray(value)) {\n                                            packArray(value);\n                                        } else {\n                                            writeObject(value);\n                                        }\n                                    } else {\n                                        pack(writeResult);\n                                    }\n                                    return;\n                                }\n                                let currentTarget = target;\n                                let currentTargetView = targetView;\n                                let currentPosition = position;\n                                target = null;\n                                let result;\n                                try {\n                                    result = extension.pack.call(this, value, (size)=>{\n                                        // restore target and use it\n                                        target = currentTarget;\n                                        currentTarget = null;\n                                        position += size;\n                                        if (position > safeEnd) makeRoom(position);\n                                        return {\n                                            target,\n                                            targetView,\n                                            position: position - size\n                                        };\n                                    }, pack);\n                                } finally{\n                                    // restore current target information (unless already restored)\n                                    if (currentTarget) {\n                                        target = currentTarget;\n                                        targetView = currentTargetView;\n                                        position = currentPosition;\n                                        safeEnd = target.length - 10;\n                                    }\n                                }\n                                if (result) {\n                                    if (result.length + position > safeEnd) makeRoom(result.length + position);\n                                    position = writeExtensionData(result, target, position, extension.type);\n                                }\n                                return;\n                            }\n                        }\n                        // check isArray after extensions, because extensions can extend Array\n                        if (Array.isArray(value)) {\n                            packArray(value);\n                        } else {\n                            // use this as an alternate mechanism for expressing how to serialize\n                            if (value.toJSON) {\n                                const json = value.toJSON();\n                                // if for some reason value.toJSON returns itself it'll loop forever\n                                if (json !== value) return pack(json);\n                            }\n                            // if there is a writeFunction, use it, otherwise just encode as undefined\n                            if (type === \"function\") return pack(this.writeFunction && this.writeFunction(value));\n                            // no extension found, write as plain object\n                            writeObject(value);\n                        }\n                    }\n                }\n            } else if (type === \"boolean\") {\n                target[position++] = value ? 0xc3 : 0xc2;\n            } else if (type === \"bigint\") {\n                if (value < BigInt(1) << BigInt(63) && value >= -(BigInt(1) << BigInt(63))) {\n                    // use a signed int as long as it fits\n                    target[position++] = 0xd3;\n                    targetView.setBigInt64(position, value);\n                } else if (value < BigInt(1) << BigInt(64) && value > 0) {\n                    // if we can fit an unsigned int, use that\n                    target[position++] = 0xcf;\n                    targetView.setBigUint64(position, value);\n                } else {\n                    // overflow\n                    if (this.largeBigIntToFloat) {\n                        target[position++] = 0xcb;\n                        targetView.setFloat64(position, Number(value));\n                    } else if (this.largeBigIntToString) {\n                        return pack(value.toString());\n                    } else if (this.useBigIntExtension && value < BigInt(2) ** BigInt(1023) && value > -(BigInt(2) ** BigInt(1023))) {\n                        target[position++] = 0xc7;\n                        position++;\n                        target[position++] = 0x42; // \"B\" for BigInt\n                        let bytes = [];\n                        let alignedSign;\n                        do {\n                            let byte = value & BigInt(0xff);\n                            alignedSign = (byte & BigInt(0x80)) === (value < BigInt(0) ? BigInt(0x80) : BigInt(0));\n                            bytes.push(byte);\n                            value >>= BigInt(8);\n                        }while (!((value === BigInt(0) || value === BigInt(-1)) && alignedSign));\n                        target[position - 2] = bytes.length;\n                        for(let i = bytes.length; i > 0;){\n                            target[position++] = Number(bytes[--i]);\n                        }\n                        return;\n                    } else {\n                        throw new RangeError(value + \" was too large to fit in MessagePack 64-bit integer format, use\" + \" useBigIntExtension, or set largeBigIntToFloat to convert to float-64, or set\" + \" largeBigIntToString to convert to string\");\n                    }\n                }\n                position += 8;\n            } else if (type === \"undefined\") {\n                if (this.encodeUndefinedAsNil) target[position++] = 0xc0;\n                else {\n                    target[position++] = 0xd4; // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\n                    target[position++] = 0;\n                    target[position++] = 0;\n                }\n            } else {\n                throw new Error(\"Unknown type: \" + type);\n            }\n        };\n        const writePlainObject = this.variableMapSize || this.coercibleKeyAsNumber || this.skipValues ? (object)=>{\n            // this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n            let keys;\n            if (this.skipValues) {\n                keys = [];\n                for(let key in object){\n                    if ((typeof object.hasOwnProperty !== \"function\" || object.hasOwnProperty(key)) && !this.skipValues.includes(object[key])) keys.push(key);\n                }\n            } else {\n                keys = Object.keys(object);\n            }\n            let length = keys.length;\n            if (length < 0x10) {\n                target[position++] = 0x80 | length;\n            } else if (length < 0x10000) {\n                target[position++] = 0xde;\n                target[position++] = length >> 8;\n                target[position++] = length & 0xff;\n            } else {\n                target[position++] = 0xdf;\n                targetView.setUint32(position, length);\n                position += 4;\n            }\n            let key;\n            if (this.coercibleKeyAsNumber) {\n                for(let i = 0; i < length; i++){\n                    key = keys[i];\n                    let num = Number(key);\n                    pack(isNaN(num) ? key : num);\n                    pack(object[key]);\n                }\n            } else {\n                for(let i = 0; i < length; i++){\n                    pack(key = keys[i]);\n                    pack(object[key]);\n                }\n            }\n        } : (object)=>{\n            target[position++] = 0xde; // always using map 16, so we can preallocate and set the length afterwards\n            let objectOffset = position - start;\n            position += 2;\n            let size = 0;\n            for(let key in object){\n                if (typeof object.hasOwnProperty !== \"function\" || object.hasOwnProperty(key)) {\n                    pack(key);\n                    pack(object[key]);\n                    size++;\n                }\n            }\n            if (size > 0xffff) {\n                throw new Error(\"Object is too large to serialize with fast 16-bit map size,\" + ' use the \"variableMapSize\" option to serialize this object');\n            }\n            target[objectOffset++ + start] = size >> 8;\n            target[objectOffset + start] = size & 0xff;\n        };\n        const writeRecord = this.useRecords === false ? writePlainObject : options.progressiveRecords && !useTwoByteRecords ? (object)=>{\n            let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null));\n            let objectOffset = position++ - start;\n            let wroteKeys;\n            for(let key in object){\n                if (typeof object.hasOwnProperty !== \"function\" || object.hasOwnProperty(key)) {\n                    nextTransition = transition[key];\n                    if (nextTransition) transition = nextTransition;\n                    else {\n                        // record doesn't exist, create full new record and insert it\n                        let keys = Object.keys(object);\n                        let lastTransition = transition;\n                        transition = structures.transitions;\n                        let newTransitions = 0;\n                        for(let i = 0, l = keys.length; i < l; i++){\n                            let key = keys[i];\n                            nextTransition = transition[key];\n                            if (!nextTransition) {\n                                nextTransition = transition[key] = Object.create(null);\n                                newTransitions++;\n                            }\n                            transition = nextTransition;\n                        }\n                        if (objectOffset + start + 1 == position) {\n                            // first key, so we don't need to insert, we can just write record directly\n                            position--;\n                            newRecord(transition, keys, newTransitions);\n                        } else insertNewRecord(transition, keys, objectOffset, newTransitions);\n                        wroteKeys = true;\n                        transition = lastTransition[key];\n                    }\n                    pack(object[key]);\n                }\n            }\n            if (!wroteKeys) {\n                let recordId = transition[RECORD_SYMBOL];\n                if (recordId) target[objectOffset + start] = recordId;\n                else insertNewRecord(transition, Object.keys(object), objectOffset, 0);\n            }\n        } : (object)=>{\n            let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null));\n            let newTransitions = 0;\n            for(let key in object)if (typeof object.hasOwnProperty !== \"function\" || object.hasOwnProperty(key)) {\n                nextTransition = transition[key];\n                if (!nextTransition) {\n                    nextTransition = transition[key] = Object.create(null);\n                    newTransitions++;\n                }\n                transition = nextTransition;\n            }\n            let recordId = transition[RECORD_SYMBOL];\n            if (recordId) {\n                if (recordId >= 0x60 && useTwoByteRecords) {\n                    target[position++] = ((recordId -= 0x60) & 0x1f) + 0x60;\n                    target[position++] = recordId >> 5;\n                } else target[position++] = recordId;\n            } else {\n                newRecord(transition, transition.__keys__ || Object.keys(object), newTransitions);\n            }\n            // now write the values\n            for(let key in object)if (typeof object.hasOwnProperty !== \"function\" || object.hasOwnProperty(key)) {\n                pack(object[key]);\n            }\n        };\n        // create reference to useRecords if useRecords is a function\n        const checkUseRecords = typeof this.useRecords == \"function\" && this.useRecords;\n        const writeObject = checkUseRecords ? (object)=>{\n            checkUseRecords(object) ? writeRecord(object) : writePlainObject(object);\n        } : writeRecord;\n        const makeRoom = (end)=>{\n            let newSize;\n            if (end > 0x1000000) {\n                // special handling for really large buffers\n                if (end - start > MAX_BUFFER_SIZE) throw new Error(\"Packed buffer would be larger than maximum buffer size\");\n                newSize = Math.min(MAX_BUFFER_SIZE, Math.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000);\n            } else newSize = (Math.max(end - start << 2, target.length - 1) >> 12) + 1 << 12;\n            let newBuffer = new ByteArrayAllocate(newSize);\n            targetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize));\n            end = Math.min(end, target.length);\n            if (target.copy) target.copy(newBuffer, 0, start, end);\n            else newBuffer.set(target.slice(start, end));\n            position -= start;\n            start = 0;\n            safeEnd = newBuffer.length - 10;\n            return target = newBuffer;\n        };\n        const newRecord = (transition, keys, newTransitions)=>{\n            let recordId = structures.nextId;\n            if (!recordId) recordId = 0x40;\n            if (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {\n                recordId = structures.nextOwnId;\n                if (!(recordId < maxStructureId)) recordId = sharedLimitId;\n                structures.nextOwnId = recordId + 1;\n            } else {\n                if (recordId >= maxStructureId) recordId = sharedLimitId;\n                structures.nextId = recordId + 1;\n            }\n            let highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? recordId - 0x60 >> 5 : -1;\n            transition[RECORD_SYMBOL] = recordId;\n            transition.__keys__ = keys;\n            structures[recordId - 0x40] = keys;\n            if (recordId < sharedLimitId) {\n                keys.isShared = true;\n                structures.sharedLength = recordId - 0x3f;\n                hasSharedUpdate = true;\n                if (highByte >= 0) {\n                    target[position++] = (recordId & 0x1f) + 0x60;\n                    target[position++] = highByte;\n                } else {\n                    target[position++] = recordId;\n                }\n            } else {\n                if (highByte >= 0) {\n                    target[position++] = 0xd5; // fixext 2\n                    target[position++] = 0x72; // \"r\" record defintion extension type\n                    target[position++] = (recordId & 0x1f) + 0x60;\n                    target[position++] = highByte;\n                } else {\n                    target[position++] = 0xd4; // fixext 1\n                    target[position++] = 0x72; // \"r\" record defintion extension type\n                    target[position++] = recordId;\n                }\n                if (newTransitions) transitionsCount += serializationsSinceTransitionRebuild * newTransitions;\n                // record the removal of the id, we can maintain our shared structure\n                if (recordIdsToRemove.length >= maxOwnStructures) recordIdsToRemove.shift()[RECORD_SYMBOL] = 0; // we are cycling back through, and have to remove old ones\n                recordIdsToRemove.push(transition);\n                pack(keys);\n            }\n        };\n        const insertNewRecord = (transition, keys, insertionOffset, newTransitions)=>{\n            let mainTarget = target;\n            let mainPosition = position;\n            let mainSafeEnd = safeEnd;\n            let mainStart = start;\n            target = keysTarget;\n            position = 0;\n            start = 0;\n            if (!target) keysTarget = target = new ByteArrayAllocate(8192);\n            safeEnd = target.length - 10;\n            newRecord(transition, keys, newTransitions);\n            keysTarget = target;\n            let keysPosition = position;\n            target = mainTarget;\n            position = mainPosition;\n            safeEnd = mainSafeEnd;\n            start = mainStart;\n            if (keysPosition > 1) {\n                let newEnd = position + keysPosition - 1;\n                if (newEnd > safeEnd) makeRoom(newEnd);\n                let insertionPosition = insertionOffset + start;\n                target.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position);\n                target.set(keysTarget.slice(0, keysPosition), insertionPosition);\n                position = newEnd;\n            } else {\n                target[insertionOffset + start] = keysTarget[0];\n            }\n        };\n        const writeStruct = (object)=>{\n            let newPosition = writeStructSlots(object, target, start, position, structures, makeRoom, (value, newPosition, notifySharedUpdate)=>{\n                if (notifySharedUpdate) return hasSharedUpdate = true;\n                position = newPosition;\n                let startTarget = target;\n                pack(value);\n                resetStructures();\n                if (startTarget !== target) {\n                    return {\n                        position,\n                        targetView,\n                        target\n                    }; // indicate the buffer was re-allocated\n                }\n                return position;\n            }, this);\n            if (newPosition === 0) return writeObject(object);\n            position = newPosition;\n        };\n    }\n    useBuffer(buffer) {\n        // this means we are finished using our own buffer and we can write over it safely\n        target = buffer;\n        target.dataView || (target.dataView = new DataView(target.buffer, target.byteOffset, target.byteLength));\n        position = 0;\n    }\n    set position(value) {\n        position = value;\n    }\n    get position() {\n        return position;\n    }\n    clearSharedData() {\n        if (this.structures) this.structures = [];\n        if (this.typedStructs) this.typedStructs = [];\n    }\n}\nextensionClasses = [\n    Date,\n    Set,\n    Error,\n    RegExp,\n    ArrayBuffer,\n    Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/ ,\n    C1Type\n];\nextensions = [\n    {\n        pack (date, allocateForWrite, pack) {\n            let seconds = date.getTime() / 1000;\n            if ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n                // Timestamp 32\n                let { target, targetView, position } = allocateForWrite(6);\n                target[position++] = 0xd6;\n                target[position++] = 0xff;\n                targetView.setUint32(position, seconds);\n            } else if (seconds > 0 && seconds < 0x100000000) {\n                // Timestamp 64\n                let { target, targetView, position } = allocateForWrite(10);\n                target[position++] = 0xd7;\n                target[position++] = 0xff;\n                targetView.setUint32(position, date.getMilliseconds() * 4000000 + (seconds / 1000 / 0x100000000 >> 0));\n                targetView.setUint32(position + 4, seconds);\n            } else if (isNaN(seconds)) {\n                if (this.onInvalidDate) {\n                    allocateForWrite(0);\n                    return pack(this.onInvalidDate());\n                }\n                // Intentionally invalid timestamp\n                let { target, targetView, position } = allocateForWrite(3);\n                target[position++] = 0xd4;\n                target[position++] = 0xff;\n                target[position++] = 0xff;\n            } else {\n                // Timestamp 96\n                let { target, targetView, position } = allocateForWrite(15);\n                target[position++] = 0xc7;\n                target[position++] = 12;\n                target[position++] = 0xff;\n                targetView.setUint32(position, date.getMilliseconds() * 1000000);\n                targetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)));\n            }\n        }\n    },\n    {\n        pack (set, allocateForWrite, pack) {\n            if (this.setAsEmptyObject) {\n                allocateForWrite(0);\n                return pack({});\n            }\n            let array = Array.from(set);\n            let { target, position } = allocateForWrite(this.moreTypes ? 3 : 0);\n            if (this.moreTypes) {\n                target[position++] = 0xd4;\n                target[position++] = 0x73; // 's' for Set\n                target[position++] = 0;\n            }\n            pack(array);\n        }\n    },\n    {\n        pack (error, allocateForWrite, pack) {\n            let { target, position } = allocateForWrite(this.moreTypes ? 3 : 0);\n            if (this.moreTypes) {\n                target[position++] = 0xd4;\n                target[position++] = 0x65; // 'e' for error\n                target[position++] = 0;\n            }\n            pack([\n                error.name,\n                error.message,\n                error.cause\n            ]);\n        }\n    },\n    {\n        pack (regex, allocateForWrite, pack) {\n            let { target, position } = allocateForWrite(this.moreTypes ? 3 : 0);\n            if (this.moreTypes) {\n                target[position++] = 0xd4;\n                target[position++] = 0x78; // 'x' for regeXp\n                target[position++] = 0;\n            }\n            pack([\n                regex.source,\n                regex.flags\n            ]);\n        }\n    },\n    {\n        pack (arrayBuffer, allocateForWrite) {\n            if (this.moreTypes) writeExtBuffer(arrayBuffer, 0x10, allocateForWrite);\n            else writeBuffer(hasNodeBuffer$1 ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite);\n        }\n    },\n    {\n        pack (typedArray, allocateForWrite) {\n            let constructor = typedArray.constructor;\n            if (constructor !== ByteArray && this.moreTypes) writeExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite);\n            else writeBuffer(typedArray, allocateForWrite);\n        }\n    },\n    {\n        pack (c1, allocateForWrite) {\n            let { target, position } = allocateForWrite(1);\n            target[position] = 0xc1;\n        }\n    }\n];\nfunction writeExtBuffer(typedArray, type, allocateForWrite, encode) {\n    let length = typedArray.byteLength;\n    if (length + 1 < 0x100) {\n        var { target, position } = allocateForWrite(4 + length);\n        target[position++] = 0xc7;\n        target[position++] = length + 1;\n    } else if (length + 1 < 0x10000) {\n        var { target, position } = allocateForWrite(5 + length);\n        target[position++] = 0xc8;\n        target[position++] = length + 1 >> 8;\n        target[position++] = length + 1 & 0xff;\n    } else {\n        var { target, position, targetView } = allocateForWrite(7 + length);\n        target[position++] = 0xc9;\n        targetView.setUint32(position, length + 1); // plus one for the type byte\n        position += 4;\n    }\n    target[position++] = 0x74; // \"t\" for typed array\n    target[position++] = type;\n    if (!typedArray.buffer) typedArray = new Uint8Array(typedArray);\n    target.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position);\n}\nfunction writeBuffer(buffer, allocateForWrite) {\n    let length = buffer.byteLength;\n    var target, position;\n    if (length < 0x100) {\n        var { target, position } = allocateForWrite(length + 2);\n        target[position++] = 0xc4;\n        target[position++] = length;\n    } else if (length < 0x10000) {\n        var { target, position } = allocateForWrite(length + 3);\n        target[position++] = 0xc5;\n        target[position++] = length >> 8;\n        target[position++] = length & 0xff;\n    } else {\n        var { target, position, targetView } = allocateForWrite(length + 5);\n        target[position++] = 0xc6;\n        targetView.setUint32(position, length);\n        position += 4;\n    }\n    target.set(buffer, position);\n}\nfunction writeExtensionData(result, target, position, type) {\n    let length = result.length;\n    switch(length){\n        case 1:\n            target[position++] = 0xd4;\n            break;\n        case 2:\n            target[position++] = 0xd5;\n            break;\n        case 4:\n            target[position++] = 0xd6;\n            break;\n        case 8:\n            target[position++] = 0xd7;\n            break;\n        case 16:\n            target[position++] = 0xd8;\n            break;\n        default:\n            if (length < 0x100) {\n                target[position++] = 0xc7;\n                target[position++] = length;\n            } else if (length < 0x10000) {\n                target[position++] = 0xc8;\n                target[position++] = length >> 8;\n                target[position++] = length & 0xff;\n            } else {\n                target[position++] = 0xc9;\n                target[position++] = length >> 24;\n                target[position++] = length >> 16 & 0xff;\n                target[position++] = length >> 8 & 0xff;\n                target[position++] = length & 0xff;\n            }\n    }\n    target[position++] = type;\n    target.set(result, position);\n    position += length;\n    return position;\n}\nfunction insertIds(serialized, idsToInsert) {\n    // insert the ids that need to be referenced for structured clones\n    let nextId;\n    let distanceToMove = idsToInsert.length * 6;\n    let lastEnd = serialized.length - distanceToMove;\n    while(nextId = idsToInsert.pop()){\n        let offset = nextId.offset;\n        let id = nextId.id;\n        serialized.copyWithin(offset + distanceToMove, offset, lastEnd);\n        distanceToMove -= 6;\n        let position = offset + distanceToMove;\n        serialized[position++] = 0xd6;\n        serialized[position++] = 0x69; // 'i'\n        serialized[position++] = id >> 24;\n        serialized[position++] = id >> 16 & 0xff;\n        serialized[position++] = id >> 8 & 0xff;\n        serialized[position++] = id & 0xff;\n        lastEnd = offset;\n    }\n    return serialized;\n}\nfunction writeBundles(start, pack, incrementPosition) {\n    if (bundledStrings.length > 0) {\n        targetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start);\n        bundledStrings.stringsPosition = position - start;\n        let writeStrings = bundledStrings;\n        bundledStrings = null;\n        pack(writeStrings[0]);\n        pack(writeStrings[1]);\n    }\n}\nfunction addExtension(extension) {\n    if (extension.Class) {\n        if (!extension.pack && !extension.write) throw new Error(\"Extension has no pack or write function\");\n        if (extension.pack && !extension.type) throw new Error(\"Extension has no type (numeric code to identify the extension)\");\n        extensionClasses.unshift(extension.Class);\n        extensions.unshift(extension);\n    }\n    addExtension$1(extension);\n}\nfunction prepareStructures$1(structures, packr) {\n    structures.isCompatible = (existingStructures)=>{\n        let compatible = !existingStructures || (packr.lastNamedStructuresLength || 0) === existingStructures.length;\n        if (!compatible) packr._mergeStructures(existingStructures);\n        return compatible;\n    };\n    return structures;\n}\nfunction setWriteStructSlots(writeSlots, makeStructures) {\n    writeStructSlots = writeSlots;\n    prepareStructures$1 = makeStructures;\n}\nlet defaultPackr = new Packr({\n    useRecords: false\n});\nconst pack = defaultPackr.pack;\nconst encode = defaultPackr.pack;\nconst Encoder = Packr;\nconst { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS;\nconst REUSE_BUFFER_MODE = 512;\nconst RESET_BUFFER_MODE = 1024;\nconst RESERVE_START_SPACE = 2048;\nconst ASCII = 3; // the MIBenum from https://www.iana.org/assignments/character-sets/character-sets.xhtml (and other character encodings could be referenced by MIBenum)\nconst NUMBER = 0;\nconst UTF8 = 2;\nconst OBJECT_DATA = 1;\nconst DATE = 16;\nconst TYPE_NAMES = [\n    \"num\",\n    \"object\",\n    \"string\",\n    \"ascii\"\n];\nTYPE_NAMES[DATE] = \"date\";\nconst float32Headers = [\n    false,\n    true,\n    true,\n    false,\n    false,\n    true,\n    true,\n    false\n];\nlet evalSupported;\ntry {\n    new Function(\"\");\n    evalSupported = true;\n} catch (error) {\n// if eval variants are not supported, do not create inline object readers ever\n}\nlet updatedPosition;\nconst hasNodeBuffer = typeof Buffer !== \"undefined\";\nlet textEncoder, currentSource;\ntry {\n    textEncoder = new TextEncoder();\n} catch (error) {}\nconst encodeUtf8 = hasNodeBuffer ? function(target, string, position) {\n    return target.utf8Write(string, position, target.byteLength - position);\n} : textEncoder && textEncoder.encodeInto ? function(target, string, position) {\n    return textEncoder.encodeInto(string, target.subarray(position)).written;\n} : false;\nsetWriteStructSlots(writeStruct, prepareStructures);\nfunction writeStruct(object, target, encodingStart, position, structures, makeRoom, pack, packr) {\n    let typedStructs = packr.typedStructs || (packr.typedStructs = []);\n    // note that we rely on pack.js to load stored structures before we get to this point\n    let targetView = target.dataView;\n    let refsStartPosition = (typedStructs.lastStringStart || 100) + position;\n    let safeEnd = target.length - 10;\n    let start = position;\n    if (position > safeEnd) {\n        target = makeRoom(position);\n        targetView = target.dataView;\n        position -= encodingStart;\n        start -= encodingStart;\n        refsStartPosition -= encodingStart;\n        encodingStart = 0;\n        safeEnd = target.length - 10;\n    }\n    let refOffset, refPosition = refsStartPosition;\n    let transition = typedStructs.transitions || (typedStructs.transitions = Object.create(null));\n    let nextId = typedStructs.nextId || typedStructs.length;\n    let headerSize = nextId < 0xf ? 1 : nextId < 0xf0 ? 2 : nextId < 0xf000 ? 3 : nextId < 0xf00000 ? 4 : 0;\n    if (headerSize === 0) return 0;\n    position += headerSize;\n    let queuedReferences = [];\n    let usedAscii0;\n    let keyIndex = 0;\n    for(let key in object){\n        let value = object[key];\n        let nextTransition = transition[key];\n        if (!nextTransition) {\n            transition[key] = nextTransition = {\n                key,\n                parent: transition,\n                enumerationOffset: 0,\n                ascii0: null,\n                ascii8: null,\n                num8: null,\n                string16: null,\n                object16: null,\n                num32: null,\n                float64: null,\n                date64: null\n            };\n        }\n        if (position > safeEnd) {\n            target = makeRoom(position);\n            targetView = target.dataView;\n            position -= encodingStart;\n            start -= encodingStart;\n            refsStartPosition -= encodingStart;\n            refPosition -= encodingStart;\n            encodingStart = 0;\n            safeEnd = target.length - 10;\n        }\n        switch(typeof value){\n            case \"number\":\n                let number = value;\n                // first check to see if we are using a lot of ids and should default to wide/common format\n                if (nextId < 200 || !nextTransition.num64) {\n                    if (number >> 0 === number && number < 0x20000000 && number > -0x1f000000) {\n                        if (number < 0xf6 && number >= 0 && (nextTransition.num8 && !(nextId > 200 && nextTransition.num32) || number < 0x20 && !nextTransition.num32)) {\n                            transition = nextTransition.num8 || createTypeTransition(nextTransition, NUMBER, 1);\n                            target[position++] = number;\n                        } else {\n                            transition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n                            targetView.setUint32(position, number, true);\n                            position += 4;\n                        }\n                        break;\n                    } else if (number < 0x100000000 && number >= -0x80000000) {\n                        targetView.setFloat32(position, number, true);\n                        if (float32Headers[target[position + 3] >>> 5]) {\n                            let xShifted;\n                            // this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n                            if ((xShifted = number * mult10[(target[position + 3] & 0x7f) << 1 | target[position + 2] >> 7]) >> 0 === xShifted) {\n                                transition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n                                position += 4;\n                                break;\n                            }\n                        }\n                    }\n                }\n                transition = nextTransition.num64 || createTypeTransition(nextTransition, NUMBER, 8);\n                targetView.setFloat64(position, number, true);\n                position += 8;\n                break;\n            case \"string\":\n                let strLength = value.length;\n                refOffset = refPosition - refsStartPosition;\n                if ((strLength << 2) + refPosition > safeEnd) {\n                    target = makeRoom((strLength << 2) + refPosition);\n                    targetView = target.dataView;\n                    position -= encodingStart;\n                    start -= encodingStart;\n                    refsStartPosition -= encodingStart;\n                    refPosition -= encodingStart;\n                    encodingStart = 0;\n                    safeEnd = target.length - 10;\n                }\n                if (strLength > 0xff00 + refOffset >> 2) {\n                    queuedReferences.push(key, value, position - start);\n                    break;\n                }\n                let isNotAscii;\n                let strStart = refPosition;\n                if (strLength < 0x40) {\n                    let i, c1, c2;\n                    for(i = 0; i < strLength; i++){\n                        c1 = value.charCodeAt(i);\n                        if (c1 < 0x80) {\n                            target[refPosition++] = c1;\n                        } else if (c1 < 0x800) {\n                            isNotAscii = true;\n                            target[refPosition++] = c1 >> 6 | 0xc0;\n                            target[refPosition++] = c1 & 0x3f | 0x80;\n                        } else if ((c1 & 0xfc00) === 0xd800 && ((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00) {\n                            isNotAscii = true;\n                            c1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff);\n                            i++;\n                            target[refPosition++] = c1 >> 18 | 0xf0;\n                            target[refPosition++] = c1 >> 12 & 0x3f | 0x80;\n                            target[refPosition++] = c1 >> 6 & 0x3f | 0x80;\n                            target[refPosition++] = c1 & 0x3f | 0x80;\n                        } else {\n                            isNotAscii = true;\n                            target[refPosition++] = c1 >> 12 | 0xe0;\n                            target[refPosition++] = c1 >> 6 & 0x3f | 0x80;\n                            target[refPosition++] = c1 & 0x3f | 0x80;\n                        }\n                    }\n                } else {\n                    refPosition += encodeUtf8(target, value, refPosition);\n                    isNotAscii = refPosition - strStart > strLength;\n                }\n                if (refOffset < 0xa0 || refOffset < 0xf6 && (nextTransition.ascii8 || nextTransition.string8)) {\n                    // short strings\n                    if (isNotAscii) {\n                        if (!(transition = nextTransition.string8)) {\n                            if (typedStructs.length > 10 && (transition = nextTransition.ascii8)) {\n                                // we can safely change ascii to utf8 in place since they are compatible\n                                transition.__type = UTF8;\n                                nextTransition.ascii8 = null;\n                                nextTransition.string8 = transition;\n                                pack(null, 0, true); // special call to notify that structures have been updated\n                            } else {\n                                transition = createTypeTransition(nextTransition, UTF8, 1);\n                            }\n                        }\n                    } else if (refOffset === 0 && !usedAscii0) {\n                        usedAscii0 = true;\n                        transition = nextTransition.ascii0 || createTypeTransition(nextTransition, ASCII, 0);\n                        break; // don't increment position\n                    } else if (!(transition = nextTransition.ascii8) && !(typedStructs.length > 10 && (transition = nextTransition.string8))) transition = createTypeTransition(nextTransition, ASCII, 1);\n                    target[position++] = refOffset;\n                } else {\n                    // TODO: Enable ascii16 at some point, but get the logic right\n                    //if (isNotAscii)\n                    transition = nextTransition.string16 || createTypeTransition(nextTransition, UTF8, 2);\n                    //else\n                    //transition = nextTransition.ascii16 || createTypeTransition(nextTransition, ASCII, 2);\n                    targetView.setUint16(position, refOffset, true);\n                    position += 2;\n                }\n                break;\n            case \"object\":\n                if (value) {\n                    if (value.constructor === Date) {\n                        transition = nextTransition.date64 || createTypeTransition(nextTransition, DATE, 8);\n                        targetView.setFloat64(position, value.getTime(), true);\n                        position += 8;\n                    } else {\n                        queuedReferences.push(key, value, keyIndex);\n                    }\n                    break;\n                } else {\n                    nextTransition = anyType(nextTransition, position, targetView, -10); // match CBOR with this\n                    if (nextTransition) {\n                        transition = nextTransition;\n                        position = updatedPosition;\n                    } else queuedReferences.push(key, value, keyIndex);\n                }\n                break;\n            case \"boolean\":\n                transition = nextTransition.num8 || nextTransition.ascii8 || createTypeTransition(nextTransition, NUMBER, 1);\n                target[position++] = value ? 0xf9 : 0xf8; // match CBOR with these\n                break;\n            case \"undefined\":\n                nextTransition = anyType(nextTransition, position, targetView, -9); // match CBOR with this\n                if (nextTransition) {\n                    transition = nextTransition;\n                    position = updatedPosition;\n                } else queuedReferences.push(key, value, keyIndex);\n                break;\n            default:\n                queuedReferences.push(key, value, keyIndex);\n        }\n        keyIndex++;\n    }\n    for(let i = 0, l = queuedReferences.length; i < l;){\n        let key = queuedReferences[i++];\n        let value = queuedReferences[i++];\n        let propertyIndex = queuedReferences[i++];\n        let nextTransition = transition[key];\n        if (!nextTransition) {\n            transition[key] = nextTransition = {\n                key,\n                parent: transition,\n                enumerationOffset: propertyIndex - keyIndex,\n                ascii0: null,\n                ascii8: null,\n                num8: null,\n                string16: null,\n                object16: null,\n                num32: null,\n                float64: null\n            };\n        }\n        let newPosition;\n        if (value) {\n            /*if (typeof value === 'string') { // TODO: we could re-enable long strings\n\t\t\t\tif (position + value.length * 3 > safeEnd) {\n\t\t\t\t\ttarget = makeRoom(position + value.length * 3);\n\t\t\t\t\tposition -= start;\n\t\t\t\t\ttargetView = target.dataView;\n\t\t\t\t\tstart = 0;\n\t\t\t\t}\n\t\t\t\tnewPosition = position + target.utf8Write(value, position, 0xffffffff);\n\t\t\t} else { */ let size;\n            refOffset = refPosition - refsStartPosition;\n            if (refOffset < 0xff00) {\n                transition = nextTransition.object16;\n                if (transition) size = 2;\n                else if (transition = nextTransition.object32) size = 4;\n                else {\n                    transition = createTypeTransition(nextTransition, OBJECT_DATA, 2);\n                    size = 2;\n                }\n            } else {\n                transition = nextTransition.object32 || createTypeTransition(nextTransition, OBJECT_DATA, 4);\n                size = 4;\n            }\n            newPosition = pack(value, refPosition);\n            //}\n            if (typeof newPosition === \"object\") {\n                // re-allocated\n                refPosition = newPosition.position;\n                targetView = newPosition.targetView;\n                target = newPosition.target;\n                refsStartPosition -= encodingStart;\n                position -= encodingStart;\n                start -= encodingStart;\n                encodingStart = 0;\n            } else refPosition = newPosition;\n            if (size === 2) {\n                targetView.setUint16(position, refOffset, true);\n                position += 2;\n            } else {\n                targetView.setUint32(position, refOffset, true);\n                position += 4;\n            }\n        } else {\n            transition = nextTransition.object16 || createTypeTransition(nextTransition, OBJECT_DATA, 2);\n            targetView.setInt16(position, value === null ? -10 : -9, true);\n            position += 2;\n        }\n        keyIndex++;\n    }\n    let recordId = transition[RECORD_SYMBOL];\n    if (recordId == null) {\n        recordId = packr.typedStructs.length;\n        let structure = [];\n        let nextTransition = transition;\n        let key, type;\n        while((type = nextTransition.__type) !== undefined){\n            let size = nextTransition.__size;\n            nextTransition = nextTransition.__parent;\n            key = nextTransition.key;\n            let property = [\n                type,\n                size,\n                key\n            ];\n            if (nextTransition.enumerationOffset) property.push(nextTransition.enumerationOffset);\n            structure.push(property);\n            nextTransition = nextTransition.parent;\n        }\n        structure.reverse();\n        transition[RECORD_SYMBOL] = recordId;\n        packr.typedStructs[recordId] = structure;\n        pack(null, 0, true); // special call to notify that structures have been updated\n    }\n    switch(headerSize){\n        case 1:\n            if (recordId >= 0x10) return 0;\n            target[start] = recordId + 0x20;\n            break;\n        case 2:\n            if (recordId >= 0x100) return 0;\n            target[start] = 0x38;\n            target[start + 1] = recordId;\n            break;\n        case 3:\n            if (recordId >= 0x10000) return 0;\n            target[start] = 0x39;\n            targetView.setUint16(start + 1, recordId, true);\n            break;\n        case 4:\n            if (recordId >= 0x1000000) return 0;\n            targetView.setUint32(start, (recordId << 8) + 0x3a, true);\n            break;\n    }\n    if (position < refsStartPosition) {\n        if (refsStartPosition === refPosition) return position; // no refs\n        // adjust positioning\n        target.copyWithin(position, refsStartPosition, refPosition);\n        refPosition += position - refsStartPosition;\n        typedStructs.lastStringStart = position - start;\n    } else if (position > refsStartPosition) {\n        if (refsStartPosition === refPosition) return position; // no refs\n        typedStructs.lastStringStart = position - start;\n        return writeStruct(object, target, encodingStart, start, structures, makeRoom, pack, packr);\n    }\n    return refPosition;\n}\nfunction anyType(transition, position, targetView, value) {\n    let nextTransition;\n    if (nextTransition = transition.ascii8 || transition.num8) {\n        targetView.setInt8(position, value, true);\n        updatedPosition = position + 1;\n        return nextTransition;\n    }\n    if (nextTransition = transition.string16 || transition.object16) {\n        targetView.setInt16(position, value, true);\n        updatedPosition = position + 2;\n        return nextTransition;\n    }\n    if (nextTransition = transition.num32) {\n        targetView.setUint32(position, 0xe0000100 + value, true);\n        updatedPosition = position + 4;\n        return nextTransition;\n    }\n    // transition.float64\n    if (nextTransition = transition.num64) {\n        targetView.setFloat64(position, NaN, true);\n        targetView.setInt8(position, value);\n        updatedPosition = position + 8;\n        return nextTransition;\n    }\n    updatedPosition = position;\n    // TODO: can we do an \"any\" type where we defer the decision?\n    return;\n}\nfunction createTypeTransition(transition, type, size) {\n    let typeName = TYPE_NAMES[type] + (size << 3);\n    let newTransition = transition[typeName] || (transition[typeName] = Object.create(null));\n    newTransition.__type = type;\n    newTransition.__size = size;\n    newTransition.__parent = transition;\n    return newTransition;\n}\nfunction onLoadedStructures(sharedData) {\n    if (!(sharedData instanceof Map)) return sharedData;\n    let typed = sharedData.get(\"typed\") || [];\n    if (Object.isFrozen(typed)) typed = typed.map((structure)=>structure.slice(0));\n    let named = sharedData.get(\"named\");\n    let transitions = Object.create(null);\n    for(let i = 0, l = typed.length; i < l; i++){\n        let structure = typed[i];\n        let transition = transitions;\n        for (let [type, size, key] of structure){\n            let nextTransition = transition[key];\n            if (!nextTransition) {\n                transition[key] = nextTransition = {\n                    key,\n                    parent: transition,\n                    enumerationOffset: 0,\n                    ascii0: null,\n                    ascii8: null,\n                    num8: null,\n                    string16: null,\n                    object16: null,\n                    num32: null,\n                    float64: null,\n                    date64: null\n                };\n            }\n            transition = createTypeTransition(nextTransition, type, size);\n        }\n        transition[RECORD_SYMBOL] = i;\n    }\n    typed.transitions = transitions;\n    this.typedStructs = typed;\n    this.lastTypedStructuresLength = typed.length;\n    return named;\n}\nvar sourceSymbol = Symbol.for(\"source\");\nfunction readStruct(src, position, srcEnd, unpackr) {\n    let recordId = src[position++] - 0x20;\n    if (recordId >= 24) {\n        switch(recordId){\n            case 24:\n                recordId = src[position++];\n                break;\n            // little endian:\n            case 25:\n                recordId = src[position++] + (src[position++] << 8);\n                break;\n            case 26:\n                recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16);\n                break;\n            case 27:\n                recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16) + (src[position++] << 24);\n                break;\n        }\n    }\n    let structure = unpackr.typedStructs && unpackr.typedStructs[recordId];\n    if (!structure) {\n        // copy src buffer because getStructures will override it\n        src = Uint8Array.prototype.slice.call(src, position, srcEnd);\n        srcEnd -= position;\n        position = 0;\n        if (!unpackr.getStructures) throw new Error(`Reference to shared structure ${recordId} without getStructures method`);\n        unpackr._mergeStructures(unpackr.getStructures());\n        if (!unpackr.typedStructs) throw new Error(\"Could not find any shared typed structures\");\n        unpackr.lastTypedStructuresLength = unpackr.typedStructs.length;\n        structure = unpackr.typedStructs[recordId];\n        if (!structure) throw new Error(\"Could not find typed structure \" + recordId);\n    }\n    var construct = structure.construct;\n    if (!construct) {\n        construct = structure.construct = function LazyObject() {};\n        var prototype = construct.prototype;\n        let properties = [];\n        let currentOffset = 0;\n        let lastRefProperty;\n        for(let i = 0, l = structure.length; i < l; i++){\n            let definition = structure[i];\n            let [type, size, key, enumerationOffset] = definition;\n            if (key === \"__proto__\") key = \"__proto_\";\n            let property = {\n                key,\n                offset: currentOffset\n            };\n            if (enumerationOffset) properties.splice(i + enumerationOffset, 0, property);\n            else properties.push(property);\n            let getRef;\n            switch(size){\n                case 0:\n                    getRef = ()=>0;\n                    break;\n                case 1:\n                    getRef = (source, position)=>{\n                        let ref = source.bytes[position + property.offset];\n                        return ref >= 0xf6 ? toConstant(ref) : ref;\n                    };\n                    break;\n                case 2:\n                    getRef = (source, position)=>{\n                        let src = source.bytes;\n                        let dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n                        let ref = dataView.getUint16(position + property.offset, true);\n                        return ref >= 0xff00 ? toConstant(ref & 0xff) : ref;\n                    };\n                    break;\n                case 4:\n                    getRef = (source, position)=>{\n                        let src = source.bytes;\n                        let dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n                        let ref = dataView.getUint32(position + property.offset, true);\n                        return ref >= 0xffffff00 ? toConstant(ref & 0xff) : ref;\n                    };\n                    break;\n            }\n            property.getRef = getRef;\n            currentOffset += size;\n            let get;\n            switch(type){\n                case ASCII:\n                    if (lastRefProperty && !lastRefProperty.next) lastRefProperty.next = property;\n                    lastRefProperty = property;\n                    property.multiGetCount = 0;\n                    get = function(source) {\n                        let src = source.bytes;\n                        let position = source.position;\n                        let refStart = currentOffset + position;\n                        let ref = getRef(source, position);\n                        if (typeof ref !== \"number\") return ref;\n                        let end, next = property.next;\n                        while(next){\n                            end = next.getRef(source, position);\n                            if (typeof end === \"number\") break;\n                            else end = null;\n                            next = next.next;\n                        }\n                        if (end == null) end = source.bytesEnd - refStart;\n                        if (source.srcString) {\n                            return source.srcString.slice(ref, end);\n                        }\n                        /*if (property.multiGetCount > 0) {\n\t\t\t\t\t\t\tlet asciiEnd;\n\t\t\t\t\t\t\tnext = firstRefProperty;\n\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tasciiEnd = dataView.getUint16(source.position + next.offset, true);\n\t\t\t\t\t\t\t\tif (asciiEnd < 0xff00)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tasciiEnd = null;\n\t\t\t\t\t\t\t} while((next = next.next));\n\t\t\t\t\t\t\tif (asciiEnd == null)\n\t\t\t\t\t\t\t\tasciiEnd = source.bytesEnd - refStart\n\t\t\t\t\t\t\tsource.srcString = src.toString('latin1', refStart, refStart + asciiEnd);\n\t\t\t\t\t\t\treturn source.srcString.slice(ref, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (source.prevStringGet) {\n\t\t\t\t\t\t\tsource.prevStringGet.multiGetCount += 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsource.prevStringGet = property;\n\t\t\t\t\t\t\tproperty.multiGetCount--;\n\t\t\t\t\t\t}*/ return readString(src, ref + refStart, end - ref);\n                    //return src.toString('latin1', ref + refStart, end + refStart);\n                    };\n                    break;\n                case UTF8:\n                case OBJECT_DATA:\n                    if (lastRefProperty && !lastRefProperty.next) lastRefProperty.next = property;\n                    lastRefProperty = property;\n                    get = function(source) {\n                        let position = source.position;\n                        let refStart = currentOffset + position;\n                        let ref = getRef(source, position);\n                        if (typeof ref !== \"number\") return ref;\n                        let src = source.bytes;\n                        let end, next = property.next;\n                        while(next){\n                            end = next.getRef(source, position);\n                            if (typeof end === \"number\") break;\n                            else end = null;\n                            next = next.next;\n                        }\n                        if (end == null) end = source.bytesEnd - refStart;\n                        if (type === UTF8) {\n                            return src.toString(\"utf8\", ref + refStart, end + refStart);\n                        } else {\n                            currentSource = source;\n                            try {\n                                return unpackr.unpack(src, {\n                                    start: ref + refStart,\n                                    end: end + refStart\n                                });\n                            } finally{\n                                currentSource = null;\n                            }\n                        }\n                    };\n                    break;\n                case NUMBER:\n                    switch(size){\n                        case 4:\n                            get = function(source) {\n                                let src = source.bytes;\n                                let dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n                                let position = source.position + property.offset;\n                                let value = dataView.getInt32(position, true);\n                                if (value < 0x20000000) {\n                                    if (value > -0x1f000000) return value;\n                                    if (value > -0x20000000) return toConstant(value & 0xff);\n                                }\n                                let fValue = dataView.getFloat32(position, true);\n                                // this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n                                let multiplier = mult10[(src[position + 3] & 0x7f) << 1 | src[position + 2] >> 7];\n                                return (multiplier * fValue + (fValue > 0 ? 0.5 : -0.5) >> 0) / multiplier;\n                            };\n                            break;\n                        case 8:\n                            get = function(source) {\n                                let src = source.bytes;\n                                let dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n                                let value = dataView.getFloat64(source.position + property.offset, true);\n                                if (isNaN(value)) {\n                                    let byte = src[source.position + property.offset];\n                                    if (byte >= 0xf6) return toConstant(byte);\n                                }\n                                return value;\n                            };\n                            break;\n                        case 1:\n                            get = function(source) {\n                                let src = source.bytes;\n                                let value = src[source.position + property.offset];\n                                return value < 0xf6 ? value : toConstant(value);\n                            };\n                            break;\n                    }\n                    break;\n                case DATE:\n                    get = function(source) {\n                        let src = source.bytes;\n                        let dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n                        return new Date(dataView.getFloat64(source.position + property.offset, true));\n                    };\n                    break;\n            }\n            property.get = get;\n        }\n        // TODO: load the srcString for faster string decoding on toJSON\n        if (evalSupported) {\n            let objectLiteralProperties = [];\n            let args = [];\n            let i = 0;\n            let hasInheritedProperties;\n            for (let property of properties){\n                if (unpackr.alwaysLazyProperty && unpackr.alwaysLazyProperty(property.key)) {\n                    // these properties are not eagerly evaluated and this can be used for creating properties\n                    // that are not serialized as JSON\n                    hasInheritedProperties = true;\n                    continue;\n                }\n                Object.defineProperty(prototype, property.key, {\n                    get: withSource(property.get),\n                    enumerable: true\n                });\n                let valueFunction = \"v\" + i++;\n                args.push(valueFunction);\n                objectLiteralProperties.push(\"[\" + JSON.stringify(property.key) + \"]:\" + valueFunction + \"(s)\");\n            }\n            if (hasInheritedProperties) {\n                objectLiteralProperties.push(\"__proto__:this\");\n            }\n            let toObject = new Function(...args, \"return function(s){return{\" + objectLiteralProperties.join(\",\") + \"}}\").apply(null, properties.map((prop)=>prop.get));\n            Object.defineProperty(prototype, \"toJSON\", {\n                value (omitUnderscoredProperties) {\n                    return toObject.call(this, this[sourceSymbol]);\n                }\n            });\n        } else {\n            Object.defineProperty(prototype, \"toJSON\", {\n                value (omitUnderscoredProperties) {\n                    // return an enumerable object with own properties to JSON stringify\n                    let resolved = {};\n                    for(let i = 0, l = properties.length; i < l; i++){\n                        // TODO: check alwaysLazyProperty\n                        let key = properties[i].key;\n                        resolved[key] = this[key];\n                    }\n                    return resolved;\n                }\n            });\n        }\n    }\n    var instance = new construct();\n    instance[sourceSymbol] = {\n        bytes: src,\n        position,\n        srcString: \"\",\n        bytesEnd: srcEnd\n    };\n    return instance;\n}\nfunction toConstant(code) {\n    switch(code){\n        case 0xf6:\n            return null;\n        case 0xf7:\n            return undefined;\n        case 0xf8:\n            return false;\n        case 0xf9:\n            return true;\n    }\n    throw new Error(\"Unknown constant\");\n}\nfunction withSource(get) {\n    return function() {\n        return get(this[sourceSymbol]);\n    };\n}\nfunction saveState() {\n    if (currentSource) {\n        currentSource.bytes = Uint8Array.prototype.slice.call(currentSource.bytes, currentSource.position, currentSource.bytesEnd);\n        currentSource.position = 0;\n        currentSource.bytesEnd = currentSource.bytes.length;\n    }\n}\nfunction prepareStructures(structures, packr) {\n    if (packr.typedStructs) {\n        let structMap = new Map();\n        structMap.set(\"named\", structures);\n        structMap.set(\"typed\", packr.typedStructs);\n        structures = structMap;\n    }\n    let lastTypedStructuresLength = packr.lastTypedStructuresLength || 0;\n    structures.isCompatible = (existing)=>{\n        let compatible = true;\n        if (existing instanceof Map) {\n            let named = existing.get(\"named\") || [];\n            if (named.length !== (packr.lastNamedStructuresLength || 0)) compatible = false;\n            let typed = existing.get(\"typed\") || [];\n            if (typed.length !== lastTypedStructuresLength) compatible = false;\n        } else if (existing instanceof Array || Array.isArray(existing)) {\n            if (existing.length !== (packr.lastNamedStructuresLength || 0)) compatible = false;\n        }\n        if (!compatible) packr._mergeStructures(existing);\n        return compatible;\n    };\n    packr.lastTypedStructuresLength = packr.typedStructs && packr.typedStructs.length;\n    return structures;\n}\nsetReadStruct(readStruct, onLoadedStructures, saveState);\nclass PackrStream extends stream.Transform {\n    constructor(options){\n        if (!options) options = {};\n        options.writableObjectMode = true;\n        super(options);\n        options.sequential = true;\n        this.packr = options.packr || new Packr(options);\n    }\n    _transform(value, encoding, callback) {\n        this.push(this.packr.pack(value));\n        callback();\n    }\n}\nclass UnpackrStream extends stream.Transform {\n    constructor(options){\n        if (!options) options = {};\n        options.objectMode = true;\n        super(options);\n        options.structures = [];\n        this.unpackr = options.unpackr || new Unpackr(options);\n    }\n    _transform(chunk, encoding, callback) {\n        if (this.incompleteBuffer) {\n            chunk = Buffer.concat([\n                this.incompleteBuffer,\n                chunk\n            ]);\n            this.incompleteBuffer = null;\n        }\n        let values;\n        try {\n            values = this.unpackr.unpackMultiple(chunk);\n        } catch (error) {\n            if (error.incomplete) {\n                this.incompleteBuffer = chunk.slice(error.lastPosition);\n                values = error.values;\n            } else throw error;\n        } finally{\n            for (let value of values || []){\n                if (value === null) value = this.getNullValue();\n                this.push(value);\n            }\n        }\n        if (callback) callback();\n    }\n    getNullValue() {\n        return Symbol.for(null);\n    }\n}\n/**\n * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer\n * If the argument is only Async Iterable, the return value will be an Async Iterable.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object\n * @param {options} [options] - msgpackr pack options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator>}\n */ function packIter(objectIterator, options = {}) {\n    if (!objectIterator || typeof objectIterator !== \"object\") {\n        throw new Error(\"first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable\");\n    } else if (typeof objectIterator[Symbol.iterator] === \"function\") {\n        return packIterSync(objectIterator, options);\n    } else if (typeof objectIterator.then === \"function\" || typeof objectIterator[Symbol.asyncIterator] === \"function\") {\n        return packIterAsync(objectIterator, options);\n    } else {\n        throw new Error(\"first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise\");\n    }\n}\nfunction* packIterSync(objectIterator, options) {\n    const packr = new Packr(options);\n    for (const value of objectIterator){\n        yield packr.pack(value);\n    }\n}\nasync function* packIterAsync(objectIterator, options) {\n    const packr = new Packr(options);\n    for await (const value of objectIterator){\n        yield packr.pack(value);\n    }\n}\n/**\n * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects\n * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator\n * @param {object} [options] - unpackr options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator}\n */ function unpackIter(bufferIterator, options = {}) {\n    if (!bufferIterator || typeof bufferIterator !== \"object\") {\n        throw new Error(\"first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise\");\n    }\n    const unpackr = new Unpackr(options);\n    let incomplete;\n    const parser = (chunk)=>{\n        let yields;\n        // if there's incomplete data from previous chunk, concatinate and try again\n        if (incomplete) {\n            chunk = Buffer.concat([\n                incomplete,\n                chunk\n            ]);\n            incomplete = undefined;\n        }\n        try {\n            yields = unpackr.unpackMultiple(chunk);\n        } catch (err) {\n            if (err.incomplete) {\n                incomplete = chunk.slice(err.lastPosition);\n                yields = err.values;\n            } else {\n                throw err;\n            }\n        }\n        return yields;\n    };\n    if (typeof bufferIterator[Symbol.iterator] === \"function\") {\n        return function* iter() {\n            for (const value of bufferIterator){\n                yield* parser(value);\n            }\n        }();\n    } else if (typeof bufferIterator[Symbol.asyncIterator] === \"function\") {\n        return async function* iter() {\n            for await (const value of bufferIterator){\n                yield* parser(value);\n            }\n        }();\n    }\n}\nconst decodeIter = unpackIter;\nconst encodeIter = packIter;\nconst useRecords = false;\nconst mapsAsObjects = true;\nconst nativeAccelerationDisabled = process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED !== undefined && process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED.toLowerCase() === \"true\";\nif (!nativeAccelerationDisabled) {\n    let extractor;\n    try {\n        if (true) extractor = __webpack_require__(/*! msgpackr-extract */ \"(rsc)/./node_modules/msgpackr-extract/index.js\");\n        else {}\n        if (extractor) setExtractor(extractor.extractStrings);\n    } catch (error) {\n    // native module is optional\n    }\n}\nexports.ALWAYS = ALWAYS;\nexports.C1 = C1;\nexports.DECIMAL_FIT = DECIMAL_FIT;\nexports.DECIMAL_ROUND = DECIMAL_ROUND;\nexports.Decoder = Decoder;\nexports.DecoderStream = UnpackrStream;\nexports.Encoder = Encoder;\nexports.EncoderStream = PackrStream;\nexports.FLOAT32_OPTIONS = FLOAT32_OPTIONS;\nexports.NEVER = NEVER;\nexports.Packr = Packr;\nexports.PackrStream = PackrStream;\nexports.Unpackr = Unpackr;\nexports.UnpackrStream = UnpackrStream;\nexports.addExtension = addExtension;\nexports.clearSource = clearSource;\nexports.decode = decode;\nexports.decodeIter = decodeIter;\nexports.encode = encode;\nexports.encodeIter = encodeIter;\nexports.mapsAsObjects = mapsAsObjects;\nexports.pack = pack;\nexports.roundFloat32 = roundFloat32;\nexports.unpack = unpack;\nexports.unpackMultiple = unpackMultiple;\nexports.useRecords = useRecords; //# sourceMappingURL=node.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbXNncGFja3IvZGlzdC9ub2RlLmNqcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO0FBRXZCLElBQUlFO0FBQ0osSUFBSTtJQUNIQSxVQUFVLElBQUlDO0FBQ2YsRUFBRSxPQUFNQyxPQUFPLENBQUM7QUFDaEIsSUFBSUM7QUFDSixJQUFJQztBQUNKLElBQUlDLGFBQWE7QUFDakIsTUFBTUMsY0FBYyxFQUFFO0FBQ3RCLElBQUlDLFVBQVVEO0FBQ2QsSUFBSUUsaUJBQWlCO0FBQ3JCLElBQUlDLGlCQUFpQixDQUFDO0FBQ3RCLElBQUlDO0FBQ0osSUFBSUM7QUFDSixJQUFJQyxpQkFBaUI7QUFDckIsSUFBSUMsZUFBZTtBQUNuQixJQUFJQztBQUNKLElBQUlDO0FBQ0osSUFBSUMsb0JBQW9CLEVBQUU7QUFDMUIsSUFBSUM7QUFDSixJQUFJQyxpQkFBaUI7SUFDcEJDLFlBQVk7SUFDWkMsZUFBZTtBQUNoQjtBQUNBLE1BQU1DO0FBQVE7QUFDZCxNQUFNQyxLQUFLLElBQUlEO0FBQ2ZDLEdBQUdDLElBQUksR0FBRztBQUNWLElBQUlDLGlCQUFpQjtBQUNyQixJQUFJQyw0QkFBNEI7QUFDaEMsSUFBSUMsY0FBY0Msc0JBQXNCQztBQUN4QyxnQkFBZ0I7QUFDaEIsSUFBSTtJQUNILElBQUlDLFNBQVM7QUFDZCxFQUFFLE9BQU0zQixPQUFPO0lBQ2QsK0VBQStFO0lBQy9FdUIsNEJBQTRCSztBQUM3QjtBQUVBLE1BQU1DO0lBQ0xDLFlBQVlDLE9BQU8sQ0FBRTtRQUNwQixJQUFJQSxTQUFTO1lBQ1osSUFBSUEsUUFBUWQsVUFBVSxLQUFLLFNBQVNjLFFBQVFiLGFBQWEsS0FBS2MsV0FDN0RELFFBQVFiLGFBQWEsR0FBRztZQUN6QixJQUFJYSxRQUFRRSxVQUFVLElBQUlGLFFBQVFHLE9BQU8sS0FBSyxPQUFPO2dCQUNwREgsUUFBUUcsT0FB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aEIzSCxtQkFBbUIsR0FBR2tYO0FBQ3RCbFgsZUFBZSxHQUFHNUg7QUFDbEI0SCxxQkFBcUIsR0FBR3VYO0FBQ3hCdlgsb0JBQW9CLEdBQUdtUjtBQUN2Qm5SLG1CQUFtQixHQUFHekc7QUFDdEJ5RyxjQUFjLEdBQUdwRTtBQUNqQm9FLGtCQUFrQixHQUFHeVk7QUFDckJ6WSxjQUFjLEdBQUcrSTtBQUNqQi9JLGtCQUFrQixHQUFHMFk7QUFDckIxWSxxQkFBcUIsR0FBR3ZJO0FBQ3hCdUksWUFBWSxHQUFHOEk7QUFDZjlJLG9CQUFvQixHQUFHa0c7QUFDdkJsRyxjQUFjLEdBQUc1RztBQUNqQjRHLHNCQUFzQixHQUFHMUY7QUFDekIwRixrQkFBa0IsR0FBR3hJLFlBQ3JCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2pvYi1ib2FyZC1zY3JhcGVyLy4vbm9kZV9tb2R1bGVzL21zZ3BhY2tyL2Rpc3Qvbm9kZS5janM/MDA4OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbnZhciBtb2R1bGUkMSA9IHJlcXVpcmUoJ21vZHVsZScpO1xuXG52YXIgZGVjb2RlcjtcbnRyeSB7XG5cdGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbn0gY2F0Y2goZXJyb3IpIHt9XG52YXIgc3JjO1xudmFyIHNyY0VuZDtcbnZhciBwb3NpdGlvbiQxID0gMDtcbmNvbnN0IEVNUFRZX0FSUkFZID0gW107XG52YXIgc3RyaW5ncyA9IEVNUFRZX0FSUkFZO1xudmFyIHN0cmluZ1Bvc2l0aW9uID0gMDtcbnZhciBjdXJyZW50VW5wYWNrciA9IHt9O1xudmFyIGN1cnJlbnRTdHJ1Y3R1cmVzO1xudmFyIHNyY1N0cmluZztcbnZhciBzcmNTdHJpbmdTdGFydCA9IDA7XG52YXIgc3JjU3RyaW5nRW5kID0gMDtcbnZhciBidW5kbGVkU3RyaW5ncyQxO1xudmFyIHJlZmVyZW5jZU1hcDtcbnZhciBjdXJyZW50RXh0ZW5zaW9ucyA9IFtdO1xudmFyIGRhdGFWaWV3O1xudmFyIGRlZmF1bHRPcHRpb25zID0ge1xuXHR1c2VSZWNvcmRzOiBmYWxzZSxcblx0bWFwc0FzT2JqZWN0czogdHJ1ZVxufTtcbmNsYXNzIEMxVHlwZSB7fVxuY29uc3QgQzEgPSBuZXcgQzFUeXBlKCk7XG5DMS5uYW1lID0gJ01lc3NhZ2VQYWNrIDB4QzEnO1xudmFyIHNlcXVlbnRpYWxNb2RlID0gZmFsc2U7XG52YXIgaW5saW5lT2JqZWN0UmVhZFRocmVzaG9sZCA9IDI7XG52YXIgcmVhZFN0cnVjdCQxLCBvbkxvYWRlZFN0cnVjdHVyZXMkMSwgb25TYXZlU3RhdGU7XG4vLyBuby1ldmFsIGJ1aWxkXG50cnkge1xuXHRuZXcgRnVuY3Rpb24oJycpO1xufSBjYXRjaChlcnJvcikge1xuXHQvLyBpZiBldmFsIHZhcmlhbnRzIGFyZSBub3Qgc3VwcG9ydGVkLCBkbyBub3QgY3JlYXRlIGlubGluZSBvYmplY3QgcmVhZGVycyBldmVyXG5cdGlubGluZU9iamVjdFJlYWRUaHJlc2hvbGQgPSBJbmZpbml0eTtcbn1cblxuY2xhc3MgVW5wYWNrciB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9ucykge1xuXHRcdFx0aWYgKG9wdGlvbnMudXNlUmVjb3JkcyA9PT0gZmFsc2UgJiYgb3B0aW9ucy5tYXBzQXNPYmplY3RzID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdG9wdGlvbnMubWFwc0FzT2JqZWN0cyA9IHRydWU7XG5cdFx0XHRpZiAob3B0aW9ucy5zZXF1ZW50aWFsICYmIG9wdGlvbnMudHJ1c3RlZCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0b3B0aW9ucy50cnVzdGVkID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCFvcHRpb25zLnN0cnVjdHVyZXMgJiYgb3B0aW9ucy51c2VSZWNvcmRzICE9IGZhbHNlKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5zdHJ1Y3R1cmVzID0gW107XG5cdFx0XHRcdFx0aWYgKCFvcHRpb25zLm1heFNoYXJlZFN0cnVjdHVyZXMpXG5cdFx0XHRcdFx0XHRvcHRpb25zLm1heFNoYXJlZFN0cnVjdHVyZXMgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9ucy5zdHJ1Y3R1cmVzKVxuXHRcdFx0XHRvcHRpb25zLnN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoID0gb3B0aW9ucy5zdHJ1Y3R1cmVzLmxlbmd0aDtcblx0XHRcdGVsc2UgaWYgKG9wdGlvbnMuZ2V0U3RydWN0dXJlcykge1xuXHRcdFx0XHQob3B0aW9ucy5zdHJ1Y3R1cmVzID0gW10pLnVuaW5pdGlhbGl6ZWQgPSB0cnVlOyAvLyB0aGlzIGlzIHdoYXQgd2UgdXNlIHRvIGRlbm90ZSBhbiB1bmluaXRpYWxpemVkIHN0cnVjdHVyZXNcblx0XHRcdFx0b3B0aW9ucy5zdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9ucy5pbnQ2NEFzTnVtYmVyKSB7XG5cdFx0XHRcdG9wdGlvbnMuaW50NjRBc1R5cGUgPSAnbnVtYmVyJztcblx0XHRcdH1cblx0XHR9XG5cdFx0T2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcblx0fVxuXHR1bnBhY2soc291cmNlLCBvcHRpb25zKSB7XG5cdFx0aWYgKHNyYykge1xuXHRcdFx0Ly8gcmUtZW50cmFudCBleGVjdXRpb24sIHNhdmUgdGhlIHN0YXRlIGFuZCByZXN0b3JlIGl0IGFmdGVyIHdlIGRvIHRoaXMgdW5wYWNrXG5cdFx0XHRyZXR1cm4gc2F2ZVN0YXRlJDEoKCkgPT4ge1xuXHRcdFx0XHRjbGVhclNvdXJjZSgpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcyA/IHRoaXMudW5wYWNrKHNvdXJjZSwgb3B0aW9ucykgOiBVbnBhY2tyLnByb3RvdHlwZS51bnBhY2suY2FsbChkZWZhdWx0T3B0aW9ucywgc291cmNlLCBvcHRpb25zKVxuXHRcdFx0fSlcblx0XHR9XG5cdFx0aWYgKCFzb3VyY2UuYnVmZmVyICYmIHNvdXJjZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpXG5cdFx0XHRzb3VyY2UgPSB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyA/IEJ1ZmZlci5mcm9tKHNvdXJjZSkgOiBuZXcgVWludDhBcnJheShzb3VyY2UpO1xuXHRcdGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcblx0XHRcdHNyY0VuZCA9IG9wdGlvbnMuZW5kIHx8IHNvdXJjZS5sZW5ndGg7XG5cdFx0XHRwb3NpdGlvbiQxID0gb3B0aW9ucy5zdGFydCB8fCAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwb3NpdGlvbiQxID0gMDtcblx0XHRcdHNyY0VuZCA9IG9wdGlvbnMgPiAtMSA/IG9wdGlvbnMgOiBzb3VyY2UubGVuZ3RoO1xuXHRcdH1cblx0XHRzdHJpbmdQb3NpdGlvbiA9IDA7XG5cdFx0c3JjU3RyaW5nRW5kID0gMDtcblx0XHRzcmNTdHJpbmcgPSBudWxsO1xuXHRcdHN0cmluZ3MgPSBFTVBUWV9BUlJBWTtcblx0XHRidW5kbGVkU3RyaW5ncyQxID0gbnVsbDtcblx0XHRzcmMgPSBzb3VyY2U7XG5cdFx0Ly8gdGhpcyBwcm92aWRlcyBjYWNoZWQgYWNjZXNzIHRvIHRoZSBkYXRhIHZpZXcgZm9yIGEgYnVmZmVyIGlmIGl0IGlzIGdldHRpbmcgcmV1c2VkLCB3aGljaCBpcyBhIHJlY29tbWVuZFxuXHRcdC8vIHRlY2huaXF1ZSBmb3IgZ2V0dGluZyBkYXRhIGZyb20gYSBkYXRhYmFzZSB3aGVyZSBpdCBjYW4gYmUgY29waWVkIGludG8gYW4gZXhpc3RpbmcgYnVmZmVyIGluc3RlYWQgb2YgY3JlYXRpbmdcblx0XHQvLyBuZXcgb25lc1xuXHRcdHRyeSB7XG5cdFx0XHRkYXRhVmlldyA9IHNvdXJjZS5kYXRhVmlldyB8fCAoc291cmNlLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNvdXJjZS5idWZmZXIsIHNvdXJjZS5ieXRlT2Zmc2V0LCBzb3VyY2UuYnl0ZUxlbmd0aCkpO1xuXHRcdH0gY2F0Y2goZXJyb3IpIHtcblx0XHRcdC8vIGlmIGl0IGRvZXNuJ3QgaGF2ZSBhIGJ1ZmZlciwgbWF5YmUgaXQgaXMgdGhlIHdyb25nIHR5cGUgb2Ygb2JqZWN0XG5cdFx0XHRzcmMgPSBudWxsO1xuXHRcdFx0aWYgKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG5cdFx0XHRcdHRocm93IGVycm9yXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1NvdXJjZSBtdXN0IGJlIGEgVWludDhBcnJheSBvciBCdWZmZXIgYnV0IHdhcyBhICcgKyAoKHNvdXJjZSAmJiB0eXBlb2Ygc291cmNlID09ICdvYmplY3QnKSA/IHNvdXJjZS5jb25zdHJ1Y3Rvci5uYW1lIDogdHlwZW9mIHNvdXJjZSkpXG5cdFx0fVxuXHRcdGlmICh0aGlzIGluc3RhbmNlb2YgVW5wYWNrcikge1xuXHRcdFx0Y3VycmVudFVucGFja3IgPSB0aGlzO1xuXHRcdFx0aWYgKHRoaXMuc3RydWN0dXJlcykge1xuXHRcdFx0XHRjdXJyZW50U3RydWN0dXJlcyA9IHRoaXMuc3RydWN0dXJlcztcblx0XHRcdFx0cmV0dXJuIGNoZWNrZWRSZWFkKG9wdGlvbnMpXG5cdFx0XHR9IGVsc2UgaWYgKCFjdXJyZW50U3RydWN0dXJlcyB8fCBjdXJyZW50U3RydWN0dXJlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGN1cnJlbnRTdHJ1Y3R1cmVzID0gW107XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1cnJlbnRVbnBhY2tyID0gZGVmYXVsdE9wdGlvbnM7XG5cdFx0XHRpZiAoIWN1cnJlbnRTdHJ1Y3R1cmVzIHx8IGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aCA+IDApXG5cdFx0XHRcdGN1cnJlbnRTdHJ1Y3R1cmVzID0gW107XG5cdFx0fVxuXHRcdHJldHVybiBjaGVja2VkUmVhZChvcHRpb25zKVxuXHR9XG5cdHVucGFja011bHRpcGxlKHNvdXJjZSwgZm9yRWFjaCkge1xuXHRcdGxldCB2YWx1ZXMsIGxhc3RQb3NpdGlvbiA9IDA7XG5cdFx0dHJ5IHtcblx0XHRcdHNlcXVlbnRpYWxNb2RlID0gdHJ1ZTtcblx0XHRcdGxldCBzaXplID0gc291cmNlLmxlbmd0aDtcblx0XHRcdGxldCB2YWx1ZSA9IHRoaXMgPyB0aGlzLnVucGFjayhzb3VyY2UsIHNpemUpIDogZGVmYXVsdFVucGFja3IudW5wYWNrKHNvdXJjZSwgc2l6ZSk7XG5cdFx0XHRpZiAoZm9yRWFjaCkge1xuXHRcdFx0XHRpZiAoZm9yRWFjaCh2YWx1ZSwgbGFzdFBvc2l0aW9uLCBwb3NpdGlvbiQxKSA9PT0gZmFsc2UpIHJldHVybjtcblx0XHRcdFx0d2hpbGUocG9zaXRpb24kMSA8IHNpemUpIHtcblx0XHRcdFx0XHRsYXN0UG9zaXRpb24gPSBwb3NpdGlvbiQxO1xuXHRcdFx0XHRcdGlmIChmb3JFYWNoKGNoZWNrZWRSZWFkKCksIGxhc3RQb3NpdGlvbiwgcG9zaXRpb24kMSkgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR2YWx1ZXMgPSBbIHZhbHVlIF07XG5cdFx0XHRcdHdoaWxlKHBvc2l0aW9uJDEgPCBzaXplKSB7XG5cdFx0XHRcdFx0bGFzdFBvc2l0aW9uID0gcG9zaXRpb24kMTtcblx0XHRcdFx0XHR2YWx1ZXMucHVzaChjaGVja2VkUmVhZCgpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWVzXG5cdFx0XHR9XG5cdFx0fSBjYXRjaChlcnJvcikge1xuXHRcdFx0ZXJyb3IubGFzdFBvc2l0aW9uID0gbGFzdFBvc2l0aW9uO1xuXHRcdFx0ZXJyb3IudmFsdWVzID0gdmFsdWVzO1xuXHRcdFx0dGhyb3cgZXJyb3Jcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0c2VxdWVudGlhbE1vZGUgPSBmYWxzZTtcblx0XHRcdGNsZWFyU291cmNlKCk7XG5cdFx0fVxuXHR9XG5cdF9tZXJnZVN0cnVjdHVyZXMobG9hZGVkU3RydWN0dXJlcywgZXhpc3RpbmdTdHJ1Y3R1cmVzKSB7XG5cdFx0aWYgKG9uTG9hZGVkU3RydWN0dXJlcyQxKVxuXHRcdFx0bG9hZGVkU3RydWN0dXJlcyA9IG9uTG9hZGVkU3RydWN0dXJlcyQxLmNhbGwodGhpcywgbG9hZGVkU3RydWN0dXJlcyk7XG5cdFx0bG9hZGVkU3RydWN0dXJlcyA9IGxvYWRlZFN0cnVjdHVyZXMgfHwgW107XG5cdFx0aWYgKE9iamVjdC5pc0Zyb3plbihsb2FkZWRTdHJ1Y3R1cmVzKSlcblx0XHRcdGxvYWRlZFN0cnVjdHVyZXMgPSBsb2FkZWRTdHJ1Y3R1cmVzLm1hcChzdHJ1Y3R1cmUgPT4gc3RydWN0dXJlLnNsaWNlKDApKTtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IGxvYWRlZFN0cnVjdHVyZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRsZXQgc3RydWN0dXJlID0gbG9hZGVkU3RydWN0dXJlc1tpXTtcblx0XHRcdGlmIChzdHJ1Y3R1cmUpIHtcblx0XHRcdFx0c3RydWN0dXJlLmlzU2hhcmVkID0gdHJ1ZTtcblx0XHRcdFx0aWYgKGkgPj0gMzIpXG5cdFx0XHRcdFx0c3RydWN0dXJlLmhpZ2hCeXRlID0gKGkgLSAzMikgPj4gNTtcblx0XHRcdH1cblx0XHR9XG5cdFx0bG9hZGVkU3RydWN0dXJlcy5zaGFyZWRMZW5ndGggPSBsb2FkZWRTdHJ1Y3R1cmVzLmxlbmd0aDtcblx0XHRmb3IgKGxldCBpZCBpbiBleGlzdGluZ1N0cnVjdHVyZXMgfHwgW10pIHtcblx0XHRcdGlmIChpZCA+PSAwKSB7XG5cdFx0XHRcdGxldCBzdHJ1Y3R1cmUgPSBsb2FkZWRTdHJ1Y3R1cmVzW2lkXTtcblx0XHRcdFx0bGV0IGV4aXN0aW5nID0gZXhpc3RpbmdTdHJ1Y3R1cmVzW2lkXTtcblx0XHRcdFx0aWYgKGV4aXN0aW5nKSB7XG5cdFx0XHRcdFx0aWYgKHN0cnVjdHVyZSlcblx0XHRcdFx0XHRcdChsb2FkZWRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzIHx8IChsb2FkZWRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzID0gW10pKVtpZF0gPSBzdHJ1Y3R1cmU7XG5cdFx0XHRcdFx0bG9hZGVkU3RydWN0dXJlc1tpZF0gPSBleGlzdGluZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5zdHJ1Y3R1cmVzID0gbG9hZGVkU3RydWN0dXJlc1xuXHR9XG5cdGRlY29kZShzb3VyY2UsIG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gdGhpcy51bnBhY2soc291cmNlLCBvcHRpb25zKVxuXHR9XG59XG5mdW5jdGlvbiBjaGVja2VkUmVhZChvcHRpb25zKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFjdXJyZW50VW5wYWNrci50cnVzdGVkICYmICFzZXF1ZW50aWFsTW9kZSkge1xuXHRcdFx0bGV0IHNoYXJlZExlbmd0aCA9IGN1cnJlbnRTdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCB8fCAwO1xuXHRcdFx0aWYgKHNoYXJlZExlbmd0aCA8IGN1cnJlbnRTdHJ1Y3R1cmVzLmxlbmd0aClcblx0XHRcdFx0Y3VycmVudFN0cnVjdHVyZXMubGVuZ3RoID0gc2hhcmVkTGVuZ3RoO1xuXHRcdH1cblx0XHRsZXQgcmVzdWx0O1xuXHRcdGlmIChjdXJyZW50VW5wYWNrci5yYW5kb21BY2Nlc3NTdHJ1Y3R1cmUgJiYgc3JjW3Bvc2l0aW9uJDFdIDwgMHg0MCAmJiBzcmNbcG9zaXRpb24kMV0gPj0gMHgyMCAmJiByZWFkU3RydWN0JDEpIHtcblx0XHRcdHJlc3VsdCA9IHJlYWRTdHJ1Y3QkMShzcmMsIHBvc2l0aW9uJDEsIHNyY0VuZCwgY3VycmVudFVucGFja3IpO1xuXHRcdFx0c3JjID0gbnVsbDsgLy8gZGlzcG9zZSBvZiB0aGlzIHNvIHRoYXQgcmVjdXJzaXZlIHVucGFjayBjYWxscyBkb24ndCBzYXZlIHN0YXRlXG5cdFx0XHRpZiAoIShvcHRpb25zICYmIG9wdGlvbnMubGF6eSkgJiYgcmVzdWx0KVxuXHRcdFx0XHRyZXN1bHQgPSByZXN1bHQudG9KU09OKCk7XG5cdFx0XHRwb3NpdGlvbiQxID0gc3JjRW5kO1xuXHRcdH0gZWxzZVxuXHRcdFx0cmVzdWx0ID0gcmVhZCgpO1xuXHRcdGlmIChidW5kbGVkU3RyaW5ncyQxKSB7IC8vIGJ1bmRsZWQgc3RyaW5ncyB0byBza2lwIHBhc3Rcblx0XHRcdHBvc2l0aW9uJDEgPSBidW5kbGVkU3RyaW5ncyQxLnBvc3RCdW5kbGVQb3NpdGlvbjtcblx0XHRcdGJ1bmRsZWRTdHJpbmdzJDEgPSBudWxsO1xuXHRcdH1cblx0XHRpZiAoc2VxdWVudGlhbE1vZGUpXG5cdFx0XHQvLyB3ZSBvbmx5IG5lZWQgdG8gcmVzdG9yZSB0aGUgc3RydWN0dXJlcyBpZiB0aGVyZSB3YXMgYW4gZXJyb3IsIGJ1dCBpZiB3ZSBjb21wbGV0ZWQgYSByZWFkLFxuXHRcdFx0Ly8gd2UgY2FuIGNsZWFyIHRoaXMgb3V0IGFuZCBrZWVwIHRoZSBzdHJ1Y3R1cmVzIHdlIHJlYWRcblx0XHRcdGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzID0gbnVsbDtcblxuXHRcdGlmIChwb3NpdGlvbiQxID09IHNyY0VuZCkge1xuXHRcdFx0Ly8gZmluaXNoZWQgcmVhZGluZyB0aGlzIHNvdXJjZSwgY2xlYW51cCByZWZlcmVuY2VzXG5cdFx0XHRpZiAoY3VycmVudFN0cnVjdHVyZXMgJiYgY3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMpXG5cdFx0XHRcdHJlc3RvcmVTdHJ1Y3R1cmVzKCk7XG5cdFx0XHRjdXJyZW50U3RydWN0dXJlcyA9IG51bGw7XG5cdFx0XHRzcmMgPSBudWxsO1xuXHRcdFx0aWYgKHJlZmVyZW5jZU1hcClcblx0XHRcdFx0cmVmZXJlbmNlTWFwID0gbnVsbDtcblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uJDEgPiBzcmNFbmQpIHtcblx0XHRcdC8vIG92ZXIgcmVhZFxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBNZXNzYWdlUGFjayBkYXRhJylcblx0XHR9IGVsc2UgaWYgKCFzZXF1ZW50aWFsTW9kZSkge1xuXHRcdFx0bGV0IGpzb25WaWV3O1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0anNvblZpZXcgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQsIChfLCB2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiID8gYCR7dmFsdWV9bmAgOiB2YWx1ZSkuc2xpY2UoMCwgMTAwKTtcblx0XHRcdH0gY2F0Y2goZXJyb3IpIHtcblx0XHRcdFx0anNvblZpZXcgPSAnKEpTT04gdmlldyBub3QgYXZhaWxhYmxlICcgKyBlcnJvciArICcpJztcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcignRGF0YSByZWFkLCBidXQgZW5kIG9mIGJ1ZmZlciBub3QgcmVhY2hlZCAnICsganNvblZpZXcpXG5cdFx0fVxuXHRcdC8vIGVsc2UgbW9yZSB0byByZWFkLCBidXQgd2UgYXJlIHJlYWRpbmcgc2VxdWVudGlhbGx5LCBzbyBkb24ndCBjbGVhciBzb3VyY2UgeWV0XG5cdFx0cmV0dXJuIHJlc3VsdFxuXHR9IGNhdGNoKGVycm9yKSB7XG5cdFx0aWYgKGN1cnJlbnRTdHJ1Y3R1cmVzICYmIGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzKVxuXHRcdFx0cmVzdG9yZVN0cnVjdHVyZXMoKTtcblx0XHRjbGVhclNvdXJjZSgpO1xuXHRcdGlmIChlcnJvciBpbnN0YW5jZW9mIFJhbmdlRXJyb3IgfHwgZXJyb3IubWVzc2FnZS5zdGFydHNXaXRoKCdVbmV4cGVjdGVkIGVuZCBvZiBidWZmZXInKSB8fCBwb3NpdGlvbiQxID4gc3JjRW5kKSB7XG5cdFx0XHRlcnJvci5pbmNvbXBsZXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0dGhyb3cgZXJyb3Jcblx0fVxufVxuXG5mdW5jdGlvbiByZXN0b3JlU3RydWN0dXJlcygpIHtcblx0Zm9yIChsZXQgaWQgaW4gY3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMpIHtcblx0XHRjdXJyZW50U3RydWN0dXJlc1tpZF0gPSBjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlc1tpZF07XG5cdH1cblx0Y3VycmVudFN0cnVjdHVyZXMucmVzdG9yZVN0cnVjdHVyZXMgPSBudWxsO1xufVxuXG5mdW5jdGlvbiByZWFkKCkge1xuXHRsZXQgdG9rZW4gPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0aWYgKHRva2VuIDwgMHhhMCkge1xuXHRcdGlmICh0b2tlbiA8IDB4ODApIHtcblx0XHRcdGlmICh0b2tlbiA8IDB4NDApXG5cdFx0XHRcdHJldHVybiB0b2tlblxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxldCBzdHJ1Y3R1cmUgPSBjdXJyZW50U3RydWN0dXJlc1t0b2tlbiAmIDB4M2ZdIHx8XG5cdFx0XHRcdFx0Y3VycmVudFVucGFja3IuZ2V0U3RydWN0dXJlcyAmJiBsb2FkU3RydWN0dXJlcygpW3Rva2VuICYgMHgzZl07XG5cdFx0XHRcdGlmIChzdHJ1Y3R1cmUpIHtcblx0XHRcdFx0XHRpZiAoIXN0cnVjdHVyZS5yZWFkKSB7XG5cdFx0XHRcdFx0XHRzdHJ1Y3R1cmUucmVhZCA9IGNyZWF0ZVN0cnVjdHVyZVJlYWRlcihzdHJ1Y3R1cmUsIHRva2VuICYgMHgzZik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBzdHJ1Y3R1cmUucmVhZCgpXG5cdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdHJldHVybiB0b2tlblxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAodG9rZW4gPCAweDkwKSB7XG5cdFx0XHQvLyBtYXBcblx0XHRcdHRva2VuIC09IDB4ODA7XG5cdFx0XHRpZiAoY3VycmVudFVucGFja3IubWFwc0FzT2JqZWN0cykge1xuXHRcdFx0XHRsZXQgb2JqZWN0ID0ge307XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW47IGkrKykge1xuXHRcdFx0XHRcdGxldCBrZXkgPSByZWFkS2V5KCk7XG5cdFx0XHRcdFx0aWYgKGtleSA9PT0gJ19fcHJvdG9fXycpXG5cdFx0XHRcdFx0XHRrZXkgPSAnX19wcm90b18nO1xuXHRcdFx0XHRcdG9iamVjdFtrZXldID0gcmVhZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBvYmplY3Rcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxldCBtYXAgPSBuZXcgTWFwKCk7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW47IGkrKykge1xuXHRcdFx0XHRcdG1hcC5zZXQocmVhZCgpLCByZWFkKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXBcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dG9rZW4gLT0gMHg5MDtcblx0XHRcdGxldCBhcnJheSA9IG5ldyBBcnJheSh0b2tlbik7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuOyBpKyspIHtcblx0XHRcdFx0YXJyYXlbaV0gPSByZWFkKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY3VycmVudFVucGFja3IuZnJlZXplRGF0YSlcblx0XHRcdFx0cmV0dXJuIE9iamVjdC5mcmVlemUoYXJyYXkpXG5cdFx0XHRyZXR1cm4gYXJyYXlcblx0XHR9XG5cdH0gZWxzZSBpZiAodG9rZW4gPCAweGMwKSB7XG5cdFx0Ly8gZml4c3RyXG5cdFx0bGV0IGxlbmd0aCA9IHRva2VuIC0gMHhhMDtcblx0XHRpZiAoc3JjU3RyaW5nRW5kID49IHBvc2l0aW9uJDEpIHtcblx0XHRcdHJldHVybiBzcmNTdHJpbmcuc2xpY2UocG9zaXRpb24kMSAtIHNyY1N0cmluZ1N0YXJ0LCAocG9zaXRpb24kMSArPSBsZW5ndGgpIC0gc3JjU3RyaW5nU3RhcnQpXG5cdFx0fVxuXHRcdGlmIChzcmNTdHJpbmdFbmQgPT0gMCAmJiBzcmNFbmQgPCAxNDApIHtcblx0XHRcdC8vIGZvciBzbWFsbCBibG9ja3MsIGF2b2lkaW5nIHRoZSBvdmVyaGVhZCBvZiB0aGUgZXh0cmFjdCBjYWxsIGlzIGhlbHBmdWxcblx0XHRcdGxldCBzdHJpbmcgPSBsZW5ndGggPCAxNiA/IHNob3J0U3RyaW5nSW5KUyhsZW5ndGgpIDogbG9uZ1N0cmluZ0luSlMobGVuZ3RoKTtcblx0XHRcdGlmIChzdHJpbmcgIT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIHN0cmluZ1xuXHRcdH1cblx0XHRyZXR1cm4gcmVhZEZpeGVkU3RyaW5nKGxlbmd0aClcblx0fSBlbHNlIHtcblx0XHRsZXQgdmFsdWU7XG5cdFx0c3dpdGNoICh0b2tlbikge1xuXHRcdFx0Y2FzZSAweGMwOiByZXR1cm4gbnVsbFxuXHRcdFx0Y2FzZSAweGMxOlxuXHRcdFx0XHRpZiAoYnVuZGxlZFN0cmluZ3MkMSkge1xuXHRcdFx0XHRcdHZhbHVlID0gcmVhZCgpOyAvLyBmb2xsb3dlZCBieSB0aGUgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgaW4gY2hhcmFjdGVycyAobm90IGJ5dGVzISlcblx0XHRcdFx0XHRpZiAodmFsdWUgPiAwKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGJ1bmRsZWRTdHJpbmdzJDFbMV0uc2xpY2UoYnVuZGxlZFN0cmluZ3MkMS5wb3NpdGlvbjEsIGJ1bmRsZWRTdHJpbmdzJDEucG9zaXRpb24xICs9IHZhbHVlKVxuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdHJldHVybiBidW5kbGVkU3RyaW5ncyQxWzBdLnNsaWNlKGJ1bmRsZWRTdHJpbmdzJDEucG9zaXRpb24wLCBidW5kbGVkU3RyaW5ncyQxLnBvc2l0aW9uMCAtPSB2YWx1ZSlcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gQzE7IC8vIFwibmV2ZXItdXNlZFwiLCByZXR1cm4gc3BlY2lhbCBvYmplY3QgdG8gZGVub3RlIHRoYXRcblx0XHRcdGNhc2UgMHhjMjogcmV0dXJuIGZhbHNlXG5cdFx0XHRjYXNlIDB4YzM6IHJldHVybiB0cnVlXG5cdFx0XHRjYXNlIDB4YzQ6XG5cdFx0XHRcdC8vIGJpbiA4XG5cdFx0XHRcdHZhbHVlID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgYnVmZmVyJylcblx0XHRcdFx0cmV0dXJuIHJlYWRCaW4odmFsdWUpXG5cdFx0XHRjYXNlIDB4YzU6XG5cdFx0XHRcdC8vIGJpbiAxNlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbiQxKTtcblx0XHRcdFx0cG9zaXRpb24kMSArPSAyO1xuXHRcdFx0XHRyZXR1cm4gcmVhZEJpbih2YWx1ZSlcblx0XHRcdGNhc2UgMHhjNjpcblx0XHRcdFx0Ly8gYmluIDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDQ7XG5cdFx0XHRcdHJldHVybiByZWFkQmluKHZhbHVlKVxuXHRcdFx0Y2FzZSAweGM3OlxuXHRcdFx0XHQvLyBleHQgOFxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dChzcmNbcG9zaXRpb24kMSsrXSlcblx0XHRcdGNhc2UgMHhjODpcblx0XHRcdFx0Ly8gZXh0IDE2XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDI7XG5cdFx0XHRcdHJldHVybiByZWFkRXh0KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGM5OlxuXHRcdFx0XHQvLyBleHQgMzJcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gNDtcblx0XHRcdFx0cmV0dXJuIHJlYWRFeHQodmFsdWUpXG5cdFx0XHRjYXNlIDB4Y2E6XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0RmxvYXQzMihwb3NpdGlvbiQxKTtcblx0XHRcdFx0aWYgKGN1cnJlbnRVbnBhY2tyLnVzZUZsb2F0MzIgPiAyKSB7XG5cdFx0XHRcdFx0Ly8gdGhpcyBkb2VzIHJvdW5kaW5nIG9mIG51bWJlcnMgdGhhdCB3ZXJlIGVuY29kZWQgaW4gMzItYml0IGZsb2F0IHRvIG5lYXJlc3Qgc2lnbmlmaWNhbnQgZGVjaW1hbCBkaWdpdCB0aGF0IGNvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0XHRcdGxldCBtdWx0aXBsaWVyID0gbXVsdDEwWygoc3JjW3Bvc2l0aW9uJDFdICYgMHg3ZikgPDwgMSkgfCAoc3JjW3Bvc2l0aW9uJDEgKyAxXSA+PiA3KV07XG5cdFx0XHRcdFx0cG9zaXRpb24kMSArPSA0O1xuXHRcdFx0XHRcdHJldHVybiAoKG11bHRpcGxpZXIgKiB2YWx1ZSArICh2YWx1ZSA+IDAgPyAwLjUgOiAtMC41KSkgPj4gMCkgLyBtdWx0aXBsaWVyXG5cdFx0XHRcdH1cblx0XHRcdFx0cG9zaXRpb24kMSArPSA0O1xuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdGNhc2UgMHhjYjpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRGbG9hdDY0KHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDg7XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0Ly8gdWludCBoYW5kbGVyc1xuXHRcdFx0Y2FzZSAweGNjOlxuXHRcdFx0XHRyZXR1cm4gc3JjW3Bvc2l0aW9uJDErK11cblx0XHRcdGNhc2UgMHhjZDpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gMjtcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHRjYXNlIDB4Y2U6XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDQ7XG5cdFx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdFx0Y2FzZSAweGNmOlxuXHRcdFx0XHRpZiAoY3VycmVudFVucGFja3IuaW50NjRBc1R5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24kMSkgKiAweDEwMDAwMDAwMDtcblx0XHRcdFx0XHR2YWx1ZSArPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24kMSArIDQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnVWludDY0KHBvc2l0aW9uJDEpLnRvU3RyaW5nKCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY3VycmVudFVucGFja3IuaW50NjRBc1R5cGUgPT09ICdhdXRvJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnVWludDY0KHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRcdGlmICh2YWx1ZTw9QmlnSW50KDIpPDxCaWdJbnQoNTIpKSB2YWx1ZT1OdW1iZXIodmFsdWUpO1xuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHR2YWx1ZSA9IGRhdGFWaWV3LmdldEJpZ1VpbnQ2NChwb3NpdGlvbiQxKTtcblx0XHRcdFx0cG9zaXRpb24kMSArPSA4O1xuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblxuXHRcdFx0Ly8gaW50IGhhbmRsZXJzXG5cdFx0XHRjYXNlIDB4ZDA6XG5cdFx0XHRcdHJldHVybiBkYXRhVmlldy5nZXRJbnQ4KHBvc2l0aW9uJDErKylcblx0XHRcdGNhc2UgMHhkMTpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRJbnQxNihwb3NpdGlvbiQxKTtcblx0XHRcdFx0cG9zaXRpb24kMSArPSAyO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdGNhc2UgMHhkMjpcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRJbnQzMihwb3NpdGlvbiQxKTtcblx0XHRcdFx0cG9zaXRpb24kMSArPSA0O1xuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdGNhc2UgMHhkMzpcblx0XHRcdFx0aWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0SW50MzIocG9zaXRpb24kMSkgKiAweDEwMDAwMDAwMDtcblx0XHRcdFx0XHR2YWx1ZSArPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24kMSArIDQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGN1cnJlbnRVbnBhY2tyLmludDY0QXNUeXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnSW50NjQocG9zaXRpb24kMSkudG9TdHJpbmcoKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjdXJyZW50VW5wYWNrci5pbnQ2NEFzVHlwZSA9PT0gJ2F1dG8nKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRCaWdJbnQ2NChwb3NpdGlvbiQxKTtcblx0XHRcdFx0XHRpZiAodmFsdWU+PUJpZ0ludCgtMik8PEJpZ0ludCg1MikmJnZhbHVlPD1CaWdJbnQoMik8PEJpZ0ludCg1MikpIHZhbHVlPU51bWJlcih2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0QmlnSW50NjQocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gODtcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cblx0XHRcdGNhc2UgMHhkNDpcblx0XHRcdFx0Ly8gZml4ZXh0IDFcblx0XHRcdFx0dmFsdWUgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0aWYgKHZhbHVlID09IDB4NzIpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVjb3JkRGVmaW5pdGlvbihzcmNbcG9zaXRpb24kMSsrXSAmIDB4M2YpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGV0IGV4dGVuc2lvbiA9IGN1cnJlbnRFeHRlbnNpb25zW3ZhbHVlXTtcblx0XHRcdFx0XHRpZiAoZXh0ZW5zaW9uKSB7XG5cdFx0XHRcdFx0XHRpZiAoZXh0ZW5zaW9uLnJlYWQpIHtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24kMSsrOyAvLyBza2lwIGZpbGxlciBieXRlXG5cdFx0XHRcdFx0XHRcdHJldHVybiBleHRlbnNpb24ucmVhZChyZWFkKCkpXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGV4dGVuc2lvbi5ub0J1ZmZlcikge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiQxKys7IC8vIHNraXAgZmlsbGVyIGJ5dGVcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGV4dGVuc2lvbigpXG5cdFx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGV4dGVuc2lvbihzcmMuc3ViYXJyYXkocG9zaXRpb24kMSwgKytwb3NpdGlvbiQxKSlcblx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5rbm93biBleHRlbnNpb24gJyArIHZhbHVlKVxuXHRcdFx0XHR9XG5cdFx0XHRjYXNlIDB4ZDU6XG5cdFx0XHRcdC8vIGZpeGV4dCAyXG5cdFx0XHRcdHZhbHVlID0gc3JjW3Bvc2l0aW9uJDFdO1xuXHRcdFx0XHRpZiAodmFsdWUgPT0gMHg3Mikge1xuXHRcdFx0XHRcdHBvc2l0aW9uJDErKztcblx0XHRcdFx0XHRyZXR1cm4gcmVjb3JkRGVmaW5pdGlvbihzcmNbcG9zaXRpb24kMSsrXSAmIDB4M2YsIHNyY1twb3NpdGlvbiQxKytdKVxuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRyZXR1cm4gcmVhZEV4dCgyKVxuXHRcdFx0Y2FzZSAweGQ2OlxuXHRcdFx0XHQvLyBmaXhleHQgNFxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dCg0KVxuXHRcdFx0Y2FzZSAweGQ3OlxuXHRcdFx0XHQvLyBmaXhleHQgOFxuXHRcdFx0XHRyZXR1cm4gcmVhZEV4dCg4KVxuXHRcdFx0Y2FzZSAweGQ4OlxuXHRcdFx0XHQvLyBmaXhleHQgMTZcblx0XHRcdFx0cmV0dXJuIHJlYWRFeHQoMTYpXG5cdFx0XHRjYXNlIDB4ZDk6XG5cdFx0XHQvLyBzdHIgOFxuXHRcdFx0XHR2YWx1ZSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRpZiAoc3JjU3RyaW5nRW5kID49IHBvc2l0aW9uJDEpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3JjU3RyaW5nLnNsaWNlKHBvc2l0aW9uJDEgLSBzcmNTdHJpbmdTdGFydCwgKHBvc2l0aW9uJDEgKz0gdmFsdWUpIC0gc3JjU3RyaW5nU3RhcnQpXG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlYWRTdHJpbmc4KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRhOlxuXHRcdFx0Ly8gc3RyIDE2XG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDI7XG5cdFx0XHRcdGlmIChzcmNTdHJpbmdFbmQgPj0gcG9zaXRpb24kMSkge1xuXHRcdFx0XHRcdHJldHVybiBzcmNTdHJpbmcuc2xpY2UocG9zaXRpb24kMSAtIHNyY1N0cmluZ1N0YXJ0LCAocG9zaXRpb24kMSArPSB2YWx1ZSkgLSBzcmNTdHJpbmdTdGFydClcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVhZFN0cmluZzE2KHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRiOlxuXHRcdFx0Ly8gc3RyIDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDQ7XG5cdFx0XHRcdGlmIChzcmNTdHJpbmdFbmQgPj0gcG9zaXRpb24kMSkge1xuXHRcdFx0XHRcdHJldHVybiBzcmNTdHJpbmcuc2xpY2UocG9zaXRpb24kMSAtIHNyY1N0cmluZ1N0YXJ0LCAocG9zaXRpb24kMSArPSB2YWx1ZSkgLSBzcmNTdHJpbmdTdGFydClcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVhZFN0cmluZzMyKHZhbHVlKVxuXHRcdFx0Y2FzZSAweGRjOlxuXHRcdFx0Ly8gYXJyYXkgMTZcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gMjtcblx0XHRcdFx0cmV0dXJuIHJlYWRBcnJheSh2YWx1ZSlcblx0XHRcdGNhc2UgMHhkZDpcblx0XHRcdC8vIGFycmF5IDMyXG5cdFx0XHRcdHZhbHVlID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDQ7XG5cdFx0XHRcdHJldHVybiByZWFkQXJyYXkodmFsdWUpXG5cdFx0XHRjYXNlIDB4ZGU6XG5cdFx0XHQvLyBtYXAgMTZcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gMjtcblx0XHRcdFx0cmV0dXJuIHJlYWRNYXAodmFsdWUpXG5cdFx0XHRjYXNlIDB4ZGY6XG5cdFx0XHQvLyBtYXAgMzJcblx0XHRcdFx0dmFsdWUgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24kMSk7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gNDtcblx0XHRcdFx0cmV0dXJuIHJlYWRNYXAodmFsdWUpXG5cdFx0XHRkZWZhdWx0OiAvLyBuZWdhdGl2ZSBpbnRcblx0XHRcdFx0aWYgKHRva2VuID49IDB4ZTApXG5cdFx0XHRcdFx0cmV0dXJuIHRva2VuIC0gMHgxMDBcblx0XHRcdFx0aWYgKHRva2VuID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRsZXQgZXJyb3IgPSBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIE1lc3NhZ2VQYWNrIGRhdGEnKTtcblx0XHRcdFx0XHRlcnJvci5pbmNvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHR0aHJvdyBlcnJvclxuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5rbm93biBNZXNzYWdlUGFjayB0b2tlbiAnICsgdG9rZW4pXG5cblx0XHR9XG5cdH1cbn1cbmNvbnN0IHZhbGlkTmFtZSA9IC9eW2EtekEtWl8kXVthLXpBLVpcXGRfJF0qJC87XG5mdW5jdGlvbiBjcmVhdGVTdHJ1Y3R1cmVSZWFkZXIoc3RydWN0dXJlLCBmaXJzdElkKSB7XG5cdGZ1bmN0aW9uIHJlYWRPYmplY3QoKSB7XG5cdFx0Ly8gVGhpcyBpbml0aWFsIGZ1bmN0aW9uIGlzIHF1aWNrIHRvIGluc3RhbnRpYXRlLCBidXQgcnVucyBzbG93ZXIuIEFmdGVyIHNldmVyYWwgaXRlcmF0aW9ucyBwYXkgdGhlIGNvc3QgdG8gYnVpbGQgdGhlIGZhc3RlciBmdW5jdGlvblxuXHRcdGlmIChyZWFkT2JqZWN0LmNvdW50KysgPiBpbmxpbmVPYmplY3RSZWFkVGhyZXNob2xkKSB7XG5cdFx0XHRsZXQgcmVhZE9iamVjdCA9IHN0cnVjdHVyZS5yZWFkID0gKG5ldyBGdW5jdGlvbigncicsICdyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gJyArIChjdXJyZW50VW5wYWNrci5mcmVlemVEYXRhID8gJ09iamVjdC5mcmVlemUnIDogJycpICtcblx0XHRcdFx0Jyh7JyArIHN0cnVjdHVyZS5tYXAoa2V5ID0+IGtleSA9PT0gJ19fcHJvdG9fXycgPyAnX19wcm90b186cigpJyA6IHZhbGlkTmFtZS50ZXN0KGtleSkgPyBrZXkgKyAnOnIoKScgOiAoJ1snICsgSlNPTi5zdHJpbmdpZnkoa2V5KSArICddOnIoKScpKS5qb2luKCcsJykgKyAnfSl9JykpKHJlYWQpO1xuXHRcdFx0aWYgKHN0cnVjdHVyZS5oaWdoQnl0ZSA9PT0gMClcblx0XHRcdFx0c3RydWN0dXJlLnJlYWQgPSBjcmVhdGVTZWNvbmRCeXRlUmVhZGVyKGZpcnN0SWQsIHN0cnVjdHVyZS5yZWFkKTtcblx0XHRcdHJldHVybiByZWFkT2JqZWN0KCkgLy8gc2Vjb25kIGJ5dGUgaXMgYWxyZWFkeSByZWFkLCBpZiB0aGVyZSBpcyBvbmUgc28gaW1tZWRpYXRlbHkgcmVhZCBvYmplY3Rcblx0XHR9XG5cdFx0bGV0IG9iamVjdCA9IHt9O1xuXHRcdGZvciAobGV0IGkgPSAwLCBsID0gc3RydWN0dXJlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0bGV0IGtleSA9IHN0cnVjdHVyZVtpXTtcblx0XHRcdGlmIChrZXkgPT09ICdfX3Byb3RvX18nKVxuXHRcdFx0XHRrZXkgPSAnX19wcm90b18nO1xuXHRcdFx0b2JqZWN0W2tleV0gPSByZWFkKCk7XG5cdFx0fVxuXHRcdGlmIChjdXJyZW50VW5wYWNrci5mcmVlemVEYXRhKVxuXHRcdFx0cmV0dXJuIE9iamVjdC5mcmVlemUob2JqZWN0KTtcblx0XHRyZXR1cm4gb2JqZWN0XG5cdH1cblx0cmVhZE9iamVjdC5jb3VudCA9IDA7XG5cdGlmIChzdHJ1Y3R1cmUuaGlnaEJ5dGUgPT09IDApIHtcblx0XHRyZXR1cm4gY3JlYXRlU2Vjb25kQnl0ZVJlYWRlcihmaXJzdElkLCByZWFkT2JqZWN0KVxuXHR9XG5cdHJldHVybiByZWFkT2JqZWN0XG59XG5cbmNvbnN0IGNyZWF0ZVNlY29uZEJ5dGVSZWFkZXIgPSAoZmlyc3RJZCwgcmVhZDApID0+IHtcblx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdGxldCBoaWdoQnl0ZSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdGlmIChoaWdoQnl0ZSA9PT0gMClcblx0XHRcdHJldHVybiByZWFkMCgpXG5cdFx0bGV0IGlkID0gZmlyc3RJZCA8IDMyID8gLShmaXJzdElkICsgKGhpZ2hCeXRlIDw8IDUpKSA6IGZpcnN0SWQgKyAoaGlnaEJ5dGUgPDwgNSk7XG5cdFx0bGV0IHN0cnVjdHVyZSA9IGN1cnJlbnRTdHJ1Y3R1cmVzW2lkXSB8fCBsb2FkU3RydWN0dXJlcygpW2lkXTtcblx0XHRpZiAoIXN0cnVjdHVyZSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdSZWNvcmQgaWQgaXMgbm90IGRlZmluZWQgZm9yICcgKyBpZClcblx0XHR9XG5cdFx0aWYgKCFzdHJ1Y3R1cmUucmVhZClcblx0XHRcdHN0cnVjdHVyZS5yZWFkID0gY3JlYXRlU3RydWN0dXJlUmVhZGVyKHN0cnVjdHVyZSwgZmlyc3RJZCk7XG5cdFx0cmV0dXJuIHN0cnVjdHVyZS5yZWFkKClcblx0fVxufTtcblxuZnVuY3Rpb24gbG9hZFN0cnVjdHVyZXMoKSB7XG5cdGxldCBsb2FkZWRTdHJ1Y3R1cmVzID0gc2F2ZVN0YXRlJDEoKCkgPT4ge1xuXHRcdC8vIHNhdmUgdGhlIHN0YXRlIGluIGNhc2UgZ2V0U3RydWN0dXJlcyBtb2RpZmllcyBvdXIgYnVmZmVyXG5cdFx0c3JjID0gbnVsbDtcblx0XHRyZXR1cm4gY3VycmVudFVucGFja3IuZ2V0U3RydWN0dXJlcygpXG5cdH0pO1xuXHRyZXR1cm4gY3VycmVudFN0cnVjdHVyZXMgPSBjdXJyZW50VW5wYWNrci5fbWVyZ2VTdHJ1Y3R1cmVzKGxvYWRlZFN0cnVjdHVyZXMsIGN1cnJlbnRTdHJ1Y3R1cmVzKVxufVxuXG52YXIgcmVhZEZpeGVkU3RyaW5nID0gcmVhZFN0cmluZ0pTO1xudmFyIHJlYWRTdHJpbmc4ID0gcmVhZFN0cmluZ0pTO1xudmFyIHJlYWRTdHJpbmcxNiA9IHJlYWRTdHJpbmdKUztcbnZhciByZWFkU3RyaW5nMzIgPSByZWFkU3RyaW5nSlM7XG5leHBvcnRzLmlzTmF0aXZlQWNjZWxlcmF0aW9uRW5hYmxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBzZXRFeHRyYWN0b3IoZXh0cmFjdFN0cmluZ3MpIHtcblx0ZXhwb3J0cy5pc05hdGl2ZUFjY2VsZXJhdGlvbkVuYWJsZWQgPSB0cnVlO1xuXHRyZWFkRml4ZWRTdHJpbmcgPSByZWFkU3RyaW5nKDEpO1xuXHRyZWFkU3RyaW5nOCA9IHJlYWRTdHJpbmcoMik7XG5cdHJlYWRTdHJpbmcxNiA9IHJlYWRTdHJpbmcoMyk7XG5cdHJlYWRTdHJpbmczMiA9IHJlYWRTdHJpbmcoNSk7XG5cdGZ1bmN0aW9uIHJlYWRTdHJpbmcoaGVhZGVyTGVuZ3RoKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHJlYWRTdHJpbmcobGVuZ3RoKSB7XG5cdFx0XHRsZXQgc3RyaW5nID0gc3RyaW5nc1tzdHJpbmdQb3NpdGlvbisrXTtcblx0XHRcdGlmIChzdHJpbmcgPT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoYnVuZGxlZFN0cmluZ3MkMSlcblx0XHRcdFx0XHRyZXR1cm4gcmVhZFN0cmluZ0pTKGxlbmd0aClcblx0XHRcdFx0bGV0IGJ5dGVPZmZzZXQgPSBzcmMuYnl0ZU9mZnNldDtcblx0XHRcdFx0bGV0IGV4dHJhY3Rpb24gPSBleHRyYWN0U3RyaW5ncyhwb3NpdGlvbiQxIC0gaGVhZGVyTGVuZ3RoICsgYnl0ZU9mZnNldCwgc3JjRW5kICsgYnl0ZU9mZnNldCwgc3JjLmJ1ZmZlcik7XG5cdFx0XHRcdGlmICh0eXBlb2YgZXh0cmFjdGlvbiA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHN0cmluZyA9IGV4dHJhY3Rpb247XG5cdFx0XHRcdFx0c3RyaW5ncyA9IEVNUFRZX0FSUkFZO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0cmluZ3MgPSBleHRyYWN0aW9uO1xuXHRcdFx0XHRcdHN0cmluZ1Bvc2l0aW9uID0gMTtcblx0XHRcdFx0XHRzcmNTdHJpbmdFbmQgPSAxOyAvLyBldmVuIGlmIGEgdXRmLTggc3RyaW5nIHdhcyBkZWNvZGVkLCBtdXN0IGluZGljYXRlIHdlIGFyZSBpbiB0aGUgbWlkc3Qgb2YgZXh0cmFjdGVkIHN0cmluZ3MgYW5kIGNhbid0IHNraXAgc3RyaW5nc1xuXHRcdFx0XHRcdHN0cmluZyA9IHN0cmluZ3NbMF07XG5cdFx0XHRcdFx0aWYgKHN0cmluZyA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBidWZmZXInKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsZXQgc3JjU3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHRcdGlmIChzcmNTdHJpbmdMZW5ndGggPD0gbGVuZ3RoKSB7XG5cdFx0XHRcdHBvc2l0aW9uJDEgKz0gbGVuZ3RoO1xuXHRcdFx0XHRyZXR1cm4gc3RyaW5nXG5cdFx0XHR9XG5cdFx0XHRzcmNTdHJpbmcgPSBzdHJpbmc7XG5cdFx0XHRzcmNTdHJpbmdTdGFydCA9IHBvc2l0aW9uJDE7XG5cdFx0XHRzcmNTdHJpbmdFbmQgPSBwb3NpdGlvbiQxICsgc3JjU3RyaW5nTGVuZ3RoO1xuXHRcdFx0cG9zaXRpb24kMSArPSBsZW5ndGg7XG5cdFx0XHRyZXR1cm4gc3RyaW5nLnNsaWNlKDAsIGxlbmd0aCkgLy8gd2Uga25vdyB3ZSBqdXN0IHdhbnQgdGhlIGJlZ2lubmluZ1xuXHRcdH1cblx0fVxufVxuZnVuY3Rpb24gcmVhZFN0cmluZ0pTKGxlbmd0aCkge1xuXHRsZXQgcmVzdWx0O1xuXHRpZiAobGVuZ3RoIDwgMTYpIHtcblx0XHRpZiAocmVzdWx0ID0gc2hvcnRTdHJpbmdJbkpTKGxlbmd0aCkpXG5cdFx0XHRyZXR1cm4gcmVzdWx0XG5cdH1cblx0aWYgKGxlbmd0aCA+IDY0ICYmIGRlY29kZXIpXG5cdFx0cmV0dXJuIGRlY29kZXIuZGVjb2RlKHNyYy5zdWJhcnJheShwb3NpdGlvbiQxLCBwb3NpdGlvbiQxICs9IGxlbmd0aCkpXG5cdGNvbnN0IGVuZCA9IHBvc2l0aW9uJDEgKyBsZW5ndGg7XG5cdGNvbnN0IHVuaXRzID0gW107XG5cdHJlc3VsdCA9ICcnO1xuXHR3aGlsZSAocG9zaXRpb24kMSA8IGVuZCkge1xuXHRcdGNvbnN0IGJ5dGUxID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0aWYgKChieXRlMSAmIDB4ODApID09PSAwKSB7XG5cdFx0XHQvLyAxIGJ5dGVcblx0XHRcdHVuaXRzLnB1c2goYnl0ZTEpO1xuXHRcdH0gZWxzZSBpZiAoKGJ5dGUxICYgMHhlMCkgPT09IDB4YzApIHtcblx0XHRcdC8vIDIgYnl0ZXNcblx0XHRcdGNvbnN0IGJ5dGUyID0gc3JjW3Bvc2l0aW9uJDErK10gJiAweDNmO1xuXHRcdFx0dW5pdHMucHVzaCgoKGJ5dGUxICYgMHgxZikgPDwgNikgfCBieXRlMik7XG5cdFx0fSBlbHNlIGlmICgoYnl0ZTEgJiAweGYwKSA9PT0gMHhlMCkge1xuXHRcdFx0Ly8gMyBieXRlc1xuXHRcdFx0Y29uc3QgYnl0ZTIgPSBzcmNbcG9zaXRpb24kMSsrXSAmIDB4M2Y7XG5cdFx0XHRjb25zdCBieXRlMyA9IHNyY1twb3NpdGlvbiQxKytdICYgMHgzZjtcblx0XHRcdHVuaXRzLnB1c2goKChieXRlMSAmIDB4MWYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzKTtcblx0XHR9IGVsc2UgaWYgKChieXRlMSAmIDB4ZjgpID09PSAweGYwKSB7XG5cdFx0XHQvLyA0IGJ5dGVzXG5cdFx0XHRjb25zdCBieXRlMiA9IHNyY1twb3NpdGlvbiQxKytdICYgMHgzZjtcblx0XHRcdGNvbnN0IGJ5dGUzID0gc3JjW3Bvc2l0aW9uJDErK10gJiAweDNmO1xuXHRcdFx0Y29uc3QgYnl0ZTQgPSBzcmNbcG9zaXRpb24kMSsrXSAmIDB4M2Y7XG5cdFx0XHRsZXQgdW5pdCA9ICgoYnl0ZTEgJiAweDA3KSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBjKSB8IChieXRlMyA8PCAweDA2KSB8IGJ5dGU0O1xuXHRcdFx0aWYgKHVuaXQgPiAweGZmZmYpIHtcblx0XHRcdFx0dW5pdCAtPSAweDEwMDAwO1xuXHRcdFx0XHR1bml0cy5wdXNoKCgodW5pdCA+Pj4gMTApICYgMHgzZmYpIHwgMHhkODAwKTtcblx0XHRcdFx0dW5pdCA9IDB4ZGMwMCB8ICh1bml0ICYgMHgzZmYpO1xuXHRcdFx0fVxuXHRcdFx0dW5pdHMucHVzaCh1bml0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dW5pdHMucHVzaChieXRlMSk7XG5cdFx0fVxuXG5cdFx0aWYgKHVuaXRzLmxlbmd0aCA+PSAweDEwMDApIHtcblx0XHRcdHJlc3VsdCArPSBmcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCB1bml0cyk7XG5cdFx0XHR1bml0cy5sZW5ndGggPSAwO1xuXHRcdH1cblx0fVxuXG5cdGlmICh1bml0cy5sZW5ndGggPiAwKSB7XG5cdFx0cmVzdWx0ICs9IGZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIHVuaXRzKTtcblx0fVxuXG5cdHJldHVybiByZXN1bHRcbn1cbmZ1bmN0aW9uIHJlYWRTdHJpbmcoc291cmNlLCBzdGFydCwgbGVuZ3RoKSB7XG5cdGxldCBleGlzdGluZ1NyYyA9IHNyYztcblx0c3JjID0gc291cmNlO1xuXHRwb3NpdGlvbiQxID0gc3RhcnQ7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHJlYWRTdHJpbmdKUyhsZW5ndGgpO1xuXHR9IGZpbmFsbHkge1xuXHRcdHNyYyA9IGV4aXN0aW5nU3JjO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHJlYWRBcnJheShsZW5ndGgpIHtcblx0bGV0IGFycmF5ID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRhcnJheVtpXSA9IHJlYWQoKTtcblx0fVxuXHRpZiAoY3VycmVudFVucGFja3IuZnJlZXplRGF0YSlcblx0XHRyZXR1cm4gT2JqZWN0LmZyZWV6ZShhcnJheSlcblx0cmV0dXJuIGFycmF5XG59XG5cbmZ1bmN0aW9uIHJlYWRNYXAobGVuZ3RoKSB7XG5cdGlmIChjdXJyZW50VW5wYWNrci5tYXBzQXNPYmplY3RzKSB7XG5cdFx0bGV0IG9iamVjdCA9IHt9O1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdGxldCBrZXkgPSByZWFkS2V5KCk7XG5cdFx0XHRpZiAoa2V5ID09PSAnX19wcm90b19fJylcblx0XHRcdFx0a2V5ID0gJ19fcHJvdG9fJztcblx0XHRcdG9iamVjdFtrZXldID0gcmVhZCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gb2JqZWN0XG5cdH0gZWxzZSB7XG5cdFx0bGV0IG1hcCA9IG5ldyBNYXAoKTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRtYXAuc2V0KHJlYWQoKSwgcmVhZCgpKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1hcFxuXHR9XG59XG5cbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuZnVuY3Rpb24gbG9uZ1N0cmluZ0luSlMobGVuZ3RoKSB7XG5cdGxldCBzdGFydCA9IHBvc2l0aW9uJDE7XG5cdGxldCBieXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuXHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3QgYnl0ZSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdGlmICgoYnl0ZSAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiQxID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0Ynl0ZXNbaV0gPSBieXRlO1xuXHRcdH1cblx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgYnl0ZXMpXG59XG5mdW5jdGlvbiBzaG9ydFN0cmluZ0luSlMobGVuZ3RoKSB7XG5cdGlmIChsZW5ndGggPCA0KSB7XG5cdFx0aWYgKGxlbmd0aCA8IDIpIHtcblx0XHRcdGlmIChsZW5ndGggPT09IDApXG5cdFx0XHRcdHJldHVybiAnJ1xuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGxldCBhID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdGlmICgoYSAmIDB4ODApID4gMSkge1xuXHRcdFx0XHRcdHBvc2l0aW9uJDEgLT0gMTtcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEpXG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBhID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRsZXQgYiA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0aWYgKChhICYgMHg4MCkgPiAwIHx8IChiICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdHBvc2l0aW9uJDEgLT0gMjtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgMylcblx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiKVxuXHRcdFx0bGV0IGMgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdGlmICgoYyAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiQxIC09IDM7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjKVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRsZXQgYSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdGxldCBiID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0bGV0IGMgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRsZXQgZCA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdGlmICgoYSAmIDB4ODApID4gMCB8fCAoYiAmIDB4ODApID4gMCB8fCAoYyAmIDB4ODApID4gMCB8fCAoZCAmIDB4ODApID4gMCkge1xuXHRcdFx0cG9zaXRpb24kMSAtPSA0O1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdGlmIChsZW5ndGggPCA2KSB7XG5cdFx0XHRpZiAobGVuZ3RoID09PSA0KVxuXHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQpXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0bGV0IGUgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0aWYgKChlICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24kMSAtPSA1O1xuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSlcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDgpIHtcblx0XHRcdGxldCBlID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRsZXQgZiA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0aWYgKChlICYgMHg4MCkgPiAwIHx8IChmICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdHBvc2l0aW9uJDEgLT0gNjtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgNylcblx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmKVxuXHRcdFx0bGV0IGcgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdGlmICgoZyAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRwb3NpdGlvbiQxIC09IDc7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRsZXQgZSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0bGV0IGYgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdGxldCBnID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRsZXQgaCA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0aWYgKChlICYgMHg4MCkgPiAwIHx8IChmICYgMHg4MCkgPiAwIHx8IChnICYgMHg4MCkgPiAwIHx8IChoICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdHBvc2l0aW9uJDEgLT0gODtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgMTApIHtcblx0XHRcdFx0aWYgKGxlbmd0aCA9PT0gOClcblx0XHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdGxldCBpID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdFx0aWYgKChpICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiQxIC09IDk7XG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpKVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDEyKSB7XG5cdFx0XHRcdGxldCBpID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdGxldCBqID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdGlmICgoaSAmIDB4ODApID4gMCB8fCAoaiAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdHBvc2l0aW9uJDEgLT0gMTA7XG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGxlbmd0aCA8IDExKVxuXHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgailcblx0XHRcdFx0bGV0IGsgPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0aWYgKChrICYgMHg4MCkgPiAwKSB7XG5cdFx0XHRcdFx0cG9zaXRpb24kMSAtPSAxMTtcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGspXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsZXQgaSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRsZXQgaiA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRsZXQgayA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRsZXQgbCA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRpZiAoKGkgJiAweDgwKSA+IDAgfHwgKGogJiAweDgwKSA+IDAgfHwgKGsgJiAweDgwKSA+IDAgfHwgKGwgJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRwb3NpdGlvbiQxIC09IDEyO1xuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsZW5ndGggPCAxNCkge1xuXHRcdFx0XHRcdGlmIChsZW5ndGggPT09IDEyKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsKVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0bGV0IG0gPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0XHRcdGlmICgobSAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiQxIC09IDEzO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiBmcm9tQ2hhckNvZGUoYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCwgbSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGV0IG0gPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0XHRsZXQgbiA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRcdFx0XHRcdGlmICgobSAmIDB4ODApID4gMCB8fCAobiAmIDB4ODApID4gMCkge1xuXHRcdFx0XHRcdFx0cG9zaXRpb24kMSAtPSAxNDtcblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobGVuZ3RoIDwgMTUpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZnJvbUNoYXJDb2RlKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGksIGosIGssIGwsIG0sIG4pXG5cdFx0XHRcdFx0bGV0IG8gPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0XHRcdFx0XHRpZiAoKG8gJiAweDgwKSA+IDApIHtcblx0XHRcdFx0XHRcdHBvc2l0aW9uJDEgLT0gMTU7XG5cdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZyb21DaGFyQ29kZShhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpLCBqLCBrLCBsLCBtLCBuLCBvKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJlYWRPbmx5SlNTdHJpbmcoKSB7XG5cdGxldCB0b2tlbiA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRsZXQgbGVuZ3RoO1xuXHRpZiAodG9rZW4gPCAweGMwKSB7XG5cdFx0Ly8gZml4c3RyXG5cdFx0bGVuZ3RoID0gdG9rZW4gLSAweGEwO1xuXHR9IGVsc2Uge1xuXHRcdHN3aXRjaCh0b2tlbikge1xuXHRcdFx0Y2FzZSAweGQ5OlxuXHRcdFx0Ly8gc3RyIDhcblx0XHRcdFx0bGVuZ3RoID0gc3JjW3Bvc2l0aW9uJDErK107XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDB4ZGE6XG5cdFx0XHQvLyBzdHIgMTZcblx0XHRcdFx0bGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDI7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDB4ZGI6XG5cdFx0XHQvLyBzdHIgMzJcblx0XHRcdFx0bGVuZ3RoID0gZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uJDEpO1xuXHRcdFx0XHRwb3NpdGlvbiQxICs9IDQ7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHN0cmluZycpXG5cdFx0fVxuXHR9XG5cdHJldHVybiByZWFkU3RyaW5nSlMobGVuZ3RoKVxufVxuXG5cbmZ1bmN0aW9uIHJlYWRCaW4obGVuZ3RoKSB7XG5cdHJldHVybiBjdXJyZW50VW5wYWNrci5jb3B5QnVmZmVycyA/XG5cdFx0Ly8gc3BlY2lmaWNhbGx5IHVzZSB0aGUgY29weWluZyBzbGljZSAobm90IHRoZSBub2RlIG9uZSlcblx0XHRVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHNyYywgcG9zaXRpb24kMSwgcG9zaXRpb24kMSArPSBsZW5ndGgpIDpcblx0XHRzcmMuc3ViYXJyYXkocG9zaXRpb24kMSwgcG9zaXRpb24kMSArPSBsZW5ndGgpXG59XG5mdW5jdGlvbiByZWFkRXh0KGxlbmd0aCkge1xuXHRsZXQgdHlwZSA9IHNyY1twb3NpdGlvbiQxKytdO1xuXHRpZiAoY3VycmVudEV4dGVuc2lvbnNbdHlwZV0pIHtcblx0XHRsZXQgZW5kO1xuXHRcdHJldHVybiBjdXJyZW50RXh0ZW5zaW9uc1t0eXBlXShzcmMuc3ViYXJyYXkocG9zaXRpb24kMSwgZW5kID0gKHBvc2l0aW9uJDEgKz0gbGVuZ3RoKSksIChyZWFkUG9zaXRpb24pID0+IHtcblx0XHRcdHBvc2l0aW9uJDEgPSByZWFkUG9zaXRpb247XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXR1cm4gcmVhZCgpO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0cG9zaXRpb24kMSA9IGVuZDtcblx0XHRcdH1cblx0XHR9KVxuXHR9XG5cdGVsc2Vcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZXh0ZW5zaW9uIHR5cGUgJyArIHR5cGUpXG59XG5cbnZhciBrZXlDYWNoZSA9IG5ldyBBcnJheSg0MDk2KTtcbmZ1bmN0aW9uIHJlYWRLZXkoKSB7XG5cdGxldCBsZW5ndGggPSBzcmNbcG9zaXRpb24kMSsrXTtcblx0aWYgKGxlbmd0aCA+PSAweGEwICYmIGxlbmd0aCA8IDB4YzApIHtcblx0XHQvLyBmaXhzdHIsIHBvdGVudGlhbGx5IHVzZSBrZXkgY2FjaGVcblx0XHRsZW5ndGggPSBsZW5ndGggLSAweGEwO1xuXHRcdGlmIChzcmNTdHJpbmdFbmQgPj0gcG9zaXRpb24kMSkgLy8gaWYgaXQgaGFzIGJlZW4gZXh0cmFjdGVkLCBtdXN0IHVzZSBpdCAoYW5kIGZhc3RlciBhbnl3YXkpXG5cdFx0XHRyZXR1cm4gc3JjU3RyaW5nLnNsaWNlKHBvc2l0aW9uJDEgLSBzcmNTdHJpbmdTdGFydCwgKHBvc2l0aW9uJDEgKz0gbGVuZ3RoKSAtIHNyY1N0cmluZ1N0YXJ0KVxuXHRcdGVsc2UgaWYgKCEoc3JjU3RyaW5nRW5kID09IDAgJiYgc3JjRW5kIDwgMTgwKSlcblx0XHRcdHJldHVybiByZWFkRml4ZWRTdHJpbmcobGVuZ3RoKVxuXHR9IGVsc2UgeyAvLyBub3QgY2FjaGVhYmxlLCBnbyBiYWNrIGFuZCBkbyBhIHN0YW5kYXJkIHJlYWRcblx0XHRwb3NpdGlvbiQxLS07XG5cdFx0cmV0dXJuIGFzU2FmZVN0cmluZyhyZWFkKCkpXG5cdH1cblx0bGV0IGtleSA9ICgobGVuZ3RoIDw8IDUpIF4gKGxlbmd0aCA+IDEgPyBkYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24kMSkgOiBsZW5ndGggPiAwID8gc3JjW3Bvc2l0aW9uJDFdIDogMCkpICYgMHhmZmY7XG5cdGxldCBlbnRyeSA9IGtleUNhY2hlW2tleV07XG5cdGxldCBjaGVja1Bvc2l0aW9uID0gcG9zaXRpb24kMTtcblx0bGV0IGVuZCA9IHBvc2l0aW9uJDEgKyBsZW5ndGggLSAzO1xuXHRsZXQgY2h1bms7XG5cdGxldCBpID0gMDtcblx0aWYgKGVudHJ5ICYmIGVudHJ5LmJ5dGVzID09IGxlbmd0aCkge1xuXHRcdHdoaWxlIChjaGVja1Bvc2l0aW9uIDwgZW5kKSB7XG5cdFx0XHRjaHVuayA9IGRhdGFWaWV3LmdldFVpbnQzMihjaGVja1Bvc2l0aW9uKTtcblx0XHRcdGlmIChjaHVuayAhPSBlbnRyeVtpKytdKSB7XG5cdFx0XHRcdGNoZWNrUG9zaXRpb24gPSAweDcwMDAwMDAwO1xuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdFx0Y2hlY2tQb3NpdGlvbiArPSA0O1xuXHRcdH1cblx0XHRlbmQgKz0gMztcblx0XHR3aGlsZSAoY2hlY2tQb3NpdGlvbiA8IGVuZCkge1xuXHRcdFx0Y2h1bmsgPSBzcmNbY2hlY2tQb3NpdGlvbisrXTtcblx0XHRcdGlmIChjaHVuayAhPSBlbnRyeVtpKytdKSB7XG5cdFx0XHRcdGNoZWNrUG9zaXRpb24gPSAweDcwMDAwMDAwO1xuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoY2hlY2tQb3NpdGlvbiA9PT0gZW5kKSB7XG5cdFx0XHRwb3NpdGlvbiQxID0gY2hlY2tQb3NpdGlvbjtcblx0XHRcdHJldHVybiBlbnRyeS5zdHJpbmdcblx0XHR9XG5cdFx0ZW5kIC09IDM7XG5cdFx0Y2hlY2tQb3NpdGlvbiA9IHBvc2l0aW9uJDE7XG5cdH1cblx0ZW50cnkgPSBbXTtcblx0a2V5Q2FjaGVba2V5XSA9IGVudHJ5O1xuXHRlbnRyeS5ieXRlcyA9IGxlbmd0aDtcblx0d2hpbGUgKGNoZWNrUG9zaXRpb24gPCBlbmQpIHtcblx0XHRjaHVuayA9IGRhdGFWaWV3LmdldFVpbnQzMihjaGVja1Bvc2l0aW9uKTtcblx0XHRlbnRyeS5wdXNoKGNodW5rKTtcblx0XHRjaGVja1Bvc2l0aW9uICs9IDQ7XG5cdH1cblx0ZW5kICs9IDM7XG5cdHdoaWxlIChjaGVja1Bvc2l0aW9uIDwgZW5kKSB7XG5cdFx0Y2h1bmsgPSBzcmNbY2hlY2tQb3NpdGlvbisrXTtcblx0XHRlbnRyeS5wdXNoKGNodW5rKTtcblx0fVxuXHQvLyBmb3Igc21hbGwgYmxvY2tzLCBhdm9pZGluZyB0aGUgb3ZlcmhlYWQgb2YgdGhlIGV4dHJhY3QgY2FsbCBpcyBoZWxwZnVsXG5cdGxldCBzdHJpbmcgPSBsZW5ndGggPCAxNiA/IHNob3J0U3RyaW5nSW5KUyhsZW5ndGgpIDogbG9uZ1N0cmluZ0luSlMobGVuZ3RoKTtcblx0aWYgKHN0cmluZyAhPSBudWxsKVxuXHRcdHJldHVybiBlbnRyeS5zdHJpbmcgPSBzdHJpbmdcblx0cmV0dXJuIGVudHJ5LnN0cmluZyA9IHJlYWRGaXhlZFN0cmluZyhsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzU2FmZVN0cmluZyhwcm9wZXJ0eSkge1xuXHQvLyBwcm90ZWN0IGFnYWluc3QgZXhwZW5zaXZlIChEb1MpIHN0cmluZyBjb252ZXJzaW9uc1xuXHRpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnc3RyaW5nJykgcmV0dXJuIHByb3BlcnR5O1xuXHRpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgcHJvcGVydHkgPT09ICdib29sZWFuJyB8fCB0eXBlb2YgcHJvcGVydHkgPT09ICdiaWdpbnQnKSByZXR1cm4gcHJvcGVydHkudG9TdHJpbmcoKTtcblx0aWYgKHByb3BlcnR5ID09IG51bGwpIHJldHVybiBwcm9wZXJ0eSArICcnO1xuXHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJvcGVydHkgdHlwZSBmb3IgcmVjb3JkJywgdHlwZW9mIHByb3BlcnR5KTtcbn1cbi8vIHRoZSByZWdpc3RyYXRpb24gb2YgdGhlIHJlY29yZCBkZWZpbml0aW9uIGV4dGVuc2lvbiAoYXMgXCJyXCIpXG5jb25zdCByZWNvcmREZWZpbml0aW9uID0gKGlkLCBoaWdoQnl0ZSkgPT4ge1xuXHRsZXQgc3RydWN0dXJlID0gcmVhZCgpLm1hcChhc1NhZmVTdHJpbmcpOyAvLyBlbnN1cmUgdGhhdCBhbGwga2V5cyBhcmUgc3RyaW5ncyBhbmRcblx0Ly8gdGhhdCB0aGUgYXJyYXkgaXMgbXV0YWJsZVxuXHRsZXQgZmlyc3RCeXRlID0gaWQ7XG5cdGlmIChoaWdoQnl0ZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aWQgPSBpZCA8IDMyID8gLSgoaGlnaEJ5dGUgPDwgNSkgKyBpZCkgOiAoKGhpZ2hCeXRlIDw8IDUpICsgaWQpO1xuXHRcdHN0cnVjdHVyZS5oaWdoQnl0ZSA9IGhpZ2hCeXRlO1xuXHR9XG5cdGxldCBleGlzdGluZ1N0cnVjdHVyZSA9IGN1cnJlbnRTdHJ1Y3R1cmVzW2lkXTtcblx0Ly8gSWYgaXQgaXMgYSBzaGFyZWQgc3RydWN0dXJlLCB3ZSBuZWVkIHRvIHJlc3RvcmUgYW55IGNoYW5nZXMgYWZ0ZXIgcmVhZGluZy5cblx0Ly8gQWxzbyBpbiBzZXF1ZW50aWFsIG1vZGUsIHdlIG1heSBnZXQgaW5jb21wbGV0ZSByZWFkcyBhbmQgdGh1cyBlcnJvcnMsIGFuZCB3ZSBuZWVkIHRvIHJlc3RvcmVcblx0Ly8gdG8gdGhlIHN0YXRlIHByaW9yIHRvIGFuIGluY29tcGxldGUgcmVhZCBpbiBvcmRlciB0byBwcm9wZXJseSByZXN1bWUuXG5cdGlmIChleGlzdGluZ1N0cnVjdHVyZSAmJiAoZXhpc3RpbmdTdHJ1Y3R1cmUuaXNTaGFyZWQgfHwgc2VxdWVudGlhbE1vZGUpKSB7XG5cdFx0KGN1cnJlbnRTdHJ1Y3R1cmVzLnJlc3RvcmVTdHJ1Y3R1cmVzIHx8IChjdXJyZW50U3RydWN0dXJlcy5yZXN0b3JlU3RydWN0dXJlcyA9IFtdKSlbaWRdID0gZXhpc3RpbmdTdHJ1Y3R1cmU7XG5cdH1cblx0Y3VycmVudFN0cnVjdHVyZXNbaWRdID0gc3RydWN0dXJlO1xuXHRzdHJ1Y3R1cmUucmVhZCA9IGNyZWF0ZVN0cnVjdHVyZVJlYWRlcihzdHJ1Y3R1cmUsIGZpcnN0Qnl0ZSk7XG5cdHJldHVybiBzdHJ1Y3R1cmUucmVhZCgpXG59O1xuY3VycmVudEV4dGVuc2lvbnNbMF0gPSAoKSA9PiB7fTsgLy8gbm90ZXBhY2sgZGVmaW5lcyBleHRlbnNpb24gMCB0byBtZWFuIHVuZGVmaW5lZCwgc28gdXNlIHRoYXQgYXMgdGhlIGRlZmF1bHQgaGVyZVxuY3VycmVudEV4dGVuc2lvbnNbMF0ubm9CdWZmZXIgPSB0cnVlO1xuXG5jdXJyZW50RXh0ZW5zaW9uc1sweDQyXSA9IChkYXRhKSA9PiB7XG5cdC8vIGRlY29kZSBiaWdpbnRcblx0bGV0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuXHRsZXQgdmFsdWUgPSBCaWdJbnQoZGF0YVswXSAmIDB4ODAgPyBkYXRhWzBdIC0gMHgxMDAgOiBkYXRhWzBdKTtcblx0Zm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdHZhbHVlIDw8PSBCaWdJbnQoOCk7XG5cdFx0dmFsdWUgKz0gQmlnSW50KGRhdGFbaV0pO1xuXHR9XG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbmxldCBlcnJvcnMgPSB7IEVycm9yLCBUeXBlRXJyb3IsIFJlZmVyZW5jZUVycm9yIH07XG5jdXJyZW50RXh0ZW5zaW9uc1sweDY1XSA9ICgpID0+IHtcblx0bGV0IGRhdGEgPSByZWFkKCk7XG5cdHJldHVybiAoZXJyb3JzW2RhdGFbMF1dIHx8IEVycm9yKShkYXRhWzFdLCB7IGNhdXNlOiBkYXRhWzJdIH0pXG59O1xuXG5jdXJyZW50RXh0ZW5zaW9uc1sweDY5XSA9IChkYXRhKSA9PiB7XG5cdC8vIGlkIGV4dGVuc2lvbiAoZm9yIHN0cnVjdHVyZWQgY2xvbmVzKVxuXHRpZiAoY3VycmVudFVucGFja3Iuc3RydWN0dXJlZENsb25lID09PSBmYWxzZSkgdGhyb3cgbmV3IEVycm9yKCdTdHJ1Y3R1cmVkIGNsb25lIGV4dGVuc2lvbiBpcyBkaXNhYmxlZCcpXG5cdGxldCBpZCA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbiQxIC0gNCk7XG5cdGlmICghcmVmZXJlbmNlTWFwKVxuXHRcdHJlZmVyZW5jZU1hcCA9IG5ldyBNYXAoKTtcblx0bGV0IHRva2VuID0gc3JjW3Bvc2l0aW9uJDFdO1xuXHRsZXQgdGFyZ2V0O1xuXHQvLyBUT0RPOiBoYW5kbGUgTWFwcywgU2V0cywgYW5kIG90aGVyIHR5cGVzIHRoYXQgY2FuIGN5Y2xlOyB0aGlzIGlzIGNvbXBsaWNhdGVkLCBiZWNhdXNlIHlvdSBwb3RlbnRpYWxseSBuZWVkIHRvIHJlYWRcblx0Ly8gYWhlYWQgcGFzdCByZWZlcmVuY2VzIHRvIHJlY29yZCBzdHJ1Y3R1cmUgZGVmaW5pdGlvbnNcblx0aWYgKHRva2VuID49IDB4OTAgJiYgdG9rZW4gPCAweGEwIHx8IHRva2VuID09IDB4ZGMgfHwgdG9rZW4gPT0gMHhkZClcblx0XHR0YXJnZXQgPSBbXTtcblx0ZWxzZVxuXHRcdHRhcmdldCA9IHt9O1xuXG5cdGxldCByZWZFbnRyeSA9IHsgdGFyZ2V0IH07IC8vIGEgcGxhY2Vob2xkZXIgb2JqZWN0XG5cdHJlZmVyZW5jZU1hcC5zZXQoaWQsIHJlZkVudHJ5KTtcblx0bGV0IHRhcmdldFByb3BlcnRpZXMgPSByZWFkKCk7IC8vIHJlYWQgdGhlIG5leHQgdmFsdWUgYXMgdGhlIHRhcmdldCBvYmplY3QgdG8gaWRcblx0aWYgKHJlZkVudHJ5LnVzZWQpIC8vIHRoZXJlIGlzIGEgY3ljbGUsIHNvIHdlIGhhdmUgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8gb3JpZ2luYWwgdGFyZ2V0XG5cdFx0cmV0dXJuIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB0YXJnZXRQcm9wZXJ0aWVzKVxuXHRyZWZFbnRyeS50YXJnZXQgPSB0YXJnZXRQcm9wZXJ0aWVzOyAvLyB0aGUgcGxhY2Vob2xkZXIgd2Fzbid0IHVzZWQsIHJlcGxhY2Ugd2l0aCB0aGUgZGVzZXJpYWxpemVkIG9uZVxuXHRyZXR1cm4gdGFyZ2V0UHJvcGVydGllcyAvLyBubyBjeWNsZSwgY2FuIGp1c3QgdXNlIHRoZSByZXR1cm5lZCByZWFkIG9iamVjdFxufTtcblxuY3VycmVudEV4dGVuc2lvbnNbMHg3MF0gPSAoZGF0YSkgPT4ge1xuXHQvLyBwb2ludGVyIGV4dGVuc2lvbiAoZm9yIHN0cnVjdHVyZWQgY2xvbmVzKVxuXHRpZiAoY3VycmVudFVucGFja3Iuc3RydWN0dXJlZENsb25lID09PSBmYWxzZSkgdGhyb3cgbmV3IEVycm9yKCdTdHJ1Y3R1cmVkIGNsb25lIGV4dGVuc2lvbiBpcyBkaXNhYmxlZCcpXG5cdGxldCBpZCA9IGRhdGFWaWV3LmdldFVpbnQzMihwb3NpdGlvbiQxIC0gNCk7XG5cdGxldCByZWZFbnRyeSA9IHJlZmVyZW5jZU1hcC5nZXQoaWQpO1xuXHRyZWZFbnRyeS51c2VkID0gdHJ1ZTtcblx0cmV0dXJuIHJlZkVudHJ5LnRhcmdldFxufTtcblxuY3VycmVudEV4dGVuc2lvbnNbMHg3M10gPSAoKSA9PiBuZXcgU2V0KHJlYWQoKSk7XG5cbmNvbnN0IHR5cGVkQXJyYXlzID0gWydJbnQ4JywnVWludDgnLCdVaW50OENsYW1wZWQnLCdJbnQxNicsJ1VpbnQxNicsJ0ludDMyJywnVWludDMyJywnRmxvYXQzMicsJ0Zsb2F0NjQnLCdCaWdJbnQ2NCcsJ0JpZ1VpbnQ2NCddLm1hcCh0eXBlID0+IHR5cGUgKyAnQXJyYXknKTtcblxubGV0IGdsYmwgPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgPyBnbG9iYWxUaGlzIDogd2luZG93O1xuY3VycmVudEV4dGVuc2lvbnNbMHg3NF0gPSAoZGF0YSkgPT4ge1xuXHRsZXQgdHlwZUNvZGUgPSBkYXRhWzBdO1xuXHRsZXQgdHlwZWRBcnJheU5hbWUgPSB0eXBlZEFycmF5c1t0eXBlQ29kZV07XG5cdGlmICghdHlwZWRBcnJheU5hbWUpIHtcblx0XHRpZiAodHlwZUNvZGUgPT09IDE2KSB7XG5cdFx0XHRsZXQgYWIgPSBuZXcgQXJyYXlCdWZmZXIoZGF0YS5sZW5ndGggLSAxKTtcblx0XHRcdGxldCB1OCA9IG5ldyBVaW50OEFycmF5KGFiKTtcblx0XHRcdHU4LnNldChkYXRhLnN1YmFycmF5KDEpKTtcblx0XHRcdHJldHVybiBhYjtcblx0XHR9XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCB0eXBlZCBhcnJheSBmb3IgY29kZSAnICsgdHlwZUNvZGUpXG5cdH1cblx0Ly8gd2UgaGF2ZSB0byBhbHdheXMgc2xpY2UvY29weSBoZXJlIHRvIGdldCBhIG5ldyBBcnJheUJ1ZmZlciB0aGF0IGlzIHdvcmQvYnl0ZSBhbGlnbmVkXG5cdHJldHVybiBuZXcgZ2xibFt0eXBlZEFycmF5TmFtZV0oVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkYXRhLCAxKS5idWZmZXIpXG59O1xuY3VycmVudEV4dGVuc2lvbnNbMHg3OF0gPSAoKSA9PiB7XG5cdGxldCBkYXRhID0gcmVhZCgpO1xuXHRyZXR1cm4gbmV3IFJlZ0V4cChkYXRhWzBdLCBkYXRhWzFdKVxufTtcbmNvbnN0IFRFTVBfQlVORExFID0gW107XG5jdXJyZW50RXh0ZW5zaW9uc1sweDYyXSA9IChkYXRhKSA9PiB7XG5cdGxldCBkYXRhU2l6ZSA9IChkYXRhWzBdIDw8IDI0KSArIChkYXRhWzFdIDw8IDE2KSArIChkYXRhWzJdIDw8IDgpICsgZGF0YVszXTtcblx0bGV0IGRhdGFQb3NpdGlvbiA9IHBvc2l0aW9uJDE7XG5cdHBvc2l0aW9uJDEgKz0gZGF0YVNpemUgLSBkYXRhLmxlbmd0aDtcblx0YnVuZGxlZFN0cmluZ3MkMSA9IFRFTVBfQlVORExFO1xuXHRidW5kbGVkU3RyaW5ncyQxID0gW3JlYWRPbmx5SlNTdHJpbmcoKSwgcmVhZE9ubHlKU1N0cmluZygpXTtcblx0YnVuZGxlZFN0cmluZ3MkMS5wb3NpdGlvbjAgPSAwO1xuXHRidW5kbGVkU3RyaW5ncyQxLnBvc2l0aW9uMSA9IDA7XG5cdGJ1bmRsZWRTdHJpbmdzJDEucG9zdEJ1bmRsZVBvc2l0aW9uID0gcG9zaXRpb24kMTtcblx0cG9zaXRpb24kMSA9IGRhdGFQb3NpdGlvbjtcblx0cmV0dXJuIHJlYWQoKVxufTtcblxuY3VycmVudEV4dGVuc2lvbnNbMHhmZl0gPSAoZGF0YSkgPT4ge1xuXHQvLyAzMi1iaXQgZGF0ZSBleHRlbnNpb25cblx0aWYgKGRhdGEubGVuZ3RoID09IDQpXG5cdFx0cmV0dXJuIG5ldyBEYXRlKChkYXRhWzBdICogMHgxMDAwMDAwICsgKGRhdGFbMV0gPDwgMTYpICsgKGRhdGFbMl0gPDwgOCkgKyBkYXRhWzNdKSAqIDEwMDApXG5cdGVsc2UgaWYgKGRhdGEubGVuZ3RoID09IDgpXG5cdFx0cmV0dXJuIG5ldyBEYXRlKFxuXHRcdFx0KChkYXRhWzBdIDw8IDIyKSArIChkYXRhWzFdIDw8IDE0KSArIChkYXRhWzJdIDw8IDYpICsgKGRhdGFbM10gPj4gMikpIC8gMTAwMDAwMCArXG5cdFx0XHQoKGRhdGFbM10gJiAweDMpICogMHgxMDAwMDAwMDAgKyBkYXRhWzRdICogMHgxMDAwMDAwICsgKGRhdGFbNV0gPDwgMTYpICsgKGRhdGFbNl0gPDwgOCkgKyBkYXRhWzddKSAqIDEwMDApXG5cdGVsc2UgaWYgKGRhdGEubGVuZ3RoID09IDEyKS8vIFRPRE86IEltcGxlbWVudCBzdXBwb3J0IGZvciBuZWdhdGl2ZVxuXHRcdHJldHVybiBuZXcgRGF0ZShcblx0XHRcdCgoZGF0YVswXSA8PCAyNCkgKyAoZGF0YVsxXSA8PCAxNikgKyAoZGF0YVsyXSA8PCA4KSArIGRhdGFbM10pIC8gMTAwMDAwMCArXG5cdFx0XHQoKChkYXRhWzRdICYgMHg4MCkgPyAtMHgxMDAwMDAwMDAwMDAwIDogMCkgKyBkYXRhWzZdICogMHgxMDAwMDAwMDAwMCArIGRhdGFbN10gKiAweDEwMDAwMDAwMCArIGRhdGFbOF0gKiAweDEwMDAwMDAgKyAoZGF0YVs5XSA8PCAxNikgKyAoZGF0YVsxMF0gPDwgOCkgKyBkYXRhWzExXSkgKiAxMDAwKVxuXHRlbHNlXG5cdFx0cmV0dXJuIG5ldyBEYXRlKCdpbnZhbGlkJylcbn07IC8vIG5vdGVwYWNrIGRlZmluZXMgZXh0ZW5zaW9uIDAgdG8gbWVhbiB1bmRlZmluZWQsIHNvIHVzZSB0aGF0IGFzIHRoZSBkZWZhdWx0IGhlcmVcbi8vIHJlZ2lzdHJhdGlvbiBvZiBidWxrIHJlY29yZCBkZWZpbml0aW9uP1xuLy8gY3VycmVudEV4dGVuc2lvbnNbMHg1Ml0gPSAoKSA9PlxuXG5mdW5jdGlvbiBzYXZlU3RhdGUkMShjYWxsYmFjaykge1xuXHRpZiAob25TYXZlU3RhdGUpXG5cdFx0b25TYXZlU3RhdGUoKTtcblx0bGV0IHNhdmVkU3JjRW5kID0gc3JjRW5kO1xuXHRsZXQgc2F2ZWRQb3NpdGlvbiA9IHBvc2l0aW9uJDE7XG5cdGxldCBzYXZlZFN0cmluZ1Bvc2l0aW9uID0gc3RyaW5nUG9zaXRpb247XG5cdGxldCBzYXZlZFNyY1N0cmluZ1N0YXJ0ID0gc3JjU3RyaW5nU3RhcnQ7XG5cdGxldCBzYXZlZFNyY1N0cmluZ0VuZCA9IHNyY1N0cmluZ0VuZDtcblx0bGV0IHNhdmVkU3JjU3RyaW5nID0gc3JjU3RyaW5nO1xuXHRsZXQgc2F2ZWRTdHJpbmdzID0gc3RyaW5ncztcblx0bGV0IHNhdmVkUmVmZXJlbmNlTWFwID0gcmVmZXJlbmNlTWFwO1xuXHRsZXQgc2F2ZWRCdW5kbGVkU3RyaW5ncyA9IGJ1bmRsZWRTdHJpbmdzJDE7XG5cblx0Ly8gVE9ETzogV2UgbWF5IG5lZWQgdG8gcmV2aXNpdCB0aGlzIGlmIHdlIGRvIG1vcmUgZXh0ZXJuYWwgY2FsbHMgdG8gdXNlciBjb2RlIChzaW5jZSBpdCBjb3VsZCBiZSBzbG93KVxuXHRsZXQgc2F2ZWRTcmMgPSBuZXcgVWludDhBcnJheShzcmMuc2xpY2UoMCwgc3JjRW5kKSk7IC8vIHdlIGNvcHkgdGhlIGRhdGEgaW4gY2FzZSBpdCBjaGFuZ2VzIHdoaWxlIGV4dGVybmFsIGRhdGEgaXMgcHJvY2Vzc2VkXG5cdGxldCBzYXZlZFN0cnVjdHVyZXMgPSBjdXJyZW50U3RydWN0dXJlcztcblx0bGV0IHNhdmVkU3RydWN0dXJlc0NvbnRlbnRzID0gY3VycmVudFN0cnVjdHVyZXMuc2xpY2UoMCwgY3VycmVudFN0cnVjdHVyZXMubGVuZ3RoKTtcblx0bGV0IHNhdmVkUGFja3IgPSBjdXJyZW50VW5wYWNrcjtcblx0bGV0IHNhdmVkU2VxdWVudGlhbE1vZGUgPSBzZXF1ZW50aWFsTW9kZTtcblx0bGV0IHZhbHVlID0gY2FsbGJhY2soKTtcblx0c3JjRW5kID0gc2F2ZWRTcmNFbmQ7XG5cdHBvc2l0aW9uJDEgPSBzYXZlZFBvc2l0aW9uO1xuXHRzdHJpbmdQb3NpdGlvbiA9IHNhdmVkU3RyaW5nUG9zaXRpb247XG5cdHNyY1N0cmluZ1N0YXJ0ID0gc2F2ZWRTcmNTdHJpbmdTdGFydDtcblx0c3JjU3RyaW5nRW5kID0gc2F2ZWRTcmNTdHJpbmdFbmQ7XG5cdHNyY1N0cmluZyA9IHNhdmVkU3JjU3RyaW5nO1xuXHRzdHJpbmdzID0gc2F2ZWRTdHJpbmdzO1xuXHRyZWZlcmVuY2VNYXAgPSBzYXZlZFJlZmVyZW5jZU1hcDtcblx0YnVuZGxlZFN0cmluZ3MkMSA9IHNhdmVkQnVuZGxlZFN0cmluZ3M7XG5cdHNyYyA9IHNhdmVkU3JjO1xuXHRzZXF1ZW50aWFsTW9kZSA9IHNhdmVkU2VxdWVudGlhbE1vZGU7XG5cdGN1cnJlbnRTdHJ1Y3R1cmVzID0gc2F2ZWRTdHJ1Y3R1cmVzO1xuXHRjdXJyZW50U3RydWN0dXJlcy5zcGxpY2UoMCwgY3VycmVudFN0cnVjdHVyZXMubGVuZ3RoLCAuLi5zYXZlZFN0cnVjdHVyZXNDb250ZW50cyk7XG5cdGN1cnJlbnRVbnBhY2tyID0gc2F2ZWRQYWNrcjtcblx0ZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQsIHNyYy5ieXRlTGVuZ3RoKTtcblx0cmV0dXJuIHZhbHVlXG59XG5mdW5jdGlvbiBjbGVhclNvdXJjZSgpIHtcblx0c3JjID0gbnVsbDtcblx0cmVmZXJlbmNlTWFwID0gbnVsbDtcblx0Y3VycmVudFN0cnVjdHVyZXMgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZGRFeHRlbnNpb24kMShleHRlbnNpb24pIHtcblx0aWYgKGV4dGVuc2lvbi51bnBhY2spXG5cdFx0Y3VycmVudEV4dGVuc2lvbnNbZXh0ZW5zaW9uLnR5cGVdID0gZXh0ZW5zaW9uLnVucGFjaztcblx0ZWxzZVxuXHRcdGN1cnJlbnRFeHRlbnNpb25zW2V4dGVuc2lvbi50eXBlXSA9IGV4dGVuc2lvbjtcbn1cblxuY29uc3QgbXVsdDEwID0gbmV3IEFycmF5KDE0Nyk7IC8vIHRoaXMgaXMgYSB0YWJsZSBtYXRjaGluZyBiaW5hcnkgZXhwb25lbnRzIHRvIHRoZSBtdWx0aXBsaWVyIHRvIGRldGVybWluZSBzaWduaWZpY2FudCBkaWdpdCByb3VuZGluZ1xuZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuXHRtdWx0MTBbaV0gPSArKCcxZScgKyBNYXRoLmZsb29yKDQ1LjE1IC0gaSAqIDAuMzAxMDMpKTtcbn1cbmNvbnN0IERlY29kZXIgPSBVbnBhY2tyO1xudmFyIGRlZmF1bHRVbnBhY2tyID0gbmV3IFVucGFja3IoeyB1c2VSZWNvcmRzOiBmYWxzZSB9KTtcbmNvbnN0IHVucGFjayA9IGRlZmF1bHRVbnBhY2tyLnVucGFjaztcbmNvbnN0IHVucGFja011bHRpcGxlID0gZGVmYXVsdFVucGFja3IudW5wYWNrTXVsdGlwbGU7XG5jb25zdCBkZWNvZGUgPSBkZWZhdWx0VW5wYWNrci51bnBhY2s7XG5jb25zdCBGTE9BVDMyX09QVElPTlMgPSB7XG5cdE5FVkVSOiAwLFxuXHRBTFdBWVM6IDEsXG5cdERFQ0lNQUxfUk9VTkQ6IDMsXG5cdERFQ0lNQUxfRklUOiA0XG59O1xubGV0IGYzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgxKTtcbmxldCB1OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZjMyQXJyYXkuYnVmZmVyLCAwLCA0KTtcbmZ1bmN0aW9uIHJvdW5kRmxvYXQzMihmbG9hdDMyTnVtYmVyKSB7XG5cdGYzMkFycmF5WzBdID0gZmxvYXQzMk51bWJlcjtcblx0bGV0IG11bHRpcGxpZXIgPSBtdWx0MTBbKCh1OEFycmF5WzNdICYgMHg3ZikgPDwgMSkgfCAodThBcnJheVsyXSA+PiA3KV07XG5cdHJldHVybiAoKG11bHRpcGxpZXIgKiBmbG9hdDMyTnVtYmVyICsgKGZsb2F0MzJOdW1iZXIgPiAwID8gMC41IDogLTAuNSkpID4+IDApIC8gbXVsdGlwbGllclxufVxuZnVuY3Rpb24gc2V0UmVhZFN0cnVjdCh1cGRhdGVkUmVhZFN0cnVjdCwgbG9hZGVkU3RydWN0cywgc2F2ZVN0YXRlKSB7XG5cdHJlYWRTdHJ1Y3QkMSA9IHVwZGF0ZWRSZWFkU3RydWN0O1xuXHRvbkxvYWRlZFN0cnVjdHVyZXMkMSA9IGxvYWRlZFN0cnVjdHM7XG5cdG9uU2F2ZVN0YXRlID0gc2F2ZVN0YXRlO1xufVxuXG5sZXQgdGV4dEVuY29kZXIkMTtcbnRyeSB7XG5cdHRleHRFbmNvZGVyJDEgPSBuZXcgVGV4dEVuY29kZXIoKTtcbn0gY2F0Y2ggKGVycm9yKSB7fVxubGV0IGV4dGVuc2lvbnMsIGV4dGVuc2lvbkNsYXNzZXM7XG5jb25zdCBoYXNOb2RlQnVmZmVyJDEgPSB0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IEJ5dGVBcnJheUFsbG9jYXRlID0gaGFzTm9kZUJ1ZmZlciQxID9cblx0ZnVuY3Rpb24obGVuZ3RoKSB7IHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KGxlbmd0aCkgfSA6IFVpbnQ4QXJyYXk7XG5jb25zdCBCeXRlQXJyYXkgPSBoYXNOb2RlQnVmZmVyJDEgPyBCdWZmZXIgOiBVaW50OEFycmF5O1xuY29uc3QgTUFYX0JVRkZFUl9TSVpFID0gaGFzTm9kZUJ1ZmZlciQxID8gMHgxMDAwMDAwMDAgOiAweDdmZDAwMDAwO1xubGV0IHRhcmdldCwga2V5c1RhcmdldDtcbmxldCB0YXJnZXRWaWV3O1xubGV0IHBvc2l0aW9uID0gMDtcbmxldCBzYWZlRW5kO1xubGV0IGJ1bmRsZWRTdHJpbmdzID0gbnVsbDtcbmxldCB3cml0ZVN0cnVjdFNsb3RzO1xuY29uc3QgTUFYX0JVTkRMRV9TSVpFID0gMHg1NTAwOyAvLyBtYXhpbXVtIGNoYXJhY3RlcnMgc3VjaCB0aGF0IHRoZSBlbmNvZGVkIGJ5dGVzIGZpdHMgaW4gMTYgYml0cy5cbmNvbnN0IGhhc05vbkxhdGluID0gL1tcXHUwMDgwLVxcdUZGRkZdLztcbmNvbnN0IFJFQ09SRF9TWU1CT0wgPSBTeW1ib2woJ3JlY29yZC1pZCcpO1xuY2xhc3MgUGFja3IgZXh0ZW5kcyBVbnBhY2tyIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdHN1cGVyKG9wdGlvbnMpO1xuXHRcdHRoaXMub2Zmc2V0ID0gMDtcblx0XHRsZXQgc3RhcnQ7XG5cdFx0bGV0IGhhc1NoYXJlZFVwZGF0ZTtcblx0XHRsZXQgc3RydWN0dXJlcztcblx0XHRsZXQgcmVmZXJlbmNlTWFwO1xuXHRcdGxldCBlbmNvZGVVdGY4ID0gQnl0ZUFycmF5LnByb3RvdHlwZS51dGY4V3JpdGUgPyBmdW5jdGlvbihzdHJpbmcsIHBvc2l0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0LnV0ZjhXcml0ZShzdHJpbmcsIHBvc2l0aW9uLCB0YXJnZXQuYnl0ZUxlbmd0aCAtIHBvc2l0aW9uKVxuXHRcdH0gOiAodGV4dEVuY29kZXIkMSAmJiB0ZXh0RW5jb2RlciQxLmVuY29kZUludG8pID9cblx0XHRcdGZ1bmN0aW9uKHN0cmluZywgcG9zaXRpb24pIHtcblx0XHRcdFx0cmV0dXJuIHRleHRFbmNvZGVyJDEuZW5jb2RlSW50byhzdHJpbmcsIHRhcmdldC5zdWJhcnJheShwb3NpdGlvbikpLndyaXR0ZW5cblx0XHRcdH0gOiBmYWxzZTtcblxuXHRcdGxldCBwYWNrciA9IHRoaXM7XG5cdFx0aWYgKCFvcHRpb25zKVxuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdGxldCBpc1NlcXVlbnRpYWwgPSBvcHRpb25zICYmIG9wdGlvbnMuc2VxdWVudGlhbDtcblx0XHRsZXQgaGFzU2hhcmVkU3RydWN0dXJlcyA9IG9wdGlvbnMuc3RydWN0dXJlcyB8fCBvcHRpb25zLnNhdmVTdHJ1Y3R1cmVzO1xuXHRcdGxldCBtYXhTaGFyZWRTdHJ1Y3R1cmVzID0gb3B0aW9ucy5tYXhTaGFyZWRTdHJ1Y3R1cmVzO1xuXHRcdGlmIChtYXhTaGFyZWRTdHJ1Y3R1cmVzID09IG51bGwpXG5cdFx0XHRtYXhTaGFyZWRTdHJ1Y3R1cmVzID0gaGFzU2hhcmVkU3RydWN0dXJlcyA/IDMyIDogMDtcblx0XHRpZiAobWF4U2hhcmVkU3RydWN0dXJlcyA+IDgxNjApXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01heGltdW0gbWF4U2hhcmVkU3RydWN0dXJlIGlzIDgxNjAnKVxuXHRcdGlmIChvcHRpb25zLnN0cnVjdHVyZWRDbG9uZSAmJiBvcHRpb25zLm1vcmVUeXBlcyA9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMubW9yZVR5cGVzID0gdHJ1ZTtcblx0XHR9XG5cdFx0bGV0IG1heE93blN0cnVjdHVyZXMgPSBvcHRpb25zLm1heE93blN0cnVjdHVyZXM7XG5cdFx0aWYgKG1heE93blN0cnVjdHVyZXMgPT0gbnVsbClcblx0XHRcdG1heE93blN0cnVjdHVyZXMgPSBoYXNTaGFyZWRTdHJ1Y3R1cmVzID8gMzIgOiA2NDtcblx0XHRpZiAoIXRoaXMuc3RydWN0dXJlcyAmJiBvcHRpb25zLnVzZVJlY29yZHMgIT0gZmFsc2UpXG5cdFx0XHR0aGlzLnN0cnVjdHVyZXMgPSBbXTtcblx0XHQvLyB0d28gYnl0ZSByZWNvcmQgaWRzIGZvciBzaGFyZWQgc3RydWN0dXJlc1xuXHRcdGxldCB1c2VUd29CeXRlUmVjb3JkcyA9IG1heFNoYXJlZFN0cnVjdHVyZXMgPiAzMiB8fCAobWF4T3duU3RydWN0dXJlcyArIG1heFNoYXJlZFN0cnVjdHVyZXMgPiA2NCk7XG5cdFx0bGV0IHNoYXJlZExpbWl0SWQgPSBtYXhTaGFyZWRTdHJ1Y3R1cmVzICsgMHg0MDtcblx0XHRsZXQgbWF4U3RydWN0dXJlSWQgPSBtYXhTaGFyZWRTdHJ1Y3R1cmVzICsgbWF4T3duU3RydWN0dXJlcyArIDB4NDA7XG5cdFx0aWYgKG1heFN0cnVjdHVyZUlkID4gODI1Nikge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXhpbXVtIG1heFNoYXJlZFN0cnVjdHVyZSArIG1heE93blN0cnVjdHVyZSBpcyA4MTkyJylcblx0XHR9XG5cdFx0bGV0IHJlY29yZElkc1RvUmVtb3ZlID0gW107XG5cdFx0bGV0IHRyYW5zaXRpb25zQ291bnQgPSAwO1xuXHRcdGxldCBzZXJpYWxpemF0aW9uc1NpbmNlVHJhbnNpdGlvblJlYnVpbGQgPSAwO1xuXG5cdFx0dGhpcy5wYWNrID0gdGhpcy5lbmNvZGUgPSBmdW5jdGlvbih2YWx1ZSwgZW5jb2RlT3B0aW9ucykge1xuXHRcdFx0aWYgKCF0YXJnZXQpIHtcblx0XHRcdFx0dGFyZ2V0ID0gbmV3IEJ5dGVBcnJheUFsbG9jYXRlKDgxOTIpO1xuXHRcdFx0XHR0YXJnZXRWaWV3ID0gdGFyZ2V0LmRhdGFWaWV3IHx8ICh0YXJnZXQuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcodGFyZ2V0LmJ1ZmZlciwgMCwgODE5MikpO1xuXHRcdFx0XHRwb3NpdGlvbiA9IDA7XG5cdFx0XHR9XG5cdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwO1xuXHRcdFx0aWYgKHNhZmVFbmQgLSBwb3NpdGlvbiA8IDB4ODAwKSB7XG5cdFx0XHRcdC8vIGRvbid0IHN0YXJ0IHRvbyBjbG9zZSB0byB0aGUgZW5kLFxuXHRcdFx0XHR0YXJnZXQgPSBuZXcgQnl0ZUFycmF5QWxsb2NhdGUodGFyZ2V0Lmxlbmd0aCk7XG5cdFx0XHRcdHRhcmdldFZpZXcgPSB0YXJnZXQuZGF0YVZpZXcgfHwgKHRhcmdldC5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyh0YXJnZXQuYnVmZmVyLCAwLCB0YXJnZXQubGVuZ3RoKSk7XG5cdFx0XHRcdHNhZmVFbmQgPSB0YXJnZXQubGVuZ3RoIC0gMTA7XG5cdFx0XHRcdHBvc2l0aW9uID0gMDtcblx0XHRcdH0gZWxzZVxuXHRcdFx0XHRwb3NpdGlvbiA9IChwb3NpdGlvbiArIDcpICYgMHg3ZmZmZmZmODsgLy8gV29yZCBhbGlnbiB0byBtYWtlIGFueSBmdXR1cmUgY29weWluZyBvZiB0aGlzIGJ1ZmZlciBmYXN0ZXJcblx0XHRcdHN0YXJ0ID0gcG9zaXRpb247XG5cdFx0XHRpZiAoZW5jb2RlT3B0aW9ucyAmIFJFU0VSVkVfU1RBUlRfU1BBQ0UpIHBvc2l0aW9uICs9IChlbmNvZGVPcHRpb25zICYgMHhmZik7XG5cdFx0XHRyZWZlcmVuY2VNYXAgPSBwYWNrci5zdHJ1Y3R1cmVkQ2xvbmUgPyBuZXcgTWFwKCkgOiBudWxsO1xuXHRcdFx0aWYgKHBhY2tyLmJ1bmRsZVN0cmluZ3MgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRidW5kbGVkU3RyaW5ncyA9IFtdO1xuXHRcdFx0XHRidW5kbGVkU3RyaW5ncy5zaXplID0gSW5maW5pdHk7IC8vIGZvcmNlIGEgbmV3IGJ1bmRsZSBzdGFydCBvbiBmaXJzdCBzdHJpbmdcblx0XHRcdH0gZWxzZVxuXHRcdFx0XHRidW5kbGVkU3RyaW5ncyA9IG51bGw7XG5cdFx0XHRzdHJ1Y3R1cmVzID0gcGFja3Iuc3RydWN0dXJlcztcblx0XHRcdGlmIChzdHJ1Y3R1cmVzKSB7XG5cdFx0XHRcdGlmIChzdHJ1Y3R1cmVzLnVuaW5pdGlhbGl6ZWQpXG5cdFx0XHRcdFx0c3RydWN0dXJlcyA9IHBhY2tyLl9tZXJnZVN0cnVjdHVyZXMocGFja3IuZ2V0U3RydWN0dXJlcygpKTtcblx0XHRcdFx0bGV0IHNoYXJlZExlbmd0aCA9IHN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoIHx8IDA7XG5cdFx0XHRcdGlmIChzaGFyZWRMZW5ndGggPiBtYXhTaGFyZWRTdHJ1Y3R1cmVzKSB7XG5cdFx0XHRcdFx0Ly9pZiAobWF4U2hhcmVkU3RydWN0dXJlcyA8PSAzMiAmJiBzdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCA+IDMyKSAvLyBUT0RPOiBjb3VsZCBzdXBwb3J0IHRoaXMsIGJ1dCB3b3VsZCBuZWVkIHRvIHVwZGF0ZSB0aGUgbGltaXQgaWRzXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdTaGFyZWQgc3RydWN0dXJlcyBpcyBsYXJnZXIgdGhhbiBtYXhpbXVtIHNoYXJlZCBzdHJ1Y3R1cmVzLCB0cnkgaW5jcmVhc2luZyBtYXhTaGFyZWRTdHJ1Y3R1cmVzIHRvICcgKyBzdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aClcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN0cnVjdHVyZXMudHJhbnNpdGlvbnMpIHtcblx0XHRcdFx0XHQvLyByZWJ1aWxkIG91ciBzdHJ1Y3R1cmUgdHJhbnNpdGlvbnNcblx0XHRcdFx0XHRzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHNoYXJlZExlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRsZXQga2V5cyA9IHN0cnVjdHVyZXNbaV07XG5cdFx0XHRcdFx0XHRpZiAoIWtleXMpXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHRcdFx0XHRsZXQgbmV4dFRyYW5zaXRpb24sIHRyYW5zaXRpb24gPSBzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zO1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuXHRcdFx0XHRcdFx0XHRsZXQga2V5ID0ga2V5c1tqXTtcblx0XHRcdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV07XG5cdFx0XHRcdFx0XHRcdGlmICghbmV4dFRyYW5zaXRpb24pIHtcblx0XHRcdFx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbltSRUNPUkRfU1lNQk9MXSA9IGkgKyAweDQwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmxhc3ROYW1lZFN0cnVjdHVyZXNMZW5ndGggPSBzaGFyZWRMZW5ndGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFpc1NlcXVlbnRpYWwpIHtcblx0XHRcdFx0XHRzdHJ1Y3R1cmVzLm5leHRJZCA9IHNoYXJlZExlbmd0aCArIDB4NDA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChoYXNTaGFyZWRVcGRhdGUpXG5cdFx0XHRcdGhhc1NoYXJlZFVwZGF0ZSA9IGZhbHNlO1xuXHRcdFx0bGV0IGVuY29kaW5nRXJyb3I7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAocGFja3IucmFuZG9tQWNjZXNzU3RydWN0dXJlICYmIHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpXG5cdFx0XHRcdFx0d3JpdGVTdHJ1Y3QodmFsdWUpO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0cGFjayh2YWx1ZSk7XG5cdFx0XHRcdGxldCBsYXN0QnVuZGxlID0gYnVuZGxlZFN0cmluZ3M7XG5cdFx0XHRcdGlmIChidW5kbGVkU3RyaW5ncylcblx0XHRcdFx0XHR3cml0ZUJ1bmRsZXMoc3RhcnQsIHBhY2ssIDApO1xuXHRcdFx0XHRpZiAocmVmZXJlbmNlTWFwICYmIHJlZmVyZW5jZU1hcC5pZHNUb0luc2VydCkge1xuXHRcdFx0XHRcdGxldCBpZHNUb0luc2VydCA9IHJlZmVyZW5jZU1hcC5pZHNUb0luc2VydC5zb3J0KChhLCBiKSA9PiBhLm9mZnNldCA+IGIub2Zmc2V0ID8gMSA6IC0xKTtcblx0XHRcdFx0XHRsZXQgaSA9IGlkc1RvSW5zZXJ0Lmxlbmd0aDtcblx0XHRcdFx0XHRsZXQgaW5jcmVtZW50UG9zaXRpb24gPSAtMTtcblx0XHRcdFx0XHR3aGlsZSAobGFzdEJ1bmRsZSAmJiBpID4gMCkge1xuXHRcdFx0XHRcdFx0bGV0IGluc2VydGlvblBvaW50ID0gaWRzVG9JbnNlcnRbLS1pXS5vZmZzZXQgKyBzdGFydDtcblx0XHRcdFx0XHRcdGlmIChpbnNlcnRpb25Qb2ludCA8IChsYXN0QnVuZGxlLnN0cmluZ3NQb3NpdGlvbiArIHN0YXJ0KSAmJiBpbmNyZW1lbnRQb3NpdGlvbiA9PT0gLTEpXG5cdFx0XHRcdFx0XHRcdGluY3JlbWVudFBvc2l0aW9uID0gMDtcblx0XHRcdFx0XHRcdGlmIChpbnNlcnRpb25Qb2ludCA+IChsYXN0QnVuZGxlLnBvc2l0aW9uICsgc3RhcnQpKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChpbmNyZW1lbnRQb3NpdGlvbiA+PSAwKVxuXHRcdFx0XHRcdFx0XHRcdGluY3JlbWVudFBvc2l0aW9uICs9IDY7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpZiAoaW5jcmVtZW50UG9zaXRpb24gPj0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIHVwZGF0ZSB0aGUgYnVuZGxlIHJlZmVyZW5jZSBub3dcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihsYXN0QnVuZGxlLnBvc2l0aW9uICsgc3RhcnQsXG5cdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3LmdldFVpbnQzMihsYXN0QnVuZGxlLnBvc2l0aW9uICsgc3RhcnQpICsgaW5jcmVtZW50UG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0XHRcdGluY3JlbWVudFBvc2l0aW9uID0gLTE7IC8vIHJlc2V0XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0bGFzdEJ1bmRsZSA9IGxhc3RCdW5kbGUucHJldmlvdXM7XG5cdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGluY3JlbWVudFBvc2l0aW9uID49IDAgJiYgbGFzdEJ1bmRsZSkge1xuXHRcdFx0XHRcdFx0Ly8gdXBkYXRlIHRoZSBidW5kbGUgcmVmZXJlbmNlIG5vd1xuXHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIobGFzdEJ1bmRsZS5wb3NpdGlvbiArIHN0YXJ0LFxuXHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3LmdldFVpbnQzMihsYXN0QnVuZGxlLnBvc2l0aW9uICsgc3RhcnQpICsgaW5jcmVtZW50UG9zaXRpb24pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwb3NpdGlvbiArPSBpZHNUb0luc2VydC5sZW5ndGggKiA2O1xuXHRcdFx0XHRcdGlmIChwb3NpdGlvbiA+IHNhZmVFbmQpXG5cdFx0XHRcdFx0XHRtYWtlUm9vbShwb3NpdGlvbik7XG5cdFx0XHRcdFx0cGFja3Iub2Zmc2V0ID0gcG9zaXRpb247XG5cdFx0XHRcdFx0bGV0IHNlcmlhbGl6ZWQgPSBpbnNlcnRJZHModGFyZ2V0LnN1YmFycmF5KHN0YXJ0LCBwb3NpdGlvbiksIGlkc1RvSW5zZXJ0KTtcblx0XHRcdFx0XHRyZWZlcmVuY2VNYXAgPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiBzZXJpYWxpemVkXG5cdFx0XHRcdH1cblx0XHRcdFx0cGFja3Iub2Zmc2V0ID0gcG9zaXRpb247IC8vIHVwZGF0ZSB0aGUgb2Zmc2V0IHNvIG5leHQgc2VyaWFsaXphdGlvbiBkb2Vzbid0IHdyaXRlIG92ZXIgb3VyIGJ1ZmZlciwgYnV0IGNhbiBjb250aW51ZSB3cml0aW5nIHRvIHNhbWUgYnVmZmVyIHNlcXVlbnRpYWxseVxuXHRcdFx0XHRpZiAoZW5jb2RlT3B0aW9ucyAmIFJFVVNFX0JVRkZFUl9NT0RFKSB7XG5cdFx0XHRcdFx0dGFyZ2V0LnN0YXJ0ID0gc3RhcnQ7XG5cdFx0XHRcdFx0dGFyZ2V0LmVuZCA9IHBvc2l0aW9uO1xuXHRcdFx0XHRcdHJldHVybiB0YXJnZXRcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0LnN1YmFycmF5KHN0YXJ0LCBwb3NpdGlvbikgLy8gcG9zaXRpb24gY2FuIGNoYW5nZSBpZiB3ZSBjYWxsIHBhY2sgYWdhaW4gaW4gc2F2ZVN0cnVjdHVyZXMsIHNvIHdlIGdldCB0aGUgYnVmZmVyIG5vd1xuXHRcdFx0fSBjYXRjaChlcnJvcikge1xuXHRcdFx0XHRlbmNvZGluZ0Vycm9yID0gZXJyb3I7XG5cdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0aWYgKHN0cnVjdHVyZXMpIHtcblx0XHRcdFx0XHRyZXNldFN0cnVjdHVyZXMoKTtcblx0XHRcdFx0XHRpZiAoaGFzU2hhcmVkVXBkYXRlICYmIHBhY2tyLnNhdmVTdHJ1Y3R1cmVzKSB7XG5cdFx0XHRcdFx0XHRsZXQgc2hhcmVkTGVuZ3RoID0gc3RydWN0dXJlcy5zaGFyZWRMZW5ndGggfHwgMDtcblx0XHRcdFx0XHRcdC8vIHdlIGNhbid0IHJlbHkgb24gc3RhcnQvZW5kIHdpdGggUkVVU0VfQlVGRkVSX01PREUgc2luY2UgdGhleSB3aWxsIChwcm9iYWJseSkgY2hhbmdlIHdoZW4gd2Ugc2F2ZVxuXHRcdFx0XHRcdFx0bGV0IHJldHVybkJ1ZmZlciA9IHRhcmdldC5zdWJhcnJheShzdGFydCwgcG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0bGV0IG5ld1NoYXJlZERhdGEgPSBwcmVwYXJlU3RydWN0dXJlcyQxKHN0cnVjdHVyZXMsIHBhY2tyKTtcblx0XHRcdFx0XHRcdGlmICghZW5jb2RpbmdFcnJvcikgeyAvLyBUT0RPOiBJZiB0aGVyZSBpcyBhbiBlbmNvZGluZyBlcnJvciwgc2hvdWxkIG1ha2UgdGhlIHN0cnVjdHVyZXMgYXMgdW5pbml0aWFsaXplZCBzbyB0aGV5IGdldCByZWJ1aWx0IG5leHQgdGltZVxuXHRcdFx0XHRcdFx0XHRpZiAocGFja3Iuc2F2ZVN0cnVjdHVyZXMobmV3U2hhcmVkRGF0YSwgbmV3U2hhcmVkRGF0YS5pc0NvbXBhdGlibGUpID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGdldCB1cGRhdGVkIHN0cnVjdHVyZXMgYW5kIHRyeSBhZ2FpbiBpZiB0aGUgdXBkYXRlIGZhaWxlZFxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBwYWNrci5wYWNrKHZhbHVlLCBlbmNvZGVPcHRpb25zKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHBhY2tyLmxhc3ROYW1lZFN0cnVjdHVyZXNMZW5ndGggPSBzaGFyZWRMZW5ndGg7XG5cdFx0XHRcdFx0XHRcdC8vIGRvbid0IGtlZXAgbGFyZ2UgYnVmZmVycyBhcm91bmRcblx0XHRcdFx0XHRcdFx0aWYgKHRhcmdldC5sZW5ndGggPiAweDQwMDAwMDAwKSB0YXJnZXQgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmV0dXJuQnVmZmVyXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGRvbid0IGtlZXAgbGFyZ2UgYnVmZmVycyBhcm91bmQsIHRoZXkgdGFrZSB0b28gbXVjaCBtZW1vcnkgYW5kIGNhdXNlIHByb2JsZW1zIChsaW1pdCBhdCAxR0IpXG5cdFx0XHRcdGlmICh0YXJnZXQubGVuZ3RoID4gMHg0MDAwMDAwMCkgdGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0aWYgKGVuY29kZU9wdGlvbnMgJiBSRVNFVF9CVUZGRVJfTU9ERSlcblx0XHRcdFx0XHRwb3NpdGlvbiA9IHN0YXJ0O1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0Y29uc3QgcmVzZXRTdHJ1Y3R1cmVzID0gKCkgPT4ge1xuXHRcdFx0aWYgKHNlcmlhbGl6YXRpb25zU2luY2VUcmFuc2l0aW9uUmVidWlsZCA8IDEwKVxuXHRcdFx0XHRzZXJpYWxpemF0aW9uc1NpbmNlVHJhbnNpdGlvblJlYnVpbGQrKztcblx0XHRcdGxldCBzaGFyZWRMZW5ndGggPSBzdHJ1Y3R1cmVzLnNoYXJlZExlbmd0aCB8fCAwO1xuXHRcdFx0aWYgKHN0cnVjdHVyZXMubGVuZ3RoID4gc2hhcmVkTGVuZ3RoICYmICFpc1NlcXVlbnRpYWwpXG5cdFx0XHRcdHN0cnVjdHVyZXMubGVuZ3RoID0gc2hhcmVkTGVuZ3RoO1xuXHRcdFx0aWYgKHRyYW5zaXRpb25zQ291bnQgPiAxMDAwMCkge1xuXHRcdFx0XHQvLyBmb3JjZSBhIHJlYnVpbGQgb2NjYXNpb25hbGx5IGFmdGVyIGEgbG90IG9mIHRyYW5zaXRpb25zIHNvIGl0IGNhbiBnZXQgY2xlYW5lZCB1cFxuXHRcdFx0XHRzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zID0gbnVsbDtcblx0XHRcdFx0c2VyaWFsaXphdGlvbnNTaW5jZVRyYW5zaXRpb25SZWJ1aWxkID0gMDtcblx0XHRcdFx0dHJhbnNpdGlvbnNDb3VudCA9IDA7XG5cdFx0XHRcdGlmIChyZWNvcmRJZHNUb1JlbW92ZS5sZW5ndGggPiAwKVxuXHRcdFx0XHRcdHJlY29yZElkc1RvUmVtb3ZlID0gW107XG5cdFx0XHR9IGVsc2UgaWYgKHJlY29yZElkc1RvUmVtb3ZlLmxlbmd0aCA+IDAgJiYgIWlzU2VxdWVudGlhbCkge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHJlY29yZElkc1RvUmVtb3ZlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHJlY29yZElkc1RvUmVtb3ZlW2ldW1JFQ09SRF9TWU1CT0xdID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZWNvcmRJZHNUb1JlbW92ZSA9IFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0Y29uc3QgcGFja0FycmF5ID0gKHZhbHVlKSA9PiB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTApIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg5MCB8IGxlbmd0aDtcblx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRjO1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggPj4gODtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGQ7XG5cdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBsZW5ndGgpO1xuXHRcdFx0XHRwb3NpdGlvbiArPSA0O1xuXHRcdFx0fVxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRwYWNrKHZhbHVlW2ldKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGNvbnN0IHBhY2sgPSAodmFsdWUpID0+IHtcblx0XHRcdGlmIChwb3NpdGlvbiA+IHNhZmVFbmQpXG5cdFx0XHRcdHRhcmdldCA9IG1ha2VSb29tKHBvc2l0aW9uKTtcblxuXHRcdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cdFx0XHR2YXIgbGVuZ3RoO1xuXHRcdFx0aWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGxldCBzdHJMZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdGlmIChidW5kbGVkU3RyaW5ncyAmJiBzdHJMZW5ndGggPj0gNCAmJiBzdHJMZW5ndGggPCAweDEwMDApIHtcblx0XHRcdFx0XHRpZiAoKGJ1bmRsZWRTdHJpbmdzLnNpemUgKz0gc3RyTGVuZ3RoKSA+IE1BWF9CVU5ETEVfU0laRSkge1xuXHRcdFx0XHRcdFx0bGV0IGV4dFN0YXJ0O1xuXHRcdFx0XHRcdFx0bGV0IG1heEJ5dGVzID0gKGJ1bmRsZWRTdHJpbmdzWzBdID8gYnVuZGxlZFN0cmluZ3NbMF0ubGVuZ3RoICogMyArIGJ1bmRsZWRTdHJpbmdzWzFdLmxlbmd0aCA6IDApICsgMTA7XG5cdFx0XHRcdFx0XHRpZiAocG9zaXRpb24gKyBtYXhCeXRlcyA+IHNhZmVFbmQpXG5cdFx0XHRcdFx0XHRcdHRhcmdldCA9IG1ha2VSb29tKHBvc2l0aW9uICsgbWF4Qnl0ZXMpO1xuXHRcdFx0XHRcdFx0bGV0IGxhc3RCdW5kbGU7XG5cdFx0XHRcdFx0XHRpZiAoYnVuZGxlZFN0cmluZ3MucG9zaXRpb24pIHsgLy8gaGVyZSB3ZSB1c2UgdGhlIDB4NjIgZXh0ZW5zaW9uIHRvIHdyaXRlIHRoZSBsYXN0IGJ1bmRsZSBhbmQgcmVzZXJ2ZSBzcGFjZSBmb3IgdGhlIHJlZmVyZW5jZSBwb2ludGVyIHRvIHRoZSBuZXh0L2N1cnJlbnQgYnVuZGxlXG5cdFx0XHRcdFx0XHRcdGxhc3RCdW5kbGUgPSBidW5kbGVkU3RyaW5ncztcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uXSA9IDB4Yzg7IC8vIGV4dCAxNlxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSAzOyAvLyByZXNlcnZlIGZvciB0aGUgd3JpdGluZyBidW5kbGUgc2l6ZVxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDYyOyAvLyAnYidcblx0XHRcdFx0XHRcdFx0ZXh0U3RhcnQgPSBwb3NpdGlvbiAtIHN0YXJ0O1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0OyAvLyByZXNlcnZlIGZvciB3cml0aW5nIGJ1bmRsZSByZWZlcmVuY2Vcblx0XHRcdFx0XHRcdFx0d3JpdGVCdW5kbGVzKHN0YXJ0LCBwYWNrLCAwKTsgLy8gd3JpdGUgdGhlIGxhc3QgYnVuZGxlc1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQxNihleHRTdGFydCArIHN0YXJ0IC0gMywgcG9zaXRpb24gLSBzdGFydCAtIGV4dFN0YXJ0KTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7IC8vIGhlcmUgd2UgdXNlIHRoZSAweDYyIGV4dGVuc2lvbiBqdXN0IHRvIHJlc2VydmUgdGhlIHNwYWNlIGZvciB0aGUgcmVmZXJlbmNlIHBvaW50ZXIgdG8gdGhlIGJ1bmRsZSAod2lsbCBiZSB1cGRhdGVkIG9uY2UgdGhlIGJ1bmRsZSBpcyB3cml0dGVuKVxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ2OyAvLyBmaXhleHQgNFxuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDYyOyAvLyAnYidcblx0XHRcdFx0XHRcdFx0ZXh0U3RhcnQgPSBwb3NpdGlvbiAtIHN0YXJ0O1xuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0OyAvLyByZXNlcnZlIGZvciB3cml0aW5nIGJ1bmRsZSByZWZlcmVuY2Vcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJ1bmRsZWRTdHJpbmdzID0gWycnLCAnJ107IC8vIGNyZWF0ZSBuZXcgb25lc1xuXHRcdFx0XHRcdFx0YnVuZGxlZFN0cmluZ3MucHJldmlvdXMgPSBsYXN0QnVuZGxlO1xuXHRcdFx0XHRcdFx0YnVuZGxlZFN0cmluZ3Muc2l6ZSA9IDA7XG5cdFx0XHRcdFx0XHRidW5kbGVkU3RyaW5ncy5wb3NpdGlvbiA9IGV4dFN0YXJ0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRsZXQgdHdvQnl0ZSA9IGhhc05vbkxhdGluLnRlc3QodmFsdWUpO1xuXHRcdFx0XHRcdGJ1bmRsZWRTdHJpbmdzW3R3b0J5dGUgPyAwIDogMV0gKz0gdmFsdWU7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjMTtcblx0XHRcdFx0XHRwYWNrKHR3b0J5dGUgPyAtc3RyTGVuZ3RoIDogc3RyTGVuZ3RoKTtcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgaGVhZGVyU2l6ZTtcblx0XHRcdFx0Ly8gZmlyc3Qgd2UgZXN0aW1hdGUgdGhlIGhlYWRlciBzaXplLCBzbyB3ZSBjYW4gd3JpdGUgdG8gdGhlIGNvcnJlY3QgbG9jYXRpb25cblx0XHRcdFx0aWYgKHN0ckxlbmd0aCA8IDB4MjApIHtcblx0XHRcdFx0XHRoZWFkZXJTaXplID0gMTtcblx0XHRcdFx0fSBlbHNlIGlmIChzdHJMZW5ndGggPCAweDEwMCkge1xuXHRcdFx0XHRcdGhlYWRlclNpemUgPSAyO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHN0ckxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0XHRoZWFkZXJTaXplID0gMztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRoZWFkZXJTaXplID0gNTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgbWF4Qnl0ZXMgPSBzdHJMZW5ndGggKiAzO1xuXHRcdFx0XHRpZiAocG9zaXRpb24gKyBtYXhCeXRlcyA+IHNhZmVFbmQpXG5cdFx0XHRcdFx0dGFyZ2V0ID0gbWFrZVJvb20ocG9zaXRpb24gKyBtYXhCeXRlcyk7XG5cblx0XHRcdFx0aWYgKHN0ckxlbmd0aCA8IDB4NDAgfHwgIWVuY29kZVV0ZjgpIHtcblx0XHRcdFx0XHRsZXQgaSwgYzEsIGMyLCBzdHJQb3NpdGlvbiA9IHBvc2l0aW9uICsgaGVhZGVyU2l6ZTtcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgc3RyTGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGMxID0gdmFsdWUuY2hhckNvZGVBdChpKTtcblx0XHRcdFx0XHRcdGlmIChjMSA8IDB4ODApIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzE7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGMxIDwgMHg4MDApIHtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgPj4gNiB8IDB4YzA7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxICYgMHgzZiB8IDB4ODA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRcdFx0XHQoYzEgJiAweGZjMDApID09PSAweGQ4MDAgJiZcblx0XHRcdFx0XHRcdFx0KChjMiA9IHZhbHVlLmNoYXJDb2RlQXQoaSArIDEpKSAmIDB4ZmMwMCkgPT09IDB4ZGMwMFxuXHRcdFx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0XHRcdGMxID0gMHgxMDAwMCArICgoYzEgJiAweDAzZmYpIDw8IDEwKSArIChjMiAmIDB4MDNmZik7XG5cdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgPj4gMTggfCAweGYwO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSA+PiAxMiAmIDB4M2YgfCAweDgwO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSA+PiA2ICYgMHgzZiB8IDB4ODA7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxICYgMHgzZiB8IDB4ODA7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbc3RyUG9zaXRpb24rK10gPSBjMSA+PiAxMiB8IDB4ZTA7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtzdHJQb3NpdGlvbisrXSA9IGMxID4+IDYgJiAweDNmIHwgMHg4MDtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3N0clBvc2l0aW9uKytdID0gYzEgJiAweDNmIHwgMHg4MDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGVuZ3RoID0gc3RyUG9zaXRpb24gLSBwb3NpdGlvbiAtIGhlYWRlclNpemU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGVuZ3RoID0gZW5jb2RlVXRmOCh2YWx1ZSwgcG9zaXRpb24gKyBoZWFkZXJTaXplKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChsZW5ndGggPCAweDIwKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhhMCB8IGxlbmd0aDtcblx0XHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPCAweDEwMCkge1xuXHRcdFx0XHRcdGlmIChoZWFkZXJTaXplIDwgMikge1xuXHRcdFx0XHRcdFx0dGFyZ2V0LmNvcHlXaXRoaW4ocG9zaXRpb24gKyAyLCBwb3NpdGlvbiArIDEsIHBvc2l0aW9uICsgMSArIGxlbmd0aCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDk7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0XHRpZiAoaGVhZGVyU2l6ZSA8IDMpIHtcblx0XHRcdFx0XHRcdHRhcmdldC5jb3B5V2l0aGluKHBvc2l0aW9uICsgMywgcG9zaXRpb24gKyAyLCBwb3NpdGlvbiArIDIgKyBsZW5ndGgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRhO1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiA4O1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCAmIDB4ZmY7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKGhlYWRlclNpemUgPCA1KSB7XG5cdFx0XHRcdFx0XHR0YXJnZXQuY29weVdpdGhpbihwb3NpdGlvbiArIDUsIHBvc2l0aW9uICsgMywgcG9zaXRpb24gKyAzICsgbGVuZ3RoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkYjtcblx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgbGVuZ3RoKTtcblx0XHRcdFx0XHRwb3NpdGlvbiArPSA0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBvc2l0aW9uICs9IGxlbmd0aDtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0aWYgKHZhbHVlID4+PiAwID09PSB2YWx1ZSkgey8vIHBvc2l0aXZlIGludGVnZXIsIDMyLWJpdCBvciBsZXNzXG5cdFx0XHRcdFx0Ly8gcG9zaXRpdmUgdWludFxuXHRcdFx0XHRcdGlmICh2YWx1ZSA8IDB4MjAgfHwgKHZhbHVlIDwgMHg4MCAmJiB0aGlzLnVzZVJlY29yZHMgPT09IGZhbHNlKSB8fCAodmFsdWUgPCAweDQwICYmICF0aGlzLnJhbmRvbUFjY2Vzc1N0cnVjdHVyZSkpIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCAweDEwMCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjYztcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCAweDEwMDAwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGNkO1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdmFsdWUgPj4gODtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlICYgMHhmZjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjZTtcblx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA+PiAwID09PSB2YWx1ZSkgeyAvLyBuZWdhdGl2ZSBpbnRlZ2VyXG5cdFx0XHRcdFx0aWYgKHZhbHVlID49IC0weDIwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDEwMCArIHZhbHVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPj0gLTB4ODApIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDA7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSB2YWx1ZSArIDB4MTAwO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPj0gLTB4ODAwMCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkMTtcblx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0SW50MTYocG9zaXRpb24sIHZhbHVlKTtcblx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDI7XG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEludDMyKHBvc2l0aW9uLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiArPSA0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsZXQgdXNlRmxvYXQzMjtcblx0XHRcdFx0XHRpZiAoKHVzZUZsb2F0MzIgPSB0aGlzLnVzZUZsb2F0MzIpID4gMCAmJiB2YWx1ZSA8IDB4MTAwMDAwMDAwICYmIHZhbHVlID49IC0weDgwMDAwMDAwKSB7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGNhO1xuXHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRGbG9hdDMyKHBvc2l0aW9uLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRsZXQgeFNoaWZ0ZWQ7XG5cdFx0XHRcdFx0XHRpZiAodXNlRmxvYXQzMiA8IDQgfHxcblx0XHRcdFx0XHRcdFx0XHQvLyB0aGlzIGNoZWNrcyBmb3Igcm91bmRpbmcgb2YgbnVtYmVycyB0aGF0IHdlcmUgZW5jb2RlZCBpbiAzMi1iaXQgZmxvYXQgdG8gbmVhcmVzdCBzaWduaWZpY2FudCBkZWNpbWFsIGRpZ2l0IHRoYXQgY291bGQgYmUgcHJlc2VydmVkXG5cdFx0XHRcdFx0XHRcdFx0KCh4U2hpZnRlZCA9IHZhbHVlICogbXVsdDEwWygodGFyZ2V0W3Bvc2l0aW9uXSAmIDB4N2YpIDw8IDEpIHwgKHRhcmdldFtwb3NpdGlvbiArIDFdID4+IDcpXSkgPj4gMCkgPT09IHhTaGlmdGVkKSB7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDQ7XG5cdFx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uLS07IC8vIG1vdmUgYmFjayBpbnRvIHBvc2l0aW9uIGZvciB3cml0aW5nIGEgZG91YmxlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2I7XG5cdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRGbG9hdDY0KHBvc2l0aW9uLCB2YWx1ZSk7XG5cdFx0XHRcdFx0cG9zaXRpb24gKz0gODtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGlmICghdmFsdWUpXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjMDtcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHJlZmVyZW5jZU1hcCkge1xuXHRcdFx0XHRcdFx0bGV0IHJlZmVyZWUgPSByZWZlcmVuY2VNYXAuZ2V0KHZhbHVlKTtcblx0XHRcdFx0XHRcdGlmIChyZWZlcmVlKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghcmVmZXJlZS5pZCkge1xuXHRcdFx0XHRcdFx0XHRcdGxldCBpZHNUb0luc2VydCA9IHJlZmVyZW5jZU1hcC5pZHNUb0luc2VydCB8fCAocmVmZXJlbmNlTWFwLmlkc1RvSW5zZXJ0ID0gW10pO1xuXHRcdFx0XHRcdFx0XHRcdHJlZmVyZWUuaWQgPSBpZHNUb0luc2VydC5wdXNoKHJlZmVyZWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDY7IC8vIGZpeGV4dCA0XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NzA7IC8vIFwicFwiIGZvciBwb2ludGVyXG5cdFx0XHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCByZWZlcmVlLmlkKTtcblx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNDtcblx0XHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdFx0cmVmZXJlbmNlTWFwLnNldCh2YWx1ZSwgeyBvZmZzZXQ6IHBvc2l0aW9uIC0gc3RhcnQgfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxldCBjb25zdHJ1Y3RvciA9IHZhbHVlLmNvbnN0cnVjdG9yO1xuXHRcdFx0XHRcdGlmIChjb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG5cdFx0XHRcdFx0XHR3cml0ZU9iamVjdCh2YWx1ZSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcblx0XHRcdFx0XHRcdHBhY2tBcnJheSh2YWx1ZSk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChjb25zdHJ1Y3RvciA9PT0gTWFwKSB7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5tYXBBc0VtcHR5T2JqZWN0KSB0YXJnZXRbcG9zaXRpb24rK10gPSAweDgwO1xuXHRcdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGxlbmd0aCA9IHZhbHVlLnNpemU7XG5cdFx0XHRcdFx0XHRcdGlmIChsZW5ndGggPCAweDEwKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg4MCB8IGxlbmd0aDtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkZTtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggPj4gODtcblx0XHRcdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggJiAweGZmO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGY7XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGxlbmd0aCk7XG5cdFx0XHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gNDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRmb3IgKGxldCBba2V5LCBlbnRyeVZhbHVlXSBvZiB2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRcdHBhY2soa2V5KTtcblx0XHRcdFx0XHRcdFx0XHRwYWNrKGVudHJ5VmFsdWUpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gZXh0ZW5zaW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0bGV0IGV4dGVuc2lvbkNsYXNzID0gZXh0ZW5zaW9uQ2xhc3Nlc1tpXTtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgZXh0ZW5zaW9uQ2xhc3MpIHtcblx0XHRcdFx0XHRcdFx0XHRsZXQgZXh0ZW5zaW9uID0gZXh0ZW5zaW9uc1tpXTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoZXh0ZW5zaW9uLndyaXRlKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoZXh0ZW5zaW9uLnR5cGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNDsgLy8gb25lIGJ5dGUgXCJ0YWdcIiBleHRlbnNpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gZXh0ZW5zaW9uLnR5cGU7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRsZXQgd3JpdGVSZXN1bHQgPSBleHRlbnNpb24ud3JpdGUuY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAod3JpdGVSZXN1bHQgPT09IHZhbHVlKSB7IC8vIGF2b2lkIGluZmluaXRlIHJlY3Vyc2lvblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwYWNrQXJyYXkodmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHdyaXRlT2JqZWN0KHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFjayh3cml0ZVJlc3VsdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGN1cnJlbnRUYXJnZXQgPSB0YXJnZXQ7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IGN1cnJlbnRUYXJnZXRWaWV3ID0gdGFyZ2V0Vmlldztcblx0XHRcdFx0XHRcdFx0XHRsZXQgY3VycmVudFBvc2l0aW9uID0gcG9zaXRpb247XG5cdFx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0XHRsZXQgcmVzdWx0O1xuXHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQgPSBleHRlbnNpb24ucGFjay5jYWxsKHRoaXMsIHZhbHVlLCAoc2l6ZSkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyByZXN0b3JlIHRhcmdldCBhbmQgdXNlIGl0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhcmdldCA9IGN1cnJlbnRUYXJnZXQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbiArPSBzaXplO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAocG9zaXRpb24gPiBzYWZlRW5kKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1ha2VSb29tKHBvc2l0aW9uKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0YXJnZXQsIHRhcmdldFZpZXcsIHBvc2l0aW9uOiBwb3NpdGlvbiAtIHNpemVcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSwgcGFjayk7XG5cdFx0XHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHJlc3RvcmUgY3VycmVudCB0YXJnZXQgaW5mb3JtYXRpb24gKHVubGVzcyBhbHJlYWR5IHJlc3RvcmVkKVxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGN1cnJlbnRUYXJnZXQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gY3VycmVudFRhcmdldDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGFyZ2V0VmlldyA9IGN1cnJlbnRUYXJnZXRWaWV3O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbiA9IGN1cnJlbnRQb3NpdGlvbjtcblx0XHRcdFx0XHRcdFx0XHRcdFx0c2FmZUVuZCA9IHRhcmdldC5sZW5ndGggLSAxMDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHJlc3VsdCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHJlc3VsdC5sZW5ndGggKyBwb3NpdGlvbiA+IHNhZmVFbmQpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG1ha2VSb29tKHJlc3VsdC5sZW5ndGggKyBwb3NpdGlvbik7XG5cdFx0XHRcdFx0XHRcdFx0XHRwb3NpdGlvbiA9IHdyaXRlRXh0ZW5zaW9uRGF0YShyZXN1bHQsIHRhcmdldCwgcG9zaXRpb24sIGV4dGVuc2lvbi50eXBlKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGNoZWNrIGlzQXJyYXkgYWZ0ZXIgZXh0ZW5zaW9ucywgYmVjYXVzZSBleHRlbnNpb25zIGNhbiBleHRlbmQgQXJyYXlcblx0XHRcdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0XHRwYWNrQXJyYXkodmFsdWUpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gdXNlIHRoaXMgYXMgYW4gYWx0ZXJuYXRlIG1lY2hhbmlzbSBmb3IgZXhwcmVzc2luZyBob3cgdG8gc2VyaWFsaXplXG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZS50b0pTT04pIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBqc29uID0gdmFsdWUudG9KU09OKCk7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gaWYgZm9yIHNvbWUgcmVhc29uIHZhbHVlLnRvSlNPTiByZXR1cm5zIGl0c2VsZiBpdCdsbCBsb29wIGZvcmV2ZXJcblx0XHRcdFx0XHRcdFx0XHRpZiAoanNvbiAhPT0gdmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcGFjayhqc29uKVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgYSB3cml0ZUZ1bmN0aW9uLCB1c2UgaXQsIG90aGVyd2lzZSBqdXN0IGVuY29kZSBhcyB1bmRlZmluZWRcblx0XHRcdFx0XHRcdFx0aWYgKHR5cGUgPT09ICdmdW5jdGlvbicpXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhY2sodGhpcy53cml0ZUZ1bmN0aW9uICYmIHRoaXMud3JpdGVGdW5jdGlvbih2YWx1ZSkpO1xuXG5cdFx0XHRcdFx0XHRcdC8vIG5vIGV4dGVuc2lvbiBmb3VuZCwgd3JpdGUgYXMgcGxhaW4gb2JqZWN0XG5cdFx0XHRcdFx0XHRcdHdyaXRlT2JqZWN0KHZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHZhbHVlID8gMHhjMyA6IDB4YzI7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdiaWdpbnQnKSB7XG5cdFx0XHRcdGlmICh2YWx1ZSA8IChCaWdJbnQoMSk8PEJpZ0ludCg2MykpICYmIHZhbHVlID49IC0oQmlnSW50KDEpPDxCaWdJbnQoNjMpKSkge1xuXHRcdFx0XHRcdC8vIHVzZSBhIHNpZ25lZCBpbnQgYXMgbG9uZyBhcyBpdCBmaXRzXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkMztcblx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEJpZ0ludDY0KHBvc2l0aW9uLCB2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPCAoQmlnSW50KDEpPDxCaWdJbnQoNjQpKSAmJiB2YWx1ZSA+IDApIHtcblx0XHRcdFx0XHQvLyBpZiB3ZSBjYW4gZml0IGFuIHVuc2lnbmVkIGludCwgdXNlIHRoYXRcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGNmO1xuXHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0QmlnVWludDY0KHBvc2l0aW9uLCB2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gb3ZlcmZsb3dcblx0XHRcdFx0XHRpZiAodGhpcy5sYXJnZUJpZ0ludFRvRmxvYXQpIHtcblx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Y2I7XG5cdFx0XHRcdFx0XHR0YXJnZXRWaWV3LnNldEZsb2F0NjQocG9zaXRpb24sIE51bWJlcih2YWx1ZSkpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5sYXJnZUJpZ0ludFRvU3RyaW5nKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcGFjayh2YWx1ZS50b1N0cmluZygpKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMudXNlQmlnSW50RXh0ZW5zaW9uICYmIHZhbHVlIDwgQmlnSW50KDIpKipCaWdJbnQoMTAyMykgJiYgdmFsdWUgPiAtKEJpZ0ludCgyKSoqQmlnSW50KDEwMjMpKSkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjNztcblx0XHRcdFx0XHRcdHBvc2l0aW9uKys7XG5cdFx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDQyOyAvLyBcIkJcIiBmb3IgQmlnSW50XG5cdFx0XHRcdFx0XHRsZXQgYnl0ZXMgPSBbXTtcblx0XHRcdFx0XHRcdGxldCBhbGlnbmVkU2lnbjtcblx0XHRcdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRcdFx0bGV0IGJ5dGUgPSB2YWx1ZSAmIEJpZ0ludCgweGZmKTtcblx0XHRcdFx0XHRcdFx0YWxpZ25lZFNpZ24gPSAoYnl0ZSAmIEJpZ0ludCgweDgwKSkgPT09ICh2YWx1ZSA8IEJpZ0ludCgwKSA/IEJpZ0ludCgweDgwKSA6IEJpZ0ludCgwKSk7XG5cdFx0XHRcdFx0XHRcdGJ5dGVzLnB1c2goYnl0ZSk7XG5cdFx0XHRcdFx0XHRcdHZhbHVlID4+PSBCaWdJbnQoOCk7XG5cdFx0XHRcdFx0XHR9IHdoaWxlICghKCh2YWx1ZSA9PT0gQmlnSW50KDApIHx8IHZhbHVlID09PSBCaWdJbnQoLTEpKSAmJiBhbGlnbmVkU2lnbikpO1xuXHRcdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uLTJdID0gYnl0ZXMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IGJ5dGVzLmxlbmd0aDsgaSA+IDA7KSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IE51bWJlcihieXRlc1stLWldKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcih2YWx1ZSArICcgd2FzIHRvbyBsYXJnZSB0byBmaXQgaW4gTWVzc2FnZVBhY2sgNjQtYml0IGludGVnZXIgZm9ybWF0LCB1c2UnICtcblx0XHRcdFx0XHRcdFx0JyB1c2VCaWdJbnRFeHRlbnNpb24sIG9yIHNldCBsYXJnZUJpZ0ludFRvRmxvYXQgdG8gY29udmVydCB0byBmbG9hdC02NCwgb3Igc2V0JyArXG5cdFx0XHRcdFx0XHRcdCcgbGFyZ2VCaWdJbnRUb1N0cmluZyB0byBjb252ZXJ0IHRvIHN0cmluZycpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHBvc2l0aW9uICs9IDg7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdGlmICh0aGlzLmVuY29kZVVuZGVmaW5lZEFzTmlsKVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4YzA7XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDQ7IC8vIGEgbnVtYmVyIG9mIGltcGxlbWVudGF0aW9ucyB1c2UgZml4ZXh0MSB3aXRoIHR5cGUgMCwgZGF0YSAwIHRvIGRlbm90ZSB1bmRlZmluZWQsIHNvIHdlIGZvbGxvdyBzdWl0ZVxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDA7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyB0eXBlKVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRjb25zdCB3cml0ZVBsYWluT2JqZWN0ID0gKHRoaXMudmFyaWFibGVNYXBTaXplIHx8IHRoaXMuY29lcmNpYmxlS2V5QXNOdW1iZXIgfHwgdGhpcy5za2lwVmFsdWVzKSA/IChvYmplY3QpID0+IHtcblx0XHRcdC8vIHRoaXMgbWV0aG9kIGlzIHNsaWdodGx5IHNsb3dlciwgYnV0IGdlbmVyYXRlcyBcInByZWZlcnJlZCBzZXJpYWxpemF0aW9uXCIgKG9wdGltYWxseSBzbWFsbCBmb3Igc21hbGxlciBvYmplY3RzKVxuXHRcdFx0bGV0IGtleXM7XG5cdFx0XHRpZiAodGhpcy5za2lwVmFsdWVzKSB7XG5cdFx0XHRcdGtleXMgPSBbXTtcblx0XHRcdFx0Zm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuXHRcdFx0XHRcdGlmICgodHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJyB8fCBvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkgJiZcblx0XHRcdFx0XHRcdCF0aGlzLnNraXBWYWx1ZXMuaW5jbHVkZXMob2JqZWN0W2tleV0pKVxuXHRcdFx0XHRcdFx0a2V5cy5wdXNoKGtleSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXHRcdFx0fVxuXHRcdFx0bGV0IGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTApIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg4MCB8IGxlbmd0aDtcblx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGRlO1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggPj4gODtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoICYgMHhmZjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZGY7XG5cdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBsZW5ndGgpO1xuXHRcdFx0XHRwb3NpdGlvbiArPSA0O1xuXHRcdFx0fVxuXHRcdFx0bGV0IGtleTtcblx0XHRcdGlmICh0aGlzLmNvZXJjaWJsZUtleUFzTnVtYmVyKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRcdGxldCBudW0gPSBOdW1iZXIoa2V5KTtcblx0XHRcdFx0XHRwYWNrKGlzTmFOKG51bSkgPyBrZXkgOiBudW0pO1xuXHRcdFx0XHRcdHBhY2sob2JqZWN0W2tleV0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRwYWNrKGtleSA9IGtleXNbaV0pO1xuXHRcdFx0XHRcdHBhY2sob2JqZWN0W2tleV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSA6XG5cdFx0KG9iamVjdCkgPT4ge1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkZTsgLy8gYWx3YXlzIHVzaW5nIG1hcCAxNiwgc28gd2UgY2FuIHByZWFsbG9jYXRlIGFuZCBzZXQgdGhlIGxlbmd0aCBhZnRlcndhcmRzXG5cdFx0XHRsZXQgb2JqZWN0T2Zmc2V0ID0gcG9zaXRpb24gLSBzdGFydDtcblx0XHRcdHBvc2l0aW9uICs9IDI7XG5cdFx0XHRsZXQgc2l6ZSA9IDA7XG5cdFx0XHRmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5ICE9PSAnZnVuY3Rpb24nIHx8IG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0cGFjayhrZXkpO1xuXHRcdFx0XHRcdHBhY2sob2JqZWN0W2tleV0pO1xuXHRcdFx0XHRcdHNpemUrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHNpemUgPiAweGZmZmYpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdPYmplY3QgaXMgdG9vIGxhcmdlIHRvIHNlcmlhbGl6ZSB3aXRoIGZhc3QgMTYtYml0IG1hcCBzaXplLCcgK1xuXHRcdFx0XHQnIHVzZSB0aGUgXCJ2YXJpYWJsZU1hcFNpemVcIiBvcHRpb24gdG8gc2VyaWFsaXplIHRoaXMgb2JqZWN0Jyk7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXRbb2JqZWN0T2Zmc2V0KysgKyBzdGFydF0gPSBzaXplID4+IDg7XG5cdFx0XHR0YXJnZXRbb2JqZWN0T2Zmc2V0ICsgc3RhcnRdID0gc2l6ZSAmIDB4ZmY7XG5cdFx0fTtcblxuXHRcdGNvbnN0IHdyaXRlUmVjb3JkID0gdGhpcy51c2VSZWNvcmRzID09PSBmYWxzZSA/IHdyaXRlUGxhaW5PYmplY3QgOlxuXHRcdChvcHRpb25zLnByb2dyZXNzaXZlUmVjb3JkcyAmJiAhdXNlVHdvQnl0ZVJlY29yZHMpID8gIC8vIHRoaXMgaXMgYWJvdXQgMiUgZmFzdGVyIGZvciBoaWdobHkgc3RhYmxlIHN0cnVjdHVyZXMsIHNpbmNlIGl0IG9ubHkgcmVxdWlyZXMgb25lIGZvci1pbiBsb29wIChidXQgbXVjaCBtb3JlIGV4cGVuc2l2ZSB3aGVuIG5ldyBzdHJ1Y3R1cmUgbmVlZHMgdG8gYmUgd3JpdHRlbilcblx0XHQob2JqZWN0KSA9PiB7XG5cdFx0XHRsZXQgbmV4dFRyYW5zaXRpb24sIHRyYW5zaXRpb24gPSBzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zIHx8IChzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cdFx0XHRsZXQgb2JqZWN0T2Zmc2V0ID0gcG9zaXRpb24rKyAtIHN0YXJ0O1xuXHRcdFx0bGV0IHdyb3RlS2V5cztcblx0XHRcdGZvciAobGV0IGtleSBpbiBvYmplY3QpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHkgIT09ICdmdW5jdGlvbicgfHwgb2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XTtcblx0XHRcdFx0XHRpZiAobmV4dFRyYW5zaXRpb24pXG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb247XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyByZWNvcmQgZG9lc24ndCBleGlzdCwgY3JlYXRlIGZ1bGwgbmV3IHJlY29yZCBhbmQgaW5zZXJ0IGl0XG5cdFx0XHRcdFx0XHRsZXQga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cdFx0XHRcdFx0XHRsZXQgbGFzdFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IHN0cnVjdHVyZXMudHJhbnNpdGlvbnM7XG5cdFx0XHRcdFx0XHRsZXQgbmV3VHJhbnNpdGlvbnMgPSAwO1xuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRsZXQga2V5ID0ga2V5c1tpXTtcblx0XHRcdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV07XG5cdFx0XHRcdFx0XHRcdGlmICghbmV4dFRyYW5zaXRpb24pIHtcblx0XHRcdFx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0XHRcdFx0XHRcdFx0bmV3VHJhbnNpdGlvbnMrKztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb247XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAob2JqZWN0T2Zmc2V0ICsgc3RhcnQgKyAxID09IHBvc2l0aW9uKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGZpcnN0IGtleSwgc28gd2UgZG9uJ3QgbmVlZCB0byBpbnNlcnQsIHdlIGNhbiBqdXN0IHdyaXRlIHJlY29yZCBkaXJlY3RseVxuXHRcdFx0XHRcdFx0XHRwb3NpdGlvbi0tO1xuXHRcdFx0XHRcdFx0XHRuZXdSZWNvcmQodHJhbnNpdGlvbiwga2V5cywgbmV3VHJhbnNpdGlvbnMpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIC8vIG90aGVyd2lzZSB3ZSBuZWVkIHRvIGluc2VydCB0aGUgcmVjb3JkLCBtb3ZpbmcgZXhpc3RpbmcgZGF0YSBhZnRlciB0aGUgcmVjb3JkXG5cdFx0XHRcdFx0XHRcdGluc2VydE5ld1JlY29yZCh0cmFuc2l0aW9uLCBrZXlzLCBvYmplY3RPZmZzZXQsIG5ld1RyYW5zaXRpb25zKTtcblx0XHRcdFx0XHRcdHdyb3RlS2V5cyA9IHRydWU7XG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbGFzdFRyYW5zaXRpb25ba2V5XTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGFjayhvYmplY3Rba2V5XSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghd3JvdGVLZXlzKSB7XG5cdFx0XHRcdGxldCByZWNvcmRJZCA9IHRyYW5zaXRpb25bUkVDT1JEX1NZTUJPTF07XG5cdFx0XHRcdGlmIChyZWNvcmRJZClcblx0XHRcdFx0XHR0YXJnZXRbb2JqZWN0T2Zmc2V0ICsgc3RhcnRdID0gcmVjb3JkSWQ7XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRpbnNlcnROZXdSZWNvcmQodHJhbnNpdGlvbiwgT2JqZWN0LmtleXMob2JqZWN0KSwgb2JqZWN0T2Zmc2V0LCAwKTtcblx0XHRcdH1cblx0XHR9IDpcblx0XHQob2JqZWN0KSA9PiB7XG5cdFx0XHRsZXQgbmV4dFRyYW5zaXRpb24sIHRyYW5zaXRpb24gPSBzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zIHx8IChzdHJ1Y3R1cmVzLnRyYW5zaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cdFx0XHRsZXQgbmV3VHJhbnNpdGlvbnMgPSAwO1xuXHRcdFx0Zm9yIChsZXQga2V5IGluIG9iamVjdCkgaWYgKHR5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHkgIT09ICdmdW5jdGlvbicgfHwgb2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0bmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV07XG5cdFx0XHRcdGlmICghbmV4dFRyYW5zaXRpb24pIHtcblx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0XHRcdFx0bmV3VHJhbnNpdGlvbnMrKztcblx0XHRcdFx0fVxuXHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb247XG5cdFx0XHR9XG5cdFx0XHRsZXQgcmVjb3JkSWQgPSB0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdO1xuXHRcdFx0aWYgKHJlY29yZElkKSB7XG5cdFx0XHRcdGlmIChyZWNvcmRJZCA+PSAweDYwICYmIHVzZVR3b0J5dGVSZWNvcmRzKSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKChyZWNvcmRJZCAtPSAweDYwKSAmIDB4MWYpICsgMHg2MDtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSByZWNvcmRJZCA+PiA1O1xuXHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSByZWNvcmRJZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ld1JlY29yZCh0cmFuc2l0aW9uLCB0cmFuc2l0aW9uLl9fa2V5c19fIHx8IE9iamVjdC5rZXlzKG9iamVjdCksIG5ld1RyYW5zaXRpb25zKTtcblx0XHRcdH1cblx0XHRcdC8vIG5vdyB3cml0ZSB0aGUgdmFsdWVzXG5cdFx0XHRmb3IgKGxldCBrZXkgaW4gb2JqZWN0KVxuXHRcdFx0XHRpZiAodHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSAhPT0gJ2Z1bmN0aW9uJyB8fCBvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdHBhY2sob2JqZWN0W2tleV0pO1xuXHRcdFx0XHR9XG5cdFx0fTtcblxuXHRcdC8vIGNyZWF0ZSByZWZlcmVuY2UgdG8gdXNlUmVjb3JkcyBpZiB1c2VSZWNvcmRzIGlzIGEgZnVuY3Rpb25cblx0XHRjb25zdCBjaGVja1VzZVJlY29yZHMgPSB0eXBlb2YgdGhpcy51c2VSZWNvcmRzID09ICdmdW5jdGlvbicgJiYgdGhpcy51c2VSZWNvcmRzO1xuXG5cdFx0Y29uc3Qgd3JpdGVPYmplY3QgPSBjaGVja1VzZVJlY29yZHMgPyAob2JqZWN0KSA9PiB7XG5cdFx0XHRjaGVja1VzZVJlY29yZHMob2JqZWN0KSA/IHdyaXRlUmVjb3JkKG9iamVjdCkgOiB3cml0ZVBsYWluT2JqZWN0KG9iamVjdCk7XG5cdFx0fSA6IHdyaXRlUmVjb3JkO1xuXG5cdFx0Y29uc3QgbWFrZVJvb20gPSAoZW5kKSA9PiB7XG5cdFx0XHRsZXQgbmV3U2l6ZTtcblx0XHRcdGlmIChlbmQgPiAweDEwMDAwMDApIHtcblx0XHRcdFx0Ly8gc3BlY2lhbCBoYW5kbGluZyBmb3IgcmVhbGx5IGxhcmdlIGJ1ZmZlcnNcblx0XHRcdFx0aWYgKChlbmQgLSBzdGFydCkgPiBNQVhfQlVGRkVSX1NJWkUpXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdQYWNrZWQgYnVmZmVyIHdvdWxkIGJlIGxhcmdlciB0aGFuIG1heGltdW0gYnVmZmVyIHNpemUnKVxuXHRcdFx0XHRuZXdTaXplID0gTWF0aC5taW4oTUFYX0JVRkZFUl9TSVpFLFxuXHRcdFx0XHRcdE1hdGgucm91bmQoTWF0aC5tYXgoKGVuZCAtIHN0YXJ0KSAqIChlbmQgPiAweDQwMDAwMDAgPyAxLjI1IDogMiksIDB4NDAwMDAwKSAvIDB4MTAwMCkgKiAweDEwMDApO1xuXHRcdFx0fSBlbHNlIC8vIGZhc3RlciBoYW5kbGluZyBmb3Igc21hbGxlciBidWZmZXJzXG5cdFx0XHRcdG5ld1NpemUgPSAoKE1hdGgubWF4KChlbmQgLSBzdGFydCkgPDwgMiwgdGFyZ2V0Lmxlbmd0aCAtIDEpID4+IDEyKSArIDEpIDw8IDEyO1xuXHRcdFx0bGV0IG5ld0J1ZmZlciA9IG5ldyBCeXRlQXJyYXlBbGxvY2F0ZShuZXdTaXplKTtcblx0XHRcdHRhcmdldFZpZXcgPSBuZXdCdWZmZXIuZGF0YVZpZXcgfHwgKG5ld0J1ZmZlci5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhuZXdCdWZmZXIuYnVmZmVyLCAwLCBuZXdTaXplKSk7XG5cdFx0XHRlbmQgPSBNYXRoLm1pbihlbmQsIHRhcmdldC5sZW5ndGgpO1xuXHRcdFx0aWYgKHRhcmdldC5jb3B5KVxuXHRcdFx0XHR0YXJnZXQuY29weShuZXdCdWZmZXIsIDAsIHN0YXJ0LCBlbmQpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRuZXdCdWZmZXIuc2V0KHRhcmdldC5zbGljZShzdGFydCwgZW5kKSk7XG5cdFx0XHRwb3NpdGlvbiAtPSBzdGFydDtcblx0XHRcdHN0YXJ0ID0gMDtcblx0XHRcdHNhZmVFbmQgPSBuZXdCdWZmZXIubGVuZ3RoIC0gMTA7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0ID0gbmV3QnVmZmVyXG5cdFx0fTtcblx0XHRjb25zdCBuZXdSZWNvcmQgPSAodHJhbnNpdGlvbiwga2V5cywgbmV3VHJhbnNpdGlvbnMpID0+IHtcblx0XHRcdGxldCByZWNvcmRJZCA9IHN0cnVjdHVyZXMubmV4dElkO1xuXHRcdFx0aWYgKCFyZWNvcmRJZClcblx0XHRcdFx0cmVjb3JkSWQgPSAweDQwO1xuXHRcdFx0aWYgKHJlY29yZElkIDwgc2hhcmVkTGltaXRJZCAmJiB0aGlzLnNob3VsZFNoYXJlU3RydWN0dXJlICYmICF0aGlzLnNob3VsZFNoYXJlU3RydWN0dXJlKGtleXMpKSB7XG5cdFx0XHRcdHJlY29yZElkID0gc3RydWN0dXJlcy5uZXh0T3duSWQ7XG5cdFx0XHRcdGlmICghKHJlY29yZElkIDwgbWF4U3RydWN0dXJlSWQpKVxuXHRcdFx0XHRcdHJlY29yZElkID0gc2hhcmVkTGltaXRJZDtcblx0XHRcdFx0c3RydWN0dXJlcy5uZXh0T3duSWQgPSByZWNvcmRJZCArIDE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAocmVjb3JkSWQgPj0gbWF4U3RydWN0dXJlSWQpLy8gY3ljbGUgYmFjayBhcm91bmRcblx0XHRcdFx0XHRyZWNvcmRJZCA9IHNoYXJlZExpbWl0SWQ7XG5cdFx0XHRcdHN0cnVjdHVyZXMubmV4dElkID0gcmVjb3JkSWQgKyAxO1xuXHRcdFx0fVxuXHRcdFx0bGV0IGhpZ2hCeXRlID0ga2V5cy5oaWdoQnl0ZSA9IHJlY29yZElkID49IDB4NjAgJiYgdXNlVHdvQnl0ZVJlY29yZHMgPyAocmVjb3JkSWQgLSAweDYwKSA+PiA1IDogLTE7XG5cdFx0XHR0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdID0gcmVjb3JkSWQ7XG5cdFx0XHR0cmFuc2l0aW9uLl9fa2V5c19fID0ga2V5cztcblx0XHRcdHN0cnVjdHVyZXNbcmVjb3JkSWQgLSAweDQwXSA9IGtleXM7XG5cblx0XHRcdGlmIChyZWNvcmRJZCA8IHNoYXJlZExpbWl0SWQpIHtcblx0XHRcdFx0a2V5cy5pc1NoYXJlZCA9IHRydWU7XG5cdFx0XHRcdHN0cnVjdHVyZXMuc2hhcmVkTGVuZ3RoID0gcmVjb3JkSWQgLSAweDNmO1xuXHRcdFx0XHRoYXNTaGFyZWRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRpZiAoaGlnaEJ5dGUgPj0gMCkge1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IChyZWNvcmRJZCAmIDB4MWYpICsgMHg2MDtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBoaWdoQnl0ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSByZWNvcmRJZDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGhpZ2hCeXRlID49IDApIHtcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ1OyAvLyBmaXhleHQgMlxuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4NzI7IC8vIFwiclwiIHJlY29yZCBkZWZpbnRpb24gZXh0ZW5zaW9uIHR5cGVcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAocmVjb3JkSWQgJiAweDFmKSArIDB4NjA7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gaGlnaEJ5dGU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNDsgLy8gZml4ZXh0IDFcblx0XHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweDcyOyAvLyBcInJcIiByZWNvcmQgZGVmaW50aW9uIGV4dGVuc2lvbiB0eXBlXG5cdFx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gcmVjb3JkSWQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAobmV3VHJhbnNpdGlvbnMpXG5cdFx0XHRcdFx0dHJhbnNpdGlvbnNDb3VudCArPSBzZXJpYWxpemF0aW9uc1NpbmNlVHJhbnNpdGlvblJlYnVpbGQgKiBuZXdUcmFuc2l0aW9ucztcblx0XHRcdFx0Ly8gcmVjb3JkIHRoZSByZW1vdmFsIG9mIHRoZSBpZCwgd2UgY2FuIG1haW50YWluIG91ciBzaGFyZWQgc3RydWN0dXJlXG5cdFx0XHRcdGlmIChyZWNvcmRJZHNUb1JlbW92ZS5sZW5ndGggPj0gbWF4T3duU3RydWN0dXJlcylcblx0XHRcdFx0XHRyZWNvcmRJZHNUb1JlbW92ZS5zaGlmdCgpW1JFQ09SRF9TWU1CT0xdID0gMDsgLy8gd2UgYXJlIGN5Y2xpbmcgYmFjayB0aHJvdWdoLCBhbmQgaGF2ZSB0byByZW1vdmUgb2xkIG9uZXNcblx0XHRcdFx0cmVjb3JkSWRzVG9SZW1vdmUucHVzaCh0cmFuc2l0aW9uKTtcblx0XHRcdFx0cGFjayhrZXlzKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGNvbnN0IGluc2VydE5ld1JlY29yZCA9ICh0cmFuc2l0aW9uLCBrZXlzLCBpbnNlcnRpb25PZmZzZXQsIG5ld1RyYW5zaXRpb25zKSA9PiB7XG5cdFx0XHRsZXQgbWFpblRhcmdldCA9IHRhcmdldDtcblx0XHRcdGxldCBtYWluUG9zaXRpb24gPSBwb3NpdGlvbjtcblx0XHRcdGxldCBtYWluU2FmZUVuZCA9IHNhZmVFbmQ7XG5cdFx0XHRsZXQgbWFpblN0YXJ0ID0gc3RhcnQ7XG5cdFx0XHR0YXJnZXQgPSBrZXlzVGFyZ2V0O1xuXHRcdFx0cG9zaXRpb24gPSAwO1xuXHRcdFx0c3RhcnQgPSAwO1xuXHRcdFx0aWYgKCF0YXJnZXQpXG5cdFx0XHRcdGtleXNUYXJnZXQgPSB0YXJnZXQgPSBuZXcgQnl0ZUFycmF5QWxsb2NhdGUoODE5Mik7XG5cdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwO1xuXHRcdFx0bmV3UmVjb3JkKHRyYW5zaXRpb24sIGtleXMsIG5ld1RyYW5zaXRpb25zKTtcblx0XHRcdGtleXNUYXJnZXQgPSB0YXJnZXQ7XG5cdFx0XHRsZXQga2V5c1Bvc2l0aW9uID0gcG9zaXRpb247XG5cdFx0XHR0YXJnZXQgPSBtYWluVGFyZ2V0O1xuXHRcdFx0cG9zaXRpb24gPSBtYWluUG9zaXRpb247XG5cdFx0XHRzYWZlRW5kID0gbWFpblNhZmVFbmQ7XG5cdFx0XHRzdGFydCA9IG1haW5TdGFydDtcblx0XHRcdGlmIChrZXlzUG9zaXRpb24gPiAxKSB7XG5cdFx0XHRcdGxldCBuZXdFbmQgPSBwb3NpdGlvbiArIGtleXNQb3NpdGlvbiAtIDE7XG5cdFx0XHRcdGlmIChuZXdFbmQgPiBzYWZlRW5kKVxuXHRcdFx0XHRcdG1ha2VSb29tKG5ld0VuZCk7XG5cdFx0XHRcdGxldCBpbnNlcnRpb25Qb3NpdGlvbiA9IGluc2VydGlvbk9mZnNldCArIHN0YXJ0O1xuXHRcdFx0XHR0YXJnZXQuY29weVdpdGhpbihpbnNlcnRpb25Qb3NpdGlvbiArIGtleXNQb3NpdGlvbiwgaW5zZXJ0aW9uUG9zaXRpb24gKyAxLCBwb3NpdGlvbik7XG5cdFx0XHRcdHRhcmdldC5zZXQoa2V5c1RhcmdldC5zbGljZSgwLCBrZXlzUG9zaXRpb24pLCBpbnNlcnRpb25Qb3NpdGlvbik7XG5cdFx0XHRcdHBvc2l0aW9uID0gbmV3RW5kO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFyZ2V0W2luc2VydGlvbk9mZnNldCArIHN0YXJ0XSA9IGtleXNUYXJnZXRbMF07XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRjb25zdCB3cml0ZVN0cnVjdCA9IChvYmplY3QpID0+IHtcblx0XHRcdGxldCBuZXdQb3NpdGlvbiA9IHdyaXRlU3RydWN0U2xvdHMob2JqZWN0LCB0YXJnZXQsIHN0YXJ0LCBwb3NpdGlvbiwgc3RydWN0dXJlcywgbWFrZVJvb20sICh2YWx1ZSwgbmV3UG9zaXRpb24sIG5vdGlmeVNoYXJlZFVwZGF0ZSkgPT4ge1xuXHRcdFx0XHRpZiAobm90aWZ5U2hhcmVkVXBkYXRlKVxuXHRcdFx0XHRcdHJldHVybiBoYXNTaGFyZWRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRwb3NpdGlvbiA9IG5ld1Bvc2l0aW9uO1xuXHRcdFx0XHRsZXQgc3RhcnRUYXJnZXQgPSB0YXJnZXQ7XG5cdFx0XHRcdHBhY2sodmFsdWUpO1xuXHRcdFx0XHRyZXNldFN0cnVjdHVyZXMoKTtcblx0XHRcdFx0aWYgKHN0YXJ0VGFyZ2V0ICE9PSB0YXJnZXQpIHtcblx0XHRcdFx0XHRyZXR1cm4geyBwb3NpdGlvbiwgdGFyZ2V0VmlldywgdGFyZ2V0IH07IC8vIGluZGljYXRlIHRoZSBidWZmZXIgd2FzIHJlLWFsbG9jYXRlZFxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwb3NpdGlvbjtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0aWYgKG5ld1Bvc2l0aW9uID09PSAwKSAvLyBiYWlsIGFuZCBnbyB0byBhIG1zZ3BhY2sgb2JqZWN0XG5cdFx0XHRcdHJldHVybiB3cml0ZU9iamVjdChvYmplY3QpO1xuXHRcdFx0cG9zaXRpb24gPSBuZXdQb3NpdGlvbjtcblx0XHR9O1xuXHR9XG5cdHVzZUJ1ZmZlcihidWZmZXIpIHtcblx0XHQvLyB0aGlzIG1lYW5zIHdlIGFyZSBmaW5pc2hlZCB1c2luZyBvdXIgb3duIGJ1ZmZlciBhbmQgd2UgY2FuIHdyaXRlIG92ZXIgaXQgc2FmZWx5XG5cdFx0dGFyZ2V0ID0gYnVmZmVyO1xuXHRcdHRhcmdldC5kYXRhVmlldyB8fCAodGFyZ2V0LmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHRhcmdldC5idWZmZXIsIHRhcmdldC5ieXRlT2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aCkpO1xuXHRcdHBvc2l0aW9uID0gMDtcblx0fVxuXHRzZXQgcG9zaXRpb24gKHZhbHVlKSB7XG5cdFx0cG9zaXRpb24gPSB2YWx1ZTtcblx0fVxuXHRnZXQgcG9zaXRpb24oKSB7XG5cdFx0cmV0dXJuIHBvc2l0aW9uO1xuXHR9XG5cdGNsZWFyU2hhcmVkRGF0YSgpIHtcblx0XHRpZiAodGhpcy5zdHJ1Y3R1cmVzKVxuXHRcdFx0dGhpcy5zdHJ1Y3R1cmVzID0gW107XG5cdFx0aWYgKHRoaXMudHlwZWRTdHJ1Y3RzKVxuXHRcdFx0dGhpcy50eXBlZFN0cnVjdHMgPSBbXTtcblx0fVxufVxuXG5leHRlbnNpb25DbGFzc2VzID0gWyBEYXRlLCBTZXQsIEVycm9yLCBSZWdFeHAsIEFycmF5QnVmZmVyLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheS5wcm90b3R5cGUpLmNvbnN0cnVjdG9yIC8qVHlwZWRBcnJheSovLCBDMVR5cGUgXTtcbmV4dGVuc2lvbnMgPSBbe1xuXHRwYWNrKGRhdGUsIGFsbG9jYXRlRm9yV3JpdGUsIHBhY2spIHtcblx0XHRsZXQgc2Vjb25kcyA9IGRhdGUuZ2V0VGltZSgpIC8gMTAwMDtcblx0XHRpZiAoKHRoaXMudXNlVGltZXN0YW1wMzIgfHwgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSA9PT0gMCkgJiYgc2Vjb25kcyA+PSAwICYmIHNlY29uZHMgPCAweDEwMDAwMDAwMCkge1xuXHRcdFx0Ly8gVGltZXN0YW1wIDMyXG5cdFx0XHRsZXQgeyB0YXJnZXQsIHRhcmdldFZpZXcsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUoNik7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ2O1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhmZjtcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBzZWNvbmRzKTtcblx0XHR9IGVsc2UgaWYgKHNlY29uZHMgPiAwICYmIHNlY29uZHMgPCAweDEwMDAwMDAwMCkge1xuXHRcdFx0Ly8gVGltZXN0YW1wIDY0XG5cdFx0XHRsZXQgeyB0YXJnZXQsIHRhcmdldFZpZXcsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUoMTApO1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkNztcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZmY7XG5cdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihwb3NpdGlvbiwgZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSAqIDQwMDAwMDAgKyAoKHNlY29uZHMgLyAxMDAwIC8gMHgxMDAwMDAwMDApID4+IDApKTtcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uICsgNCwgc2Vjb25kcyk7XG5cdFx0fSBlbHNlIGlmIChpc05hTihzZWNvbmRzKSkge1xuXHRcdFx0aWYgKHRoaXMub25JbnZhbGlkRGF0ZSkge1xuXHRcdFx0XHRhbGxvY2F0ZUZvcldyaXRlKDApO1xuXHRcdFx0XHRyZXR1cm4gcGFjayh0aGlzLm9uSW52YWxpZERhdGUoKSlcblx0XHRcdH1cblx0XHRcdC8vIEludGVudGlvbmFsbHkgaW52YWxpZCB0aW1lc3RhbXBcblx0XHRcdGxldCB7IHRhcmdldCwgdGFyZ2V0VmlldywgcG9zaXRpb259ID0gYWxsb2NhdGVGb3JXcml0ZSgzKTtcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4ZDQ7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGZmO1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhmZjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVGltZXN0YW1wIDk2XG5cdFx0XHRsZXQgeyB0YXJnZXQsIHRhcmdldFZpZXcsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUoMTUpO1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjNztcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDEyO1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhmZjtcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBkYXRlLmdldE1pbGxpc2Vjb25kcygpICogMTAwMDAwMCk7XG5cdFx0XHR0YXJnZXRWaWV3LnNldEJpZ0ludDY0KHBvc2l0aW9uICsgNCwgQmlnSW50KE1hdGguZmxvb3Ioc2Vjb25kcykpKTtcblx0XHR9XG5cdH1cbn0sIHtcblx0cGFjayhzZXQsIGFsbG9jYXRlRm9yV3JpdGUsIHBhY2spIHtcblx0XHRpZiAodGhpcy5zZXRBc0VtcHR5T2JqZWN0KSB7XG5cdFx0XHRhbGxvY2F0ZUZvcldyaXRlKDApO1xuXHRcdFx0cmV0dXJuIHBhY2soe30pXG5cdFx0fVxuXHRcdGxldCBhcnJheSA9IEFycmF5LmZyb20oc2V0KTtcblx0XHRsZXQgeyB0YXJnZXQsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUodGhpcy5tb3JlVHlwZXMgPyAzIDogMCk7XG5cdFx0aWYgKHRoaXMubW9yZVR5cGVzKSB7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0O1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg3MzsgLy8gJ3MnIGZvciBTZXRcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDA7XG5cdFx0fVxuXHRcdHBhY2soYXJyYXkpO1xuXHR9XG59LCB7XG5cdHBhY2soZXJyb3IsIGFsbG9jYXRlRm9yV3JpdGUsIHBhY2spIHtcblx0XHRsZXQgeyB0YXJnZXQsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUodGhpcy5tb3JlVHlwZXMgPyAzIDogMCk7XG5cdFx0aWYgKHRoaXMubW9yZVR5cGVzKSB7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0O1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg2NTsgLy8gJ2UnIGZvciBlcnJvclxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMDtcblx0XHR9XG5cdFx0cGFjayhbIGVycm9yLm5hbWUsIGVycm9yLm1lc3NhZ2UsIGVycm9yLmNhdXNlIF0pO1xuXHR9XG59LCB7XG5cdHBhY2socmVnZXgsIGFsbG9jYXRlRm9yV3JpdGUsIHBhY2spIHtcblx0XHRsZXQgeyB0YXJnZXQsIHBvc2l0aW9ufSA9IGFsbG9jYXRlRm9yV3JpdGUodGhpcy5tb3JlVHlwZXMgPyAzIDogMCk7XG5cdFx0aWYgKHRoaXMubW9yZVR5cGVzKSB7XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0O1xuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg3ODsgLy8gJ3gnIGZvciByZWdlWHBcblx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDA7XG5cdFx0fVxuXHRcdHBhY2soWyByZWdleC5zb3VyY2UsIHJlZ2V4LmZsYWdzIF0pO1xuXHR9XG59LCB7XG5cdHBhY2soYXJyYXlCdWZmZXIsIGFsbG9jYXRlRm9yV3JpdGUpIHtcblx0XHRpZiAodGhpcy5tb3JlVHlwZXMpXG5cdFx0XHR3cml0ZUV4dEJ1ZmZlcihhcnJheUJ1ZmZlciwgMHgxMCwgYWxsb2NhdGVGb3JXcml0ZSk7XG5cdFx0ZWxzZVxuXHRcdFx0d3JpdGVCdWZmZXIoaGFzTm9kZUJ1ZmZlciQxID8gQnVmZmVyLmZyb20oYXJyYXlCdWZmZXIpIDogbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpLCBhbGxvY2F0ZUZvcldyaXRlKTtcblx0fVxufSwge1xuXHRwYWNrKHR5cGVkQXJyYXksIGFsbG9jYXRlRm9yV3JpdGUpIHtcblx0XHRsZXQgY29uc3RydWN0b3IgPSB0eXBlZEFycmF5LmNvbnN0cnVjdG9yO1xuXHRcdGlmIChjb25zdHJ1Y3RvciAhPT0gQnl0ZUFycmF5ICYmIHRoaXMubW9yZVR5cGVzKVxuXHRcdFx0d3JpdGVFeHRCdWZmZXIodHlwZWRBcnJheSwgdHlwZWRBcnJheXMuaW5kZXhPZihjb25zdHJ1Y3Rvci5uYW1lKSwgYWxsb2NhdGVGb3JXcml0ZSk7XG5cdFx0ZWxzZVxuXHRcdFx0d3JpdGVCdWZmZXIodHlwZWRBcnJheSwgYWxsb2NhdGVGb3JXcml0ZSk7XG5cdH1cbn0sIHtcblx0cGFjayhjMSwgYWxsb2NhdGVGb3JXcml0ZSkgeyAvLyBzcGVjaWZpYyAweEMxIG9iamVjdFxuXHRcdGxldCB7IHRhcmdldCwgcG9zaXRpb259ID0gYWxsb2NhdGVGb3JXcml0ZSgxKTtcblx0XHR0YXJnZXRbcG9zaXRpb25dID0gMHhjMTtcblx0fVxufV07XG5cbmZ1bmN0aW9uIHdyaXRlRXh0QnVmZmVyKHR5cGVkQXJyYXksIHR5cGUsIGFsbG9jYXRlRm9yV3JpdGUsIGVuY29kZSkge1xuXHRsZXQgbGVuZ3RoID0gdHlwZWRBcnJheS5ieXRlTGVuZ3RoO1xuXHRpZiAobGVuZ3RoICsgMSA8IDB4MTAwKSB7XG5cdFx0dmFyIHsgdGFyZ2V0LCBwb3NpdGlvbiB9ID0gYWxsb2NhdGVGb3JXcml0ZSg0ICsgbGVuZ3RoKTtcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM3O1xuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCArIDE7XG5cdH0gZWxzZSBpZiAobGVuZ3RoICsgMSA8IDB4MTAwMDApIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uIH0gPSBhbGxvY2F0ZUZvcldyaXRlKDUgKyBsZW5ndGgpO1xuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzg7XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKGxlbmd0aCArIDEpID4+IDg7XG5cdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKGxlbmd0aCArIDEpICYgMHhmZjtcblx0fSBlbHNlIHtcblx0XHR2YXIgeyB0YXJnZXQsIHBvc2l0aW9uLCB0YXJnZXRWaWV3IH0gPSBhbGxvY2F0ZUZvcldyaXRlKDcgKyBsZW5ndGgpO1xuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IDB4Yzk7XG5cdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIGxlbmd0aCArIDEpOyAvLyBwbHVzIG9uZSBmb3IgdGhlIHR5cGUgYnl0ZVxuXHRcdHBvc2l0aW9uICs9IDQ7XG5cdH1cblx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHg3NDsgLy8gXCJ0XCIgZm9yIHR5cGVkIGFycmF5XG5cdHRhcmdldFtwb3NpdGlvbisrXSA9IHR5cGU7XG5cdGlmICghdHlwZWRBcnJheS5idWZmZXIpIHR5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheSh0eXBlZEFycmF5KTtcblx0dGFyZ2V0LnNldChuZXcgVWludDhBcnJheSh0eXBlZEFycmF5LmJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5LmJ5dGVMZW5ndGgpLCBwb3NpdGlvbik7XG59XG5mdW5jdGlvbiB3cml0ZUJ1ZmZlcihidWZmZXIsIGFsbG9jYXRlRm9yV3JpdGUpIHtcblx0bGV0IGxlbmd0aCA9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuXHR2YXIgdGFyZ2V0LCBwb3NpdGlvbjtcblx0aWYgKGxlbmd0aCA8IDB4MTAwKSB7XG5cdFx0dmFyIHsgdGFyZ2V0LCBwb3NpdGlvbiB9ID0gYWxsb2NhdGVGb3JXcml0ZShsZW5ndGggKyAyKTtcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM0O1xuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aDtcblx0fSBlbHNlIGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0dmFyIHsgdGFyZ2V0LCBwb3NpdGlvbiB9ID0gYWxsb2NhdGVGb3JXcml0ZShsZW5ndGggKyAzKTtcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM1O1xuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCA+PiA4O1xuXHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCAmIDB4ZmY7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIHsgdGFyZ2V0LCBwb3NpdGlvbiwgdGFyZ2V0VmlldyB9ID0gYWxsb2NhdGVGb3JXcml0ZShsZW5ndGggKyA1KTtcblx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM2O1xuXHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCBsZW5ndGgpO1xuXHRcdHBvc2l0aW9uICs9IDQ7XG5cdH1cblx0dGFyZ2V0LnNldChidWZmZXIsIHBvc2l0aW9uKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVFeHRlbnNpb25EYXRhKHJlc3VsdCwgdGFyZ2V0LCBwb3NpdGlvbiwgdHlwZSkge1xuXHRsZXQgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblx0c3dpdGNoIChsZW5ndGgpIHtcblx0XHRjYXNlIDE6XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ0O1xuXHRcdFx0YnJlYWtcblx0XHRjYXNlIDI6XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ1O1xuXHRcdFx0YnJlYWtcblx0XHRjYXNlIDQ6XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ2O1xuXHRcdFx0YnJlYWtcblx0XHRjYXNlIDg6XG5cdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGQ3O1xuXHRcdFx0YnJlYWtcblx0XHRjYXNlIDE2OlxuXHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhkODtcblx0XHRcdGJyZWFrXG5cdFx0ZGVmYXVsdDpcblx0XHRcdGlmIChsZW5ndGggPCAweDEwMCkge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM3O1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGg7XG5cdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gMHhjODtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gbGVuZ3RoID4+IDg7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCAmIDB4ZmY7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSAweGM5O1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSBsZW5ndGggPj4gMjQ7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IChsZW5ndGggPj4gMTYpICYgMHhmZjtcblx0XHRcdFx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gKGxlbmd0aCA+PiA4KSAmIDB4ZmY7XG5cdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IGxlbmd0aCAmIDB4ZmY7XG5cdFx0XHR9XG5cdH1cblx0dGFyZ2V0W3Bvc2l0aW9uKytdID0gdHlwZTtcblx0dGFyZ2V0LnNldChyZXN1bHQsIHBvc2l0aW9uKTtcblx0cG9zaXRpb24gKz0gbGVuZ3RoO1xuXHRyZXR1cm4gcG9zaXRpb25cbn1cblxuZnVuY3Rpb24gaW5zZXJ0SWRzKHNlcmlhbGl6ZWQsIGlkc1RvSW5zZXJ0KSB7XG5cdC8vIGluc2VydCB0aGUgaWRzIHRoYXQgbmVlZCB0byBiZSByZWZlcmVuY2VkIGZvciBzdHJ1Y3R1cmVkIGNsb25lc1xuXHRsZXQgbmV4dElkO1xuXHRsZXQgZGlzdGFuY2VUb01vdmUgPSBpZHNUb0luc2VydC5sZW5ndGggKiA2O1xuXHRsZXQgbGFzdEVuZCA9IHNlcmlhbGl6ZWQubGVuZ3RoIC0gZGlzdGFuY2VUb01vdmU7XG5cdHdoaWxlIChuZXh0SWQgPSBpZHNUb0luc2VydC5wb3AoKSkge1xuXHRcdGxldCBvZmZzZXQgPSBuZXh0SWQub2Zmc2V0O1xuXHRcdGxldCBpZCA9IG5leHRJZC5pZDtcblx0XHRzZXJpYWxpemVkLmNvcHlXaXRoaW4ob2Zmc2V0ICsgZGlzdGFuY2VUb01vdmUsIG9mZnNldCwgbGFzdEVuZCk7XG5cdFx0ZGlzdGFuY2VUb01vdmUgLT0gNjtcblx0XHRsZXQgcG9zaXRpb24gPSBvZmZzZXQgKyBkaXN0YW5jZVRvTW92ZTtcblx0XHRzZXJpYWxpemVkW3Bvc2l0aW9uKytdID0gMHhkNjtcblx0XHRzZXJpYWxpemVkW3Bvc2l0aW9uKytdID0gMHg2OTsgLy8gJ2knXG5cdFx0c2VyaWFsaXplZFtwb3NpdGlvbisrXSA9IGlkID4+IDI0O1xuXHRcdHNlcmlhbGl6ZWRbcG9zaXRpb24rK10gPSAoaWQgPj4gMTYpICYgMHhmZjtcblx0XHRzZXJpYWxpemVkW3Bvc2l0aW9uKytdID0gKGlkID4+IDgpICYgMHhmZjtcblx0XHRzZXJpYWxpemVkW3Bvc2l0aW9uKytdID0gaWQgJiAweGZmO1xuXHRcdGxhc3RFbmQgPSBvZmZzZXQ7XG5cdH1cblx0cmV0dXJuIHNlcmlhbGl6ZWRcbn1cblxuZnVuY3Rpb24gd3JpdGVCdW5kbGVzKHN0YXJ0LCBwYWNrLCBpbmNyZW1lbnRQb3NpdGlvbikge1xuXHRpZiAoYnVuZGxlZFN0cmluZ3MubGVuZ3RoID4gMCkge1xuXHRcdHRhcmdldFZpZXcuc2V0VWludDMyKGJ1bmRsZWRTdHJpbmdzLnBvc2l0aW9uICsgc3RhcnQsIHBvc2l0aW9uICsgaW5jcmVtZW50UG9zaXRpb24gLSBidW5kbGVkU3RyaW5ncy5wb3NpdGlvbiAtIHN0YXJ0KTtcblx0XHRidW5kbGVkU3RyaW5ncy5zdHJpbmdzUG9zaXRpb24gPSBwb3NpdGlvbiAtIHN0YXJ0O1xuXHRcdGxldCB3cml0ZVN0cmluZ3MgPSBidW5kbGVkU3RyaW5ncztcblx0XHRidW5kbGVkU3RyaW5ncyA9IG51bGw7XG5cdFx0cGFjayh3cml0ZVN0cmluZ3NbMF0pO1xuXHRcdHBhY2sod3JpdGVTdHJpbmdzWzFdKTtcblx0fVxufVxuXG5mdW5jdGlvbiBhZGRFeHRlbnNpb24oZXh0ZW5zaW9uKSB7XG5cdGlmIChleHRlbnNpb24uQ2xhc3MpIHtcblx0XHRpZiAoIWV4dGVuc2lvbi5wYWNrICYmICFleHRlbnNpb24ud3JpdGUpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0V4dGVuc2lvbiBoYXMgbm8gcGFjayBvciB3cml0ZSBmdW5jdGlvbicpXG5cdFx0aWYgKGV4dGVuc2lvbi5wYWNrICYmICFleHRlbnNpb24udHlwZSlcblx0XHRcdHRocm93IG5ldyBFcnJvcignRXh0ZW5zaW9uIGhhcyBubyB0eXBlIChudW1lcmljIGNvZGUgdG8gaWRlbnRpZnkgdGhlIGV4dGVuc2lvbiknKVxuXHRcdGV4dGVuc2lvbkNsYXNzZXMudW5zaGlmdChleHRlbnNpb24uQ2xhc3MpO1xuXHRcdGV4dGVuc2lvbnMudW5zaGlmdChleHRlbnNpb24pO1xuXHR9XG5cdGFkZEV4dGVuc2lvbiQxKGV4dGVuc2lvbik7XG59XG5mdW5jdGlvbiBwcmVwYXJlU3RydWN0dXJlcyQxKHN0cnVjdHVyZXMsIHBhY2tyKSB7XG5cdHN0cnVjdHVyZXMuaXNDb21wYXRpYmxlID0gKGV4aXN0aW5nU3RydWN0dXJlcykgPT4ge1xuXHRcdGxldCBjb21wYXRpYmxlID0gIWV4aXN0aW5nU3RydWN0dXJlcyB8fCAoKHBhY2tyLmxhc3ROYW1lZFN0cnVjdHVyZXNMZW5ndGggfHwgMCkgPT09IGV4aXN0aW5nU3RydWN0dXJlcy5sZW5ndGgpO1xuXHRcdGlmICghY29tcGF0aWJsZSkgLy8gd2Ugd2FudCB0byBtZXJnZSB0aGVzZSBleGlzdGluZyBzdHJ1Y3R1cmVzIGltbWVkaWF0ZWx5IHNpbmNlIHdlIGFscmVhZHkgaGF2ZSBpdCBhbmQgd2UgYXJlIGluIHRoZSByaWdodCB0cmFuc2FjdGlvblxuXHRcdFx0cGFja3IuX21lcmdlU3RydWN0dXJlcyhleGlzdGluZ1N0cnVjdHVyZXMpO1xuXHRcdHJldHVybiBjb21wYXRpYmxlO1xuXHR9O1xuXHRyZXR1cm4gc3RydWN0dXJlc1xufVxuZnVuY3Rpb24gc2V0V3JpdGVTdHJ1Y3RTbG90cyh3cml0ZVNsb3RzLCBtYWtlU3RydWN0dXJlcykge1xuXHR3cml0ZVN0cnVjdFNsb3RzID0gd3JpdGVTbG90cztcblx0cHJlcGFyZVN0cnVjdHVyZXMkMSA9IG1ha2VTdHJ1Y3R1cmVzO1xufVxuXG5sZXQgZGVmYXVsdFBhY2tyID0gbmV3IFBhY2tyKHsgdXNlUmVjb3JkczogZmFsc2UgfSk7XG5jb25zdCBwYWNrID0gZGVmYXVsdFBhY2tyLnBhY2s7XG5jb25zdCBlbmNvZGUgPSBkZWZhdWx0UGFja3IucGFjaztcbmNvbnN0IEVuY29kZXIgPSBQYWNrcjtcbmNvbnN0IHsgTkVWRVIsIEFMV0FZUywgREVDSU1BTF9ST1VORCwgREVDSU1BTF9GSVQgfSA9IEZMT0FUMzJfT1BUSU9OUztcbmNvbnN0IFJFVVNFX0JVRkZFUl9NT0RFID0gNTEyO1xuY29uc3QgUkVTRVRfQlVGRkVSX01PREUgPSAxMDI0O1xuY29uc3QgUkVTRVJWRV9TVEFSVF9TUEFDRSA9IDIwNDg7XG5cbmNvbnN0IEFTQ0lJID0gMzsgLy8gdGhlIE1JQmVudW0gZnJvbSBodHRwczovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9jaGFyYWN0ZXItc2V0cy9jaGFyYWN0ZXItc2V0cy54aHRtbCAoYW5kIG90aGVyIGNoYXJhY3RlciBlbmNvZGluZ3MgY291bGQgYmUgcmVmZXJlbmNlZCBieSBNSUJlbnVtKVxuY29uc3QgTlVNQkVSID0gMDtcbmNvbnN0IFVURjggPSAyO1xuY29uc3QgT0JKRUNUX0RBVEEgPSAxO1xuY29uc3QgREFURSA9IDE2O1xuY29uc3QgVFlQRV9OQU1FUyA9IFsnbnVtJywgJ29iamVjdCcsICdzdHJpbmcnLCAnYXNjaWknXTtcblRZUEVfTkFNRVNbREFURV0gPSAnZGF0ZSc7XG5jb25zdCBmbG9hdDMySGVhZGVycyA9IFtmYWxzZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIGZhbHNlLCB0cnVlLCB0cnVlLCBmYWxzZV07XG5sZXQgZXZhbFN1cHBvcnRlZDtcbnRyeSB7XG5cdG5ldyBGdW5jdGlvbignJyk7XG5cdGV2YWxTdXBwb3J0ZWQgPSB0cnVlO1xufSBjYXRjaChlcnJvcikge1xuXHQvLyBpZiBldmFsIHZhcmlhbnRzIGFyZSBub3Qgc3VwcG9ydGVkLCBkbyBub3QgY3JlYXRlIGlubGluZSBvYmplY3QgcmVhZGVycyBldmVyXG59XG5cbmxldCB1cGRhdGVkUG9zaXRpb247XG5jb25zdCBoYXNOb2RlQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCc7XG5sZXQgdGV4dEVuY29kZXIsIGN1cnJlbnRTb3VyY2U7XG50cnkge1xuXHR0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xufSBjYXRjaCAoZXJyb3IpIHt9XG5jb25zdCBlbmNvZGVVdGY4ID0gaGFzTm9kZUJ1ZmZlciA/IGZ1bmN0aW9uKHRhcmdldCwgc3RyaW5nLCBwb3NpdGlvbikge1xuXHRyZXR1cm4gdGFyZ2V0LnV0ZjhXcml0ZShzdHJpbmcsIHBvc2l0aW9uLCB0YXJnZXQuYnl0ZUxlbmd0aCAtIHBvc2l0aW9uKVxufSA6ICh0ZXh0RW5jb2RlciAmJiB0ZXh0RW5jb2Rlci5lbmNvZGVJbnRvKSA/XG5cdGZ1bmN0aW9uKHRhcmdldCwgc3RyaW5nLCBwb3NpdGlvbikge1xuXHRcdHJldHVybiB0ZXh0RW5jb2Rlci5lbmNvZGVJbnRvKHN0cmluZywgdGFyZ2V0LnN1YmFycmF5KHBvc2l0aW9uKSkud3JpdHRlblxuXHR9IDogZmFsc2U7XG5zZXRXcml0ZVN0cnVjdFNsb3RzKHdyaXRlU3RydWN0LCBwcmVwYXJlU3RydWN0dXJlcyk7XG5mdW5jdGlvbiB3cml0ZVN0cnVjdChvYmplY3QsIHRhcmdldCwgZW5jb2RpbmdTdGFydCwgcG9zaXRpb24sIHN0cnVjdHVyZXMsIG1ha2VSb29tLCBwYWNrLCBwYWNrcikge1xuXHRsZXQgdHlwZWRTdHJ1Y3RzID0gcGFja3IudHlwZWRTdHJ1Y3RzIHx8IChwYWNrci50eXBlZFN0cnVjdHMgPSBbXSk7XG5cdC8vIG5vdGUgdGhhdCB3ZSByZWx5IG9uIHBhY2suanMgdG8gbG9hZCBzdG9yZWQgc3RydWN0dXJlcyBiZWZvcmUgd2UgZ2V0IHRvIHRoaXMgcG9pbnRcblx0bGV0IHRhcmdldFZpZXcgPSB0YXJnZXQuZGF0YVZpZXc7XG5cdGxldCByZWZzU3RhcnRQb3NpdGlvbiA9ICh0eXBlZFN0cnVjdHMubGFzdFN0cmluZ1N0YXJ0IHx8IDEwMCkgKyBwb3NpdGlvbjtcblx0bGV0IHNhZmVFbmQgPSB0YXJnZXQubGVuZ3RoIC0gMTA7XG5cdGxldCBzdGFydCA9IHBvc2l0aW9uO1xuXHRpZiAocG9zaXRpb24gPiBzYWZlRW5kKSB7XG5cdFx0dGFyZ2V0ID0gbWFrZVJvb20ocG9zaXRpb24pO1xuXHRcdHRhcmdldFZpZXcgPSB0YXJnZXQuZGF0YVZpZXc7XG5cdFx0cG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRzdGFydCAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdHJlZnNTdGFydFBvc2l0aW9uIC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0ZW5jb2RpbmdTdGFydCA9IDA7XG5cdFx0c2FmZUVuZCA9IHRhcmdldC5sZW5ndGggLSAxMDtcblx0fVxuXG5cdGxldCByZWZPZmZzZXQsIHJlZlBvc2l0aW9uID0gcmVmc1N0YXJ0UG9zaXRpb247XG5cblx0bGV0IHRyYW5zaXRpb24gPSB0eXBlZFN0cnVjdHMudHJhbnNpdGlvbnMgfHwgKHR5cGVkU3RydWN0cy50cmFuc2l0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXHRsZXQgbmV4dElkID0gdHlwZWRTdHJ1Y3RzLm5leHRJZCB8fCB0eXBlZFN0cnVjdHMubGVuZ3RoO1xuXHRsZXQgaGVhZGVyU2l6ZSA9XG5cdFx0bmV4dElkIDwgMHhmID8gMSA6XG5cdFx0XHRuZXh0SWQgPCAweGYwID8gMiA6XG5cdFx0XHRcdG5leHRJZCA8IDB4ZjAwMCA/IDMgOlxuXHRcdFx0XHRcdG5leHRJZCA8IDB4ZjAwMDAwID8gNCA6IDA7XG5cdGlmIChoZWFkZXJTaXplID09PSAwKVxuXHRcdHJldHVybiAwO1xuXHRwb3NpdGlvbiArPSBoZWFkZXJTaXplO1xuXHRsZXQgcXVldWVkUmVmZXJlbmNlcyA9IFtdO1xuXHRsZXQgdXNlZEFzY2lpMDtcblx0bGV0IGtleUluZGV4ID0gMDtcblx0Zm9yIChsZXQga2V5IGluIG9iamVjdCkge1xuXHRcdGxldCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXHRcdGxldCBuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XTtcblx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHR0cmFuc2l0aW9uW2tleV0gPSBuZXh0VHJhbnNpdGlvbiA9IHtcblx0XHRcdFx0a2V5LFxuXHRcdFx0XHRwYXJlbnQ6IHRyYW5zaXRpb24sXG5cdFx0XHRcdGVudW1lcmF0aW9uT2Zmc2V0OiAwLFxuXHRcdFx0XHRhc2NpaTA6IG51bGwsXG5cdFx0XHRcdGFzY2lpODogbnVsbCxcblx0XHRcdFx0bnVtODogbnVsbCxcblx0XHRcdFx0c3RyaW5nMTY6IG51bGwsXG5cdFx0XHRcdG9iamVjdDE2OiBudWxsLFxuXHRcdFx0XHRudW0zMjogbnVsbCxcblx0XHRcdFx0ZmxvYXQ2NDogbnVsbCxcblx0XHRcdFx0ZGF0ZTY0OiBudWxsXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRpZiAocG9zaXRpb24gPiBzYWZlRW5kKSB7XG5cdFx0XHR0YXJnZXQgPSBtYWtlUm9vbShwb3NpdGlvbik7XG5cdFx0XHR0YXJnZXRWaWV3ID0gdGFyZ2V0LmRhdGFWaWV3O1xuXHRcdFx0cG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdHN0YXJ0IC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0XHRyZWZzU3RhcnRQb3NpdGlvbiAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0cmVmUG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdGVuY29kaW5nU3RhcnQgPSAwO1xuXHRcdFx0c2FmZUVuZCA9IHRhcmdldC5sZW5ndGggLSAxMDtcblx0XHR9XG5cdFx0c3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcblx0XHRcdGNhc2UgJ251bWJlcic6XG5cdFx0XHRcdGxldCBudW1iZXIgPSB2YWx1ZTtcblx0XHRcdFx0Ly8gZmlyc3QgY2hlY2sgdG8gc2VlIGlmIHdlIGFyZSB1c2luZyBhIGxvdCBvZiBpZHMgYW5kIHNob3VsZCBkZWZhdWx0IHRvIHdpZGUvY29tbW9uIGZvcm1hdFxuXHRcdFx0XHRpZiAobmV4dElkIDwgMjAwIHx8ICFuZXh0VHJhbnNpdGlvbi5udW02NCkge1xuXHRcdFx0XHRcdGlmIChudW1iZXIgPj4gMCA9PT0gbnVtYmVyICYmIG51bWJlciA8IDB4MjAwMDAwMDAgJiYgbnVtYmVyID4gLTB4MWYwMDAwMDApIHtcblx0XHRcdFx0XHRcdGlmIChudW1iZXIgPCAweGY2ICYmIG51bWJlciA+PSAwICYmIChuZXh0VHJhbnNpdGlvbi5udW04ICYmICEobmV4dElkID4gMjAwICYmIG5leHRUcmFuc2l0aW9uLm51bTMyKSB8fCBudW1iZXIgPCAweDIwICYmICFuZXh0VHJhbnNpdGlvbi5udW0zMikpIHtcblx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm51bTggfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIE5VTUJFUiwgMSk7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IG51bWJlcjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5udW0zMiB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgTlVNQkVSLCA0KTtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIG51bWJlciwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG51bWJlciA8IDB4MTAwMDAwMDAwICYmIG51bWJlciA+PSAtMHg4MDAwMDAwMCkge1xuXHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRGbG9hdDMyKHBvc2l0aW9uLCBudW1iZXIsIHRydWUpO1xuXHRcdFx0XHRcdFx0aWYgKGZsb2F0MzJIZWFkZXJzW3RhcmdldFtwb3NpdGlvbiArIDNdID4+PiA1XSkge1xuXHRcdFx0XHRcdFx0XHRsZXQgeFNoaWZ0ZWQ7XG5cdFx0XHRcdFx0XHRcdC8vIHRoaXMgY2hlY2tzIGZvciByb3VuZGluZyBvZiBudW1iZXJzIHRoYXQgd2VyZSBlbmNvZGVkIGluIDMyLWJpdCBmbG9hdCB0byBuZWFyZXN0IHNpZ25pZmljYW50IGRlY2ltYWwgZGlnaXQgdGhhdCBjb3VsZCBiZSBwcmVzZXJ2ZWRcblx0XHRcdFx0XHRcdFx0aWYgKCgoeFNoaWZ0ZWQgPSBudW1iZXIgKiBtdWx0MTBbKCh0YXJnZXRbcG9zaXRpb24gKyAzXSAmIDB4N2YpIDw8IDEpIHwgKHRhcmdldFtwb3NpdGlvbiArIDJdID4+IDcpXSkgPj4gMCkgPT09IHhTaGlmdGVkKSB7XG5cdFx0XHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm51bTMyIHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBOVU1CRVIsIDQpO1xuXHRcdFx0XHRcdFx0XHRcdHBvc2l0aW9uICs9IDQ7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm51bTY0IHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBOVU1CRVIsIDgpO1xuXHRcdFx0XHR0YXJnZXRWaWV3LnNldEZsb2F0NjQocG9zaXRpb24sIG51bWJlciwgdHJ1ZSk7XG5cdFx0XHRcdHBvc2l0aW9uICs9IDg7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnc3RyaW5nJzpcblx0XHRcdFx0bGV0IHN0ckxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdFx0cmVmT2Zmc2V0ID0gcmVmUG9zaXRpb24gLSByZWZzU3RhcnRQb3NpdGlvbjtcblx0XHRcdFx0aWYgKChzdHJMZW5ndGggPDwgMikgKyByZWZQb3NpdGlvbiA+IHNhZmVFbmQpIHtcblx0XHRcdFx0XHR0YXJnZXQgPSBtYWtlUm9vbSgoc3RyTGVuZ3RoIDw8IDIpICsgcmVmUG9zaXRpb24pO1xuXHRcdFx0XHRcdHRhcmdldFZpZXcgPSB0YXJnZXQuZGF0YVZpZXc7XG5cdFx0XHRcdFx0cG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdFx0XHRzdGFydCAtPSBlbmNvZGluZ1N0YXJ0O1xuXHRcdFx0XHRcdHJlZnNTdGFydFBvc2l0aW9uIC09IGVuY29kaW5nU3RhcnQ7XG5cdFx0XHRcdFx0cmVmUG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdFx0XHRlbmNvZGluZ1N0YXJ0ID0gMDtcblx0XHRcdFx0XHRzYWZlRW5kID0gdGFyZ2V0Lmxlbmd0aCAtIDEwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzdHJMZW5ndGggPiAoKDB4ZmYwMCArIHJlZk9mZnNldCkgPj4gMikpIHtcblx0XHRcdFx0XHRxdWV1ZWRSZWZlcmVuY2VzLnB1c2goa2V5LCB2YWx1ZSwgcG9zaXRpb24gLSBzdGFydCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IGlzTm90QXNjaWk7XG5cdFx0XHRcdGxldCBzdHJTdGFydCA9IHJlZlBvc2l0aW9uO1xuXHRcdFx0XHRpZiAoc3RyTGVuZ3RoIDwgMHg0MCkge1xuXHRcdFx0XHRcdGxldCBpLCBjMSwgYzI7XG5cdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IHN0ckxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjMSA9IHZhbHVlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRcdFx0XHRpZiAoYzEgPCAweDgwKSB7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChjMSA8IDB4ODAwKSB7XG5cdFx0XHRcdFx0XHRcdGlzTm90QXNjaWkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSA+PiA2IHwgMHhjMDtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzEgJiAweDNmIHwgMHg4MDtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdFx0XHRcdChjMSAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJlxuXHRcdFx0XHRcdFx0XHQoKGMyID0gdmFsdWUuY2hhckNvZGVBdChpICsgMSkpICYgMHhmYzAwKSA9PT0gMHhkYzAwXG5cdFx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdFx0aXNOb3RBc2NpaSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGMxID0gMHgxMDAwMCArICgoYzEgJiAweDAzZmYpIDw8IDEwKSArIChjMiAmIDB4MDNmZik7XG5cdFx0XHRcdFx0XHRcdGkrKztcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzEgPj4gMTggfCAweGYwO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSA+PiAxMiAmIDB4M2YgfCAweDgwO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSA+PiA2ICYgMHgzZiB8IDB4ODA7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxICYgMHgzZiB8IDB4ODA7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRpc05vdEFzY2lpID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0dGFyZ2V0W3JlZlBvc2l0aW9uKytdID0gYzEgPj4gMTIgfCAweGUwO1xuXHRcdFx0XHRcdFx0XHR0YXJnZXRbcmVmUG9zaXRpb24rK10gPSBjMSA+PiA2ICYgMHgzZiB8IDB4ODA7XG5cdFx0XHRcdFx0XHRcdHRhcmdldFtyZWZQb3NpdGlvbisrXSA9IGMxICYgMHgzZiB8IDB4ODA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlZlBvc2l0aW9uICs9IGVuY29kZVV0ZjgodGFyZ2V0LCB2YWx1ZSwgcmVmUG9zaXRpb24pO1xuXHRcdFx0XHRcdGlzTm90QXNjaWkgPSByZWZQb3NpdGlvbiAtIHN0clN0YXJ0ID4gc3RyTGVuZ3RoO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZWZPZmZzZXQgPCAweGEwIHx8IChyZWZPZmZzZXQgPCAweGY2ICYmIChuZXh0VHJhbnNpdGlvbi5hc2NpaTggfHwgbmV4dFRyYW5zaXRpb24uc3RyaW5nOCkpKSB7XG5cdFx0XHRcdFx0Ly8gc2hvcnQgc3RyaW5nc1xuXHRcdFx0XHRcdGlmIChpc05vdEFzY2lpKSB7XG5cdFx0XHRcdFx0XHRpZiAoISh0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uc3RyaW5nOCkpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHR5cGVkU3RydWN0cy5sZW5ndGggPiAxMCAmJiAodHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLmFzY2lpOCkpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyB3ZSBjYW4gc2FmZWx5IGNoYW5nZSBhc2NpaSB0byB1dGY4IGluIHBsYWNlIHNpbmNlIHRoZXkgYXJlIGNvbXBhdGlibGVcblx0XHRcdFx0XHRcdFx0XHR0cmFuc2l0aW9uLl9fdHlwZSA9IFVURjg7XG5cdFx0XHRcdFx0XHRcdFx0bmV4dFRyYW5zaXRpb24uYXNjaWk4ID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbi5zdHJpbmc4ID0gdHJhbnNpdGlvbjtcblx0XHRcdFx0XHRcdFx0XHRwYWNrKG51bGwsIDAsIHRydWUpOyAvLyBzcGVjaWFsIGNhbGwgdG8gbm90aWZ5IHRoYXQgc3RydWN0dXJlcyBoYXZlIGJlZW4gdXBkYXRlZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgVVRGOCwgMSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHJlZk9mZnNldCA9PT0gMCAmJiAhdXNlZEFzY2lpMCkge1xuXHRcdFx0XHRcdFx0dXNlZEFzY2lpMCA9IHRydWU7XG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uYXNjaWkwIHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBBU0NJSSwgMCk7XG5cdFx0XHRcdFx0XHRicmVhazsgLy8gZG9uJ3QgaW5jcmVtZW50IHBvc2l0aW9uXG5cdFx0XHRcdFx0fS8vIGVsc2UgYXNjaWk6XG5cdFx0XHRcdFx0ZWxzZSBpZiAoISh0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uYXNjaWk4KSAmJiAhKHR5cGVkU3RydWN0cy5sZW5ndGggPiAxMCAmJiAodHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLnN0cmluZzgpKSlcblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgQVNDSUksIDEpO1xuXHRcdFx0XHRcdHRhcmdldFtwb3NpdGlvbisrXSA9IHJlZk9mZnNldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBUT0RPOiBFbmFibGUgYXNjaWkxNiBhdCBzb21lIHBvaW50LCBidXQgZ2V0IHRoZSBsb2dpYyByaWdodFxuXHRcdFx0XHRcdC8vaWYgKGlzTm90QXNjaWkpXG5cdFx0XHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uc3RyaW5nMTYgfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIFVURjgsIDIpO1xuXHRcdFx0XHRcdC8vZWxzZVxuXHRcdFx0XHRcdFx0Ly90cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24uYXNjaWkxNiB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgQVNDSUksIDIpO1xuXHRcdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDE2KHBvc2l0aW9uLCByZWZPZmZzZXQsIHRydWUpO1xuXHRcdFx0XHRcdHBvc2l0aW9uICs9IDI7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdvYmplY3QnOlxuXHRcdFx0XHRpZiAodmFsdWUpIHtcblx0XHRcdFx0XHRpZiAodmFsdWUuY29uc3RydWN0b3IgPT09IERhdGUpIHtcblx0XHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5kYXRlNjQgfHwgY3JlYXRlVHlwZVRyYW5zaXRpb24obmV4dFRyYW5zaXRpb24sIERBVEUsIDgpO1xuXHRcdFx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRGbG9hdDY0KHBvc2l0aW9uLCB2YWx1ZS5nZXRUaW1lKCksIHRydWUpO1xuXHRcdFx0XHRcdFx0cG9zaXRpb24gKz0gODtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cXVldWVkUmVmZXJlbmNlcy5wdXNoKGtleSwgdmFsdWUsIGtleUluZGV4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gZWxzZSB7IC8vIG51bGxcblx0XHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IGFueVR5cGUobmV4dFRyYW5zaXRpb24sIHBvc2l0aW9uLCB0YXJnZXRWaWV3LCAtMTApOyAvLyBtYXRjaCBDQk9SIHdpdGggdGhpc1xuXHRcdFx0XHRcdGlmIChuZXh0VHJhbnNpdGlvbikge1xuXHRcdFx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uO1xuXHRcdFx0XHRcdFx0cG9zaXRpb24gPSB1cGRhdGVkUG9zaXRpb247XG5cdFx0XHRcdFx0fSBlbHNlIHF1ZXVlZFJlZmVyZW5jZXMucHVzaChrZXksIHZhbHVlLCBrZXlJbmRleCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdib29sZWFuJzpcblx0XHRcdFx0dHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm51bTggfHwgbmV4dFRyYW5zaXRpb24uYXNjaWk4IHx8IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBOVU1CRVIsIDEpO1xuXHRcdFx0XHR0YXJnZXRbcG9zaXRpb24rK10gPSB2YWx1ZSA/IDB4ZjkgOiAweGY4OyAvLyBtYXRjaCBDQk9SIHdpdGggdGhlc2Vcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd1bmRlZmluZWQnOlxuXHRcdFx0XHRuZXh0VHJhbnNpdGlvbiA9IGFueVR5cGUobmV4dFRyYW5zaXRpb24sIHBvc2l0aW9uLCB0YXJnZXRWaWV3LCAtOSk7IC8vIG1hdGNoIENCT1Igd2l0aCB0aGlzXG5cdFx0XHRcdGlmIChuZXh0VHJhbnNpdGlvbikge1xuXHRcdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbjtcblx0XHRcdFx0XHRwb3NpdGlvbiA9IHVwZGF0ZWRQb3NpdGlvbjtcblx0XHRcdFx0fSBlbHNlIHF1ZXVlZFJlZmVyZW5jZXMucHVzaChrZXksIHZhbHVlLCBrZXlJbmRleCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0cXVldWVkUmVmZXJlbmNlcy5wdXNoKGtleSwgdmFsdWUsIGtleUluZGV4KTtcblx0XHR9XG5cdFx0a2V5SW5kZXgrKztcblx0fVxuXG5cdGZvciAobGV0IGkgPSAwLCBsID0gcXVldWVkUmVmZXJlbmNlcy5sZW5ndGg7IGkgPCBsOykge1xuXHRcdGxldCBrZXkgPSBxdWV1ZWRSZWZlcmVuY2VzW2krK107XG5cdFx0bGV0IHZhbHVlID0gcXVldWVkUmVmZXJlbmNlc1tpKytdO1xuXHRcdGxldCBwcm9wZXJ0eUluZGV4ID0gcXVldWVkUmVmZXJlbmNlc1tpKytdO1xuXHRcdGxldCBuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25ba2V5XTtcblx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHR0cmFuc2l0aW9uW2tleV0gPSBuZXh0VHJhbnNpdGlvbiA9IHtcblx0XHRcdFx0a2V5LFxuXHRcdFx0XHRwYXJlbnQ6IHRyYW5zaXRpb24sXG5cdFx0XHRcdGVudW1lcmF0aW9uT2Zmc2V0OiBwcm9wZXJ0eUluZGV4IC0ga2V5SW5kZXgsXG5cdFx0XHRcdGFzY2lpMDogbnVsbCxcblx0XHRcdFx0YXNjaWk4OiBudWxsLFxuXHRcdFx0XHRudW04OiBudWxsLFxuXHRcdFx0XHRzdHJpbmcxNjogbnVsbCxcblx0XHRcdFx0b2JqZWN0MTY6IG51bGwsXG5cdFx0XHRcdG51bTMyOiBudWxsLFxuXHRcdFx0XHRmbG9hdDY0OiBudWxsXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRsZXQgbmV3UG9zaXRpb247XG5cdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHQvKmlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7IC8vIFRPRE86IHdlIGNvdWxkIHJlLWVuYWJsZSBsb25nIHN0cmluZ3Ncblx0XHRcdFx0aWYgKHBvc2l0aW9uICsgdmFsdWUubGVuZ3RoICogMyA+IHNhZmVFbmQpIHtcblx0XHRcdFx0XHR0YXJnZXQgPSBtYWtlUm9vbShwb3NpdGlvbiArIHZhbHVlLmxlbmd0aCAqIDMpO1xuXHRcdFx0XHRcdHBvc2l0aW9uIC09IHN0YXJ0O1xuXHRcdFx0XHRcdHRhcmdldFZpZXcgPSB0YXJnZXQuZGF0YVZpZXc7XG5cdFx0XHRcdFx0c3RhcnQgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5ld1Bvc2l0aW9uID0gcG9zaXRpb24gKyB0YXJnZXQudXRmOFdyaXRlKHZhbHVlLCBwb3NpdGlvbiwgMHhmZmZmZmZmZik7XG5cdFx0XHR9IGVsc2UgeyAqL1xuXHRcdFx0bGV0IHNpemU7XG5cdFx0XHRyZWZPZmZzZXQgPSByZWZQb3NpdGlvbiAtIHJlZnNTdGFydFBvc2l0aW9uO1xuXHRcdFx0aWYgKHJlZk9mZnNldCA8IDB4ZmYwMCkge1xuXHRcdFx0XHR0cmFuc2l0aW9uID0gbmV4dFRyYW5zaXRpb24ub2JqZWN0MTY7XG5cdFx0XHRcdGlmICh0cmFuc2l0aW9uKVxuXHRcdFx0XHRcdHNpemUgPSAyO1xuXHRcdFx0XHRlbHNlIGlmICgodHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLm9iamVjdDMyKSlcblx0XHRcdFx0XHRzaXplID0gNDtcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dHJhbnNpdGlvbiA9IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCBPQkpFQ1RfREFUQSwgMik7XG5cdFx0XHRcdFx0c2l6ZSA9IDI7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5vYmplY3QzMiB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgT0JKRUNUX0RBVEEsIDQpO1xuXHRcdFx0XHRzaXplID0gNDtcblx0XHRcdH1cblx0XHRcdG5ld1Bvc2l0aW9uID0gcGFjayh2YWx1ZSwgcmVmUG9zaXRpb24pO1xuXHRcdFx0Ly99XG5cdFx0XHRpZiAodHlwZW9mIG5ld1Bvc2l0aW9uID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHQvLyByZS1hbGxvY2F0ZWRcblx0XHRcdFx0cmVmUG9zaXRpb24gPSBuZXdQb3NpdGlvbi5wb3NpdGlvbjtcblx0XHRcdFx0dGFyZ2V0VmlldyA9IG5ld1Bvc2l0aW9uLnRhcmdldFZpZXc7XG5cdFx0XHRcdHRhcmdldCA9IG5ld1Bvc2l0aW9uLnRhcmdldDtcblx0XHRcdFx0cmVmc1N0YXJ0UG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdFx0cG9zaXRpb24gLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdFx0c3RhcnQgLT0gZW5jb2RpbmdTdGFydDtcblx0XHRcdFx0ZW5jb2RpbmdTdGFydCA9IDA7XG5cdFx0XHR9IGVsc2Vcblx0XHRcdFx0cmVmUG9zaXRpb24gPSBuZXdQb3NpdGlvbjtcblx0XHRcdGlmIChzaXplID09PSAyKSB7XG5cdFx0XHRcdHRhcmdldFZpZXcuc2V0VWludDE2KHBvc2l0aW9uLCByZWZPZmZzZXQsIHRydWUpO1xuXHRcdFx0XHRwb3NpdGlvbiArPSAyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGFyZ2V0Vmlldy5zZXRVaW50MzIocG9zaXRpb24sIHJlZk9mZnNldCwgdHJ1ZSk7XG5cdFx0XHRcdHBvc2l0aW9uICs9IDQ7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHsgLy8gbnVsbCBvciB1bmRlZmluZWRcblx0XHRcdHRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5vYmplY3QxNiB8fCBjcmVhdGVUeXBlVHJhbnNpdGlvbihuZXh0VHJhbnNpdGlvbiwgT0JKRUNUX0RBVEEsIDIpO1xuXHRcdFx0dGFyZ2V0Vmlldy5zZXRJbnQxNihwb3NpdGlvbiwgdmFsdWUgPT09IG51bGwgPyAtMTAgOiAtOSwgdHJ1ZSk7XG5cdFx0XHRwb3NpdGlvbiArPSAyO1xuXHRcdH1cblx0XHRrZXlJbmRleCsrO1xuXHR9XG5cblxuXHRsZXQgcmVjb3JkSWQgPSB0cmFuc2l0aW9uW1JFQ09SRF9TWU1CT0xdO1xuXHRpZiAocmVjb3JkSWQgPT0gbnVsbCkge1xuXHRcdHJlY29yZElkID0gcGFja3IudHlwZWRTdHJ1Y3RzLmxlbmd0aDtcblx0XHRsZXQgc3RydWN0dXJlID0gW107XG5cdFx0bGV0IG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbjtcblx0XHRsZXQga2V5LCB0eXBlO1xuXHRcdHdoaWxlICgodHlwZSA9IG5leHRUcmFuc2l0aW9uLl9fdHlwZSkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0bGV0IHNpemUgPSBuZXh0VHJhbnNpdGlvbi5fX3NpemU7XG5cdFx0XHRuZXh0VHJhbnNpdGlvbiA9IG5leHRUcmFuc2l0aW9uLl9fcGFyZW50O1xuXHRcdFx0a2V5ID0gbmV4dFRyYW5zaXRpb24ua2V5O1xuXHRcdFx0bGV0IHByb3BlcnR5ID0gW3R5cGUsIHNpemUsIGtleV07XG5cdFx0XHRpZiAobmV4dFRyYW5zaXRpb24uZW51bWVyYXRpb25PZmZzZXQpXG5cdFx0XHRcdHByb3BlcnR5LnB1c2gobmV4dFRyYW5zaXRpb24uZW51bWVyYXRpb25PZmZzZXQpO1xuXHRcdFx0c3RydWN0dXJlLnB1c2gocHJvcGVydHkpO1xuXHRcdFx0bmV4dFRyYW5zaXRpb24gPSBuZXh0VHJhbnNpdGlvbi5wYXJlbnQ7XG5cdFx0fVxuXHRcdHN0cnVjdHVyZS5yZXZlcnNlKCk7XG5cdFx0dHJhbnNpdGlvbltSRUNPUkRfU1lNQk9MXSA9IHJlY29yZElkO1xuXHRcdHBhY2tyLnR5cGVkU3RydWN0c1tyZWNvcmRJZF0gPSBzdHJ1Y3R1cmU7XG5cdFx0cGFjayhudWxsLCAwLCB0cnVlKTsgLy8gc3BlY2lhbCBjYWxsIHRvIG5vdGlmeSB0aGF0IHN0cnVjdHVyZXMgaGF2ZSBiZWVuIHVwZGF0ZWRcblx0fVxuXG5cblx0c3dpdGNoIChoZWFkZXJTaXplKSB7XG5cdFx0Y2FzZSAxOlxuXHRcdFx0aWYgKHJlY29yZElkID49IDB4MTApIHJldHVybiAwO1xuXHRcdFx0dGFyZ2V0W3N0YXJ0XSA9IHJlY29yZElkICsgMHgyMDtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMjpcblx0XHRcdGlmIChyZWNvcmRJZCA+PSAweDEwMCkgcmV0dXJuIDA7XG5cdFx0XHR0YXJnZXRbc3RhcnRdID0gMHgzODtcblx0XHRcdHRhcmdldFtzdGFydCArIDFdID0gcmVjb3JkSWQ7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDM6XG5cdFx0XHRpZiAocmVjb3JkSWQgPj0gMHgxMDAwMCkgcmV0dXJuIDA7XG5cdFx0XHR0YXJnZXRbc3RhcnRdID0gMHgzOTtcblx0XHRcdHRhcmdldFZpZXcuc2V0VWludDE2KHN0YXJ0ICsgMSwgcmVjb3JkSWQsIHRydWUpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSA0OlxuXHRcdFx0aWYgKHJlY29yZElkID49IDB4MTAwMDAwMCkgcmV0dXJuIDA7XG5cdFx0XHR0YXJnZXRWaWV3LnNldFVpbnQzMihzdGFydCwgKHJlY29yZElkIDw8IDgpICsgMHgzYSwgdHJ1ZSk7XG5cdFx0XHRicmVhaztcblx0fVxuXG5cdGlmIChwb3NpdGlvbiA8IHJlZnNTdGFydFBvc2l0aW9uKSB7XG5cdFx0aWYgKHJlZnNTdGFydFBvc2l0aW9uID09PSByZWZQb3NpdGlvbilcblx0XHRcdHJldHVybiBwb3NpdGlvbjsgLy8gbm8gcmVmc1xuXHRcdC8vIGFkanVzdCBwb3NpdGlvbmluZ1xuXHRcdHRhcmdldC5jb3B5V2l0aGluKHBvc2l0aW9uLCByZWZzU3RhcnRQb3NpdGlvbiwgcmVmUG9zaXRpb24pO1xuXHRcdHJlZlBvc2l0aW9uICs9IHBvc2l0aW9uIC0gcmVmc1N0YXJ0UG9zaXRpb247XG5cdFx0dHlwZWRTdHJ1Y3RzLmxhc3RTdHJpbmdTdGFydCA9IHBvc2l0aW9uIC0gc3RhcnQ7XG5cdH0gZWxzZSBpZiAocG9zaXRpb24gPiByZWZzU3RhcnRQb3NpdGlvbikge1xuXHRcdGlmIChyZWZzU3RhcnRQb3NpdGlvbiA9PT0gcmVmUG9zaXRpb24pXG5cdFx0XHRyZXR1cm4gcG9zaXRpb247IC8vIG5vIHJlZnNcblx0XHR0eXBlZFN0cnVjdHMubGFzdFN0cmluZ1N0YXJ0ID0gcG9zaXRpb24gLSBzdGFydDtcblx0XHRyZXR1cm4gd3JpdGVTdHJ1Y3Qob2JqZWN0LCB0YXJnZXQsIGVuY29kaW5nU3RhcnQsIHN0YXJ0LCBzdHJ1Y3R1cmVzLCBtYWtlUm9vbSwgcGFjaywgcGFja3IpO1xuXHR9XG5cdHJldHVybiByZWZQb3NpdGlvbjtcbn1cbmZ1bmN0aW9uIGFueVR5cGUodHJhbnNpdGlvbiwgcG9zaXRpb24sIHRhcmdldFZpZXcsIHZhbHVlKSB7XG5cdGxldCBuZXh0VHJhbnNpdGlvbjtcblx0aWYgKChuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb24uYXNjaWk4IHx8IHRyYW5zaXRpb24ubnVtOCkpIHtcblx0XHR0YXJnZXRWaWV3LnNldEludDgocG9zaXRpb24sIHZhbHVlLCB0cnVlKTtcblx0XHR1cGRhdGVkUG9zaXRpb24gPSBwb3NpdGlvbiArIDE7XG5cdFx0cmV0dXJuIG5leHRUcmFuc2l0aW9uO1xuXHR9XG5cdGlmICgobmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uLnN0cmluZzE2IHx8IHRyYW5zaXRpb24ub2JqZWN0MTYpKSB7XG5cdFx0dGFyZ2V0Vmlldy5zZXRJbnQxNihwb3NpdGlvbiwgdmFsdWUsIHRydWUpO1xuXHRcdHVwZGF0ZWRQb3NpdGlvbiA9IHBvc2l0aW9uICsgMjtcblx0XHRyZXR1cm4gbmV4dFRyYW5zaXRpb247XG5cdH1cblx0aWYgKG5leHRUcmFuc2l0aW9uID0gdHJhbnNpdGlvbi5udW0zMikge1xuXHRcdHRhcmdldFZpZXcuc2V0VWludDMyKHBvc2l0aW9uLCAweGUwMDAwMTAwICsgdmFsdWUsIHRydWUpO1xuXHRcdHVwZGF0ZWRQb3NpdGlvbiA9IHBvc2l0aW9uICsgNDtcblx0XHRyZXR1cm4gbmV4dFRyYW5zaXRpb247XG5cdH1cblx0Ly8gdHJhbnNpdGlvbi5mbG9hdDY0XG5cdGlmIChuZXh0VHJhbnNpdGlvbiA9IHRyYW5zaXRpb24ubnVtNjQpIHtcblx0XHR0YXJnZXRWaWV3LnNldEZsb2F0NjQocG9zaXRpb24sIE5hTiwgdHJ1ZSk7XG5cdFx0dGFyZ2V0Vmlldy5zZXRJbnQ4KHBvc2l0aW9uLCB2YWx1ZSk7XG5cdFx0dXBkYXRlZFBvc2l0aW9uID0gcG9zaXRpb24gKyA4O1xuXHRcdHJldHVybiBuZXh0VHJhbnNpdGlvbjtcblx0fVxuXHR1cGRhdGVkUG9zaXRpb24gPSBwb3NpdGlvbjtcblx0Ly8gVE9ETzogY2FuIHdlIGRvIGFuIFwiYW55XCIgdHlwZSB3aGVyZSB3ZSBkZWZlciB0aGUgZGVjaXNpb24/XG5cdHJldHVybjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR5cGVUcmFuc2l0aW9uKHRyYW5zaXRpb24sIHR5cGUsIHNpemUpIHtcblx0bGV0IHR5cGVOYW1lID0gVFlQRV9OQU1FU1t0eXBlXSArIChzaXplIDw8IDMpO1xuXHRsZXQgbmV3VHJhbnNpdGlvbiA9IHRyYW5zaXRpb25bdHlwZU5hbWVdIHx8ICh0cmFuc2l0aW9uW3R5cGVOYW1lXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXHRuZXdUcmFuc2l0aW9uLl9fdHlwZSA9IHR5cGU7XG5cdG5ld1RyYW5zaXRpb24uX19zaXplID0gc2l6ZTtcblx0bmV3VHJhbnNpdGlvbi5fX3BhcmVudCA9IHRyYW5zaXRpb247XG5cdHJldHVybiBuZXdUcmFuc2l0aW9uO1xufVxuZnVuY3Rpb24gb25Mb2FkZWRTdHJ1Y3R1cmVzKHNoYXJlZERhdGEpIHtcblx0aWYgKCEoc2hhcmVkRGF0YSBpbnN0YW5jZW9mIE1hcCkpXG5cdFx0cmV0dXJuIHNoYXJlZERhdGE7XG5cdGxldCB0eXBlZCA9IHNoYXJlZERhdGEuZ2V0KCd0eXBlZCcpIHx8IFtdO1xuXHRpZiAoT2JqZWN0LmlzRnJvemVuKHR5cGVkKSlcblx0XHR0eXBlZCA9IHR5cGVkLm1hcChzdHJ1Y3R1cmUgPT4gc3RydWN0dXJlLnNsaWNlKDApKTtcblx0bGV0IG5hbWVkID0gc2hhcmVkRGF0YS5nZXQoJ25hbWVkJyk7XG5cdGxldCB0cmFuc2l0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdGZvciAobGV0IGkgPSAwLCBsID0gdHlwZWQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0bGV0IHN0cnVjdHVyZSA9IHR5cGVkW2ldO1xuXHRcdGxldCB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbnM7XG5cdFx0Zm9yIChsZXQgW3R5cGUsIHNpemUsIGtleV0gb2Ygc3RydWN0dXJlKSB7XG5cdFx0XHRsZXQgbmV4dFRyYW5zaXRpb24gPSB0cmFuc2l0aW9uW2tleV07XG5cdFx0XHRpZiAoIW5leHRUcmFuc2l0aW9uKSB7XG5cdFx0XHRcdHRyYW5zaXRpb25ba2V5XSA9IG5leHRUcmFuc2l0aW9uID0ge1xuXHRcdFx0XHRcdGtleSxcblx0XHRcdFx0XHRwYXJlbnQ6IHRyYW5zaXRpb24sXG5cdFx0XHRcdFx0ZW51bWVyYXRpb25PZmZzZXQ6IDAsXG5cdFx0XHRcdFx0YXNjaWkwOiBudWxsLFxuXHRcdFx0XHRcdGFzY2lpODogbnVsbCxcblx0XHRcdFx0XHRudW04OiBudWxsLFxuXHRcdFx0XHRcdHN0cmluZzE2OiBudWxsLFxuXHRcdFx0XHRcdG9iamVjdDE2OiBudWxsLFxuXHRcdFx0XHRcdG51bTMyOiBudWxsLFxuXHRcdFx0XHRcdGZsb2F0NjQ6IG51bGwsXG5cdFx0XHRcdFx0ZGF0ZTY0OiBudWxsLFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0dHJhbnNpdGlvbiA9IGNyZWF0ZVR5cGVUcmFuc2l0aW9uKG5leHRUcmFuc2l0aW9uLCB0eXBlLCBzaXplKTtcblx0XHR9XG5cdFx0dHJhbnNpdGlvbltSRUNPUkRfU1lNQk9MXSA9IGk7XG5cdH1cblx0dHlwZWQudHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9ucztcblx0dGhpcy50eXBlZFN0cnVjdHMgPSB0eXBlZDtcblx0dGhpcy5sYXN0VHlwZWRTdHJ1Y3R1cmVzTGVuZ3RoID0gdHlwZWQubGVuZ3RoO1xuXHRyZXR1cm4gbmFtZWQ7XG59XG52YXIgc291cmNlU3ltYm9sID0gU3ltYm9sLmZvcignc291cmNlJyk7XG5mdW5jdGlvbiByZWFkU3RydWN0KHNyYywgcG9zaXRpb24sIHNyY0VuZCwgdW5wYWNrcikge1xuXHRsZXQgcmVjb3JkSWQgPSBzcmNbcG9zaXRpb24rK10gLSAweDIwO1xuXHRpZiAocmVjb3JkSWQgPj0gMjQpIHtcblx0XHRzd2l0Y2gocmVjb3JkSWQpIHtcblx0XHRcdGNhc2UgMjQ6IHJlY29yZElkID0gc3JjW3Bvc2l0aW9uKytdOyBicmVhaztcblx0XHRcdC8vIGxpdHRsZSBlbmRpYW46XG5cdFx0XHRjYXNlIDI1OiByZWNvcmRJZCA9IHNyY1twb3NpdGlvbisrXSArIChzcmNbcG9zaXRpb24rK10gPDwgOCk7IGJyZWFrO1xuXHRcdFx0Y2FzZSAyNjogcmVjb3JkSWQgPSBzcmNbcG9zaXRpb24rK10gKyAoc3JjW3Bvc2l0aW9uKytdIDw8IDgpICsgKHNyY1twb3NpdGlvbisrXSA8PCAxNik7IGJyZWFrO1xuXHRcdFx0Y2FzZSAyNzogcmVjb3JkSWQgPSBzcmNbcG9zaXRpb24rK10gKyAoc3JjW3Bvc2l0aW9uKytdIDw8IDgpICsgKHNyY1twb3NpdGlvbisrXSA8PCAxNikgKyAoc3JjW3Bvc2l0aW9uKytdIDw8IDI0KTsgYnJlYWs7XG5cdFx0fVxuXHR9XG5cdGxldCBzdHJ1Y3R1cmUgPSB1bnBhY2tyLnR5cGVkU3RydWN0cyAmJiB1bnBhY2tyLnR5cGVkU3RydWN0c1tyZWNvcmRJZF07XG5cdGlmICghc3RydWN0dXJlKSB7XG5cdFx0Ly8gY29weSBzcmMgYnVmZmVyIGJlY2F1c2UgZ2V0U3RydWN0dXJlcyB3aWxsIG92ZXJyaWRlIGl0XG5cdFx0c3JjID0gVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzcmMsIHBvc2l0aW9uLCBzcmNFbmQpO1xuXHRcdHNyY0VuZCAtPSBwb3NpdGlvbjtcblx0XHRwb3NpdGlvbiA9IDA7XG5cdFx0aWYgKCF1bnBhY2tyLmdldFN0cnVjdHVyZXMpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFJlZmVyZW5jZSB0byBzaGFyZWQgc3RydWN0dXJlICR7cmVjb3JkSWR9IHdpdGhvdXQgZ2V0U3RydWN0dXJlcyBtZXRob2RgKTtcblx0XHR1bnBhY2tyLl9tZXJnZVN0cnVjdHVyZXModW5wYWNrci5nZXRTdHJ1Y3R1cmVzKCkpO1xuXHRcdGlmICghdW5wYWNrci50eXBlZFN0cnVjdHMpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGFueSBzaGFyZWQgdHlwZWQgc3RydWN0dXJlcycpO1xuXHRcdHVucGFja3IubGFzdFR5cGVkU3RydWN0dXJlc0xlbmd0aCA9IHVucGFja3IudHlwZWRTdHJ1Y3RzLmxlbmd0aDtcblx0XHRzdHJ1Y3R1cmUgPSB1bnBhY2tyLnR5cGVkU3RydWN0c1tyZWNvcmRJZF07XG5cdFx0aWYgKCFzdHJ1Y3R1cmUpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHR5cGVkIHN0cnVjdHVyZSAnICsgcmVjb3JkSWQpO1xuXHR9XG5cdHZhciBjb25zdHJ1Y3QgPSBzdHJ1Y3R1cmUuY29uc3RydWN0O1xuXHRpZiAoIWNvbnN0cnVjdCkge1xuXHRcdGNvbnN0cnVjdCA9IHN0cnVjdHVyZS5jb25zdHJ1Y3QgPSBmdW5jdGlvbiBMYXp5T2JqZWN0KCkge1xuXHRcdH07XG5cdFx0dmFyIHByb3RvdHlwZSA9IGNvbnN0cnVjdC5wcm90b3R5cGU7XG5cdFx0bGV0IHByb3BlcnRpZXMgPSBbXTtcblx0XHRsZXQgY3VycmVudE9mZnNldCA9IDA7XG5cdFx0bGV0IGxhc3RSZWZQcm9wZXJ0eTtcblx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHN0cnVjdHVyZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGxldCBkZWZpbml0aW9uID0gc3RydWN0dXJlW2ldO1xuXHRcdFx0bGV0IFsgdHlwZSwgc2l6ZSwga2V5LCBlbnVtZXJhdGlvbk9mZnNldCBdID0gZGVmaW5pdGlvbjtcblx0XHRcdGlmIChrZXkgPT09ICdfX3Byb3RvX18nKVxuXHRcdFx0XHRrZXkgPSAnX19wcm90b18nO1xuXHRcdFx0bGV0IHByb3BlcnR5ID0ge1xuXHRcdFx0XHRrZXksXG5cdFx0XHRcdG9mZnNldDogY3VycmVudE9mZnNldCxcblx0XHRcdH07XG5cdFx0XHRpZiAoZW51bWVyYXRpb25PZmZzZXQpXG5cdFx0XHRcdHByb3BlcnRpZXMuc3BsaWNlKGkgKyBlbnVtZXJhdGlvbk9mZnNldCwgMCwgcHJvcGVydHkpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRwcm9wZXJ0aWVzLnB1c2gocHJvcGVydHkpO1xuXHRcdFx0bGV0IGdldFJlZjtcblx0XHRcdHN3aXRjaChzaXplKSB7IC8vIFRPRE86IE1vdmUgaW50byBhIHNlcGFyYXRlIGZ1bmN0aW9uXG5cdFx0XHRcdGNhc2UgMDogZ2V0UmVmID0gKCkgPT4gMDsgYnJlYWs7XG5cdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHRnZXRSZWYgPSAoc291cmNlLCBwb3NpdGlvbikgPT4ge1xuXHRcdFx0XHRcdFx0bGV0IHJlZiA9IHNvdXJjZS5ieXRlc1twb3NpdGlvbiArIHByb3BlcnR5Lm9mZnNldF07XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVmID49IDB4ZjYgPyB0b0NvbnN0YW50KHJlZikgOiByZWY7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRcdGdldFJlZiA9IChzb3VyY2UsIHBvc2l0aW9uKSA9PiB7XG5cdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0bGV0IGRhdGFWaWV3ID0gc3JjLmRhdGFWaWV3IHx8IChzcmMuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQsIHNyYy5ieXRlTGVuZ3RoKSk7XG5cdFx0XHRcdFx0XHRsZXQgcmVmID0gZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uICsgcHJvcGVydHkub2Zmc2V0LCB0cnVlKTtcblx0XHRcdFx0XHRcdHJldHVybiByZWYgPj0gMHhmZjAwID8gdG9Db25zdGFudChyZWYgJiAweGZmKSA6IHJlZjtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDQ6XG5cdFx0XHRcdFx0Z2V0UmVmID0gKHNvdXJjZSwgcG9zaXRpb24pID0+IHtcblx0XHRcdFx0XHRcdGxldCBzcmMgPSBzb3VyY2UuYnl0ZXM7XG5cdFx0XHRcdFx0XHRsZXQgZGF0YVZpZXcgPSBzcmMuZGF0YVZpZXcgfHwgKHNyYy5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzcmMuYnVmZmVyLCBzcmMuYnl0ZU9mZnNldCwgc3JjLmJ5dGVMZW5ndGgpKTtcblx0XHRcdFx0XHRcdGxldCByZWYgPSBkYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24gKyBwcm9wZXJ0eS5vZmZzZXQsIHRydWUpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZiA+PSAweGZmZmZmZjAwID8gdG9Db25zdGFudChyZWYgJiAweGZmKSA6IHJlZjtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cHJvcGVydHkuZ2V0UmVmID0gZ2V0UmVmO1xuXHRcdFx0Y3VycmVudE9mZnNldCArPSBzaXplO1xuXHRcdFx0bGV0IGdldDtcblx0XHRcdHN3aXRjaCh0eXBlKSB7XG5cdFx0XHRcdGNhc2UgQVNDSUk6XG5cdFx0XHRcdFx0aWYgKGxhc3RSZWZQcm9wZXJ0eSAmJiAhbGFzdFJlZlByb3BlcnR5Lm5leHQpXG5cdFx0XHRcdFx0XHRsYXN0UmVmUHJvcGVydHkubmV4dCA9IHByb3BlcnR5O1xuXHRcdFx0XHRcdGxhc3RSZWZQcm9wZXJ0eSA9IHByb3BlcnR5O1xuXHRcdFx0XHRcdHByb3BlcnR5Lm11bHRpR2V0Q291bnQgPSAwO1xuXHRcdFx0XHRcdGdldCA9IGZ1bmN0aW9uKHNvdXJjZSkge1xuXHRcdFx0XHRcdFx0bGV0IHNyYyA9IHNvdXJjZS5ieXRlcztcblx0XHRcdFx0XHRcdGxldCBwb3NpdGlvbiA9IHNvdXJjZS5wb3NpdGlvbjtcblx0XHRcdFx0XHRcdGxldCByZWZTdGFydCA9IGN1cnJlbnRPZmZzZXQgKyBwb3NpdGlvbjtcblx0XHRcdFx0XHRcdGxldCByZWYgPSBnZXRSZWYoc291cmNlLCBwb3NpdGlvbik7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHJlZiAhPT0gJ251bWJlcicpIHJldHVybiByZWY7XG5cblx0XHRcdFx0XHRcdGxldCBlbmQsIG5leHQgPSBwcm9wZXJ0eS5uZXh0O1xuXHRcdFx0XHRcdFx0d2hpbGUobmV4dCkge1xuXHRcdFx0XHRcdFx0XHRlbmQgPSBuZXh0LmdldFJlZihzb3VyY2UsIHBvc2l0aW9uKTtcblx0XHRcdFx0XHRcdFx0aWYgKHR5cGVvZiBlbmQgPT09ICdudW1iZXInKVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0ZW5kID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0bmV4dCA9IG5leHQubmV4dDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChlbmQgPT0gbnVsbClcblx0XHRcdFx0XHRcdFx0ZW5kID0gc291cmNlLmJ5dGVzRW5kIC0gcmVmU3RhcnQ7XG5cdFx0XHRcdFx0XHRpZiAoc291cmNlLnNyY1N0cmluZykge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc291cmNlLnNyY1N0cmluZy5zbGljZShyZWYsIGVuZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvKmlmIChwcm9wZXJ0eS5tdWx0aUdldENvdW50ID4gMCkge1xuXHRcdFx0XHRcdFx0XHRsZXQgYXNjaWlFbmQ7XG5cdFx0XHRcdFx0XHRcdG5leHQgPSBmaXJzdFJlZlByb3BlcnR5O1xuXHRcdFx0XHRcdFx0XHRsZXQgZGF0YVZpZXcgPSBzcmMuZGF0YVZpZXcgfHwgKHNyYy5kYXRhVmlldyA9IG5ldyBEYXRhVmlldyhzcmMuYnVmZmVyLCBzcmMuYnl0ZU9mZnNldCwgc3JjLmJ5dGVMZW5ndGgpKTtcblx0XHRcdFx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdFx0XHRcdGFzY2lpRW5kID0gZGF0YVZpZXcuZ2V0VWludDE2KHNvdXJjZS5wb3NpdGlvbiArIG5leHQub2Zmc2V0LCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoYXNjaWlFbmQgPCAweGZmMDApXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0XHRcdFx0XHRhc2NpaUVuZCA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdH0gd2hpbGUoKG5leHQgPSBuZXh0Lm5leHQpKTtcblx0XHRcdFx0XHRcdFx0aWYgKGFzY2lpRW5kID09IG51bGwpXG5cdFx0XHRcdFx0XHRcdFx0YXNjaWlFbmQgPSBzb3VyY2UuYnl0ZXNFbmQgLSByZWZTdGFydFxuXHRcdFx0XHRcdFx0XHRzb3VyY2Uuc3JjU3RyaW5nID0gc3JjLnRvU3RyaW5nKCdsYXRpbjEnLCByZWZTdGFydCwgcmVmU3RhcnQgKyBhc2NpaUVuZCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBzb3VyY2Uuc3JjU3RyaW5nLnNsaWNlKHJlZiwgZW5kKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChzb3VyY2UucHJldlN0cmluZ0dldCkge1xuXHRcdFx0XHRcdFx0XHRzb3VyY2UucHJldlN0cmluZ0dldC5tdWx0aUdldENvdW50ICs9IDI7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzb3VyY2UucHJldlN0cmluZ0dldCA9IHByb3BlcnR5O1xuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0eS5tdWx0aUdldENvdW50LS07XG5cdFx0XHRcdFx0XHR9Ki9cblx0XHRcdFx0XHRcdHJldHVybiByZWFkU3RyaW5nKHNyYywgcmVmICsgcmVmU3RhcnQsIGVuZCAtIHJlZik7XG5cdFx0XHRcdFx0XHQvL3JldHVybiBzcmMudG9TdHJpbmcoJ2xhdGluMScsIHJlZiArIHJlZlN0YXJ0LCBlbmQgKyByZWZTdGFydCk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBVVEY4OiBjYXNlIE9CSkVDVF9EQVRBOlxuXHRcdFx0XHRcdGlmIChsYXN0UmVmUHJvcGVydHkgJiYgIWxhc3RSZWZQcm9wZXJ0eS5uZXh0KVxuXHRcdFx0XHRcdFx0bGFzdFJlZlByb3BlcnR5Lm5leHQgPSBwcm9wZXJ0eTtcblx0XHRcdFx0XHRsYXN0UmVmUHJvcGVydHkgPSBwcm9wZXJ0eTtcblx0XHRcdFx0XHRnZXQgPSBmdW5jdGlvbihzb3VyY2UpIHtcblx0XHRcdFx0XHRcdGxldCBwb3NpdGlvbiA9IHNvdXJjZS5wb3NpdGlvbjtcblx0XHRcdFx0XHRcdGxldCByZWZTdGFydCA9IGN1cnJlbnRPZmZzZXQgKyBwb3NpdGlvbjtcblx0XHRcdFx0XHRcdGxldCByZWYgPSBnZXRSZWYoc291cmNlLCBwb3NpdGlvbik7XG5cdFx0XHRcdFx0XHRpZiAodHlwZW9mIHJlZiAhPT0gJ251bWJlcicpIHJldHVybiByZWY7XG5cdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0bGV0IGVuZCwgbmV4dCA9IHByb3BlcnR5Lm5leHQ7XG5cdFx0XHRcdFx0XHR3aGlsZShuZXh0KSB7XG5cdFx0XHRcdFx0XHRcdGVuZCA9IG5leHQuZ2V0UmVmKHNvdXJjZSwgcG9zaXRpb24pO1xuXHRcdFx0XHRcdFx0XHRpZiAodHlwZW9mIGVuZCA9PT0gJ251bWJlcicpXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRlbmQgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRuZXh0ID0gbmV4dC5uZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGVuZCA9PSBudWxsKVxuXHRcdFx0XHRcdFx0XHRlbmQgPSBzb3VyY2UuYnl0ZXNFbmQgLSByZWZTdGFydDtcblx0XHRcdFx0XHRcdGlmICh0eXBlID09PSBVVEY4KSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBzcmMudG9TdHJpbmcoJ3V0ZjgnLCByZWYgKyByZWZTdGFydCwgZW5kICsgcmVmU3RhcnQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y3VycmVudFNvdXJjZSA9IHNvdXJjZTtcblx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdW5wYWNrci51bnBhY2soc3JjLCB7IHN0YXJ0OiByZWYgKyByZWZTdGFydCwgZW5kOiBlbmQgKyByZWZTdGFydCB9KTtcblx0XHRcdFx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50U291cmNlID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgTlVNQkVSOlxuXHRcdFx0XHRcdHN3aXRjaChzaXplKSB7XG5cdFx0XHRcdFx0XHRjYXNlIDQ6XG5cdFx0XHRcdFx0XHRcdGdldCA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0XHRcdGxldCBkYXRhVmlldyA9IHNyYy5kYXRhVmlldyB8fCAoc3JjLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aCkpO1xuXHRcdFx0XHRcdFx0XHRcdGxldCBwb3NpdGlvbiA9IHNvdXJjZS5wb3NpdGlvbiArIHByb3BlcnR5Lm9mZnNldDtcblx0XHRcdFx0XHRcdFx0XHRsZXQgdmFsdWUgPSBkYXRhVmlldy5nZXRJbnQzMihwb3NpdGlvbiwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlIDwgMHgyMDAwMDAwMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlID4gLTB4MWYwMDAwMDApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSA+IC0weDIwMDAwMDAwKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdG9Db25zdGFudCh2YWx1ZSAmIDB4ZmYpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRsZXQgZlZhbHVlID0gZGF0YVZpZXcuZ2V0RmxvYXQzMihwb3NpdGlvbiwgdHJ1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gdGhpcyBkb2VzIHJvdW5kaW5nIG9mIG51bWJlcnMgdGhhdCB3ZXJlIGVuY29kZWQgaW4gMzItYml0IGZsb2F0IHRvIG5lYXJlc3Qgc2lnbmlmaWNhbnQgZGVjaW1hbCBkaWdpdCB0aGF0IGNvdWxkIGJlIHByZXNlcnZlZFxuXHRcdFx0XHRcdFx0XHRcdGxldCBtdWx0aXBsaWVyID0gbXVsdDEwWygoc3JjW3Bvc2l0aW9uICsgM10gJiAweDdmKSA8PCAxKSB8IChzcmNbcG9zaXRpb24gKyAyXSA+PiA3KV07XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuICgobXVsdGlwbGllciAqIGZWYWx1ZSArIChmVmFsdWUgPiAwID8gMC41IDogLTAuNSkpID4+IDApIC8gbXVsdGlwbGllcjtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIDg6XG5cdFx0XHRcdFx0XHRcdGdldCA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0XHRcdGxldCBkYXRhVmlldyA9IHNyYy5kYXRhVmlldyB8fCAoc3JjLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHNyYy5idWZmZXIsIHNyYy5ieXRlT2Zmc2V0LCBzcmMuYnl0ZUxlbmd0aCkpO1xuXHRcdFx0XHRcdFx0XHRcdGxldCB2YWx1ZSA9IGRhdGFWaWV3LmdldEZsb2F0NjQoc291cmNlLnBvc2l0aW9uICsgcHJvcGVydHkub2Zmc2V0LCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoaXNOYU4odmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsZXQgYnl0ZSA9IHNyY1tzb3VyY2UucG9zaXRpb24gKyBwcm9wZXJ0eS5vZmZzZXRdO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGJ5dGUgPj0gMHhmNilcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRvQ29uc3RhbnQoYnl0ZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlIDE6XG5cdFx0XHRcdFx0XHRcdGdldCA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0XHRcdGxldCB2YWx1ZSA9IHNyY1tzb3VyY2UucG9zaXRpb24gKyBwcm9wZXJ0eS5vZmZzZXRdO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZSA8IDB4ZjYgPyB2YWx1ZSA6IHRvQ29uc3RhbnQodmFsdWUpO1xuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgREFURTpcblx0XHRcdFx0XHRnZXQgPSBmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRcdFx0XHRsZXQgc3JjID0gc291cmNlLmJ5dGVzO1xuXHRcdFx0XHRcdFx0bGV0IGRhdGFWaWV3ID0gc3JjLmRhdGFWaWV3IHx8IChzcmMuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoc3JjLmJ1ZmZlciwgc3JjLmJ5dGVPZmZzZXQsIHNyYy5ieXRlTGVuZ3RoKSk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IERhdGUoZGF0YVZpZXcuZ2V0RmxvYXQ2NChzb3VyY2UucG9zaXRpb24gKyBwcm9wZXJ0eS5vZmZzZXQsIHRydWUpKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cdFx0XHRwcm9wZXJ0eS5nZXQgPSBnZXQ7XG5cdFx0fVxuXHRcdC8vIFRPRE86IGxvYWQgdGhlIHNyY1N0cmluZyBmb3IgZmFzdGVyIHN0cmluZyBkZWNvZGluZyBvbiB0b0pTT05cblx0XHRpZiAoZXZhbFN1cHBvcnRlZCkge1xuXHRcdFx0bGV0IG9iamVjdExpdGVyYWxQcm9wZXJ0aWVzID0gW107XG5cdFx0XHRsZXQgYXJncyA9IFtdO1xuXHRcdFx0bGV0IGkgPSAwO1xuXHRcdFx0bGV0IGhhc0luaGVyaXRlZFByb3BlcnRpZXM7XG5cdFx0XHRmb3IgKGxldCBwcm9wZXJ0eSBvZiBwcm9wZXJ0aWVzKSB7IC8vIGFzc2lnbiBpbiBlbnVtZXJhdGlvbiBvcmRlclxuXHRcdFx0XHRpZiAodW5wYWNrci5hbHdheXNMYXp5UHJvcGVydHkgJiYgdW5wYWNrci5hbHdheXNMYXp5UHJvcGVydHkocHJvcGVydHkua2V5KSkge1xuXHRcdFx0XHRcdC8vIHRoZXNlIHByb3BlcnRpZXMgYXJlIG5vdCBlYWdlcmx5IGV2YWx1YXRlZCBhbmQgdGhpcyBjYW4gYmUgdXNlZCBmb3IgY3JlYXRpbmcgcHJvcGVydGllc1xuXHRcdFx0XHRcdC8vIHRoYXQgYXJlIG5vdCBzZXJpYWxpemVkIGFzIEpTT05cblx0XHRcdFx0XHRoYXNJbmhlcml0ZWRQcm9wZXJ0aWVzID0gdHJ1ZTtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBwcm9wZXJ0eS5rZXksIHsgZ2V0OiB3aXRoU291cmNlKHByb3BlcnR5LmdldCksIGVudW1lcmFibGU6IHRydWUgfSk7XG5cdFx0XHRcdGxldCB2YWx1ZUZ1bmN0aW9uID0gJ3YnICsgaSsrO1xuXHRcdFx0XHRhcmdzLnB1c2godmFsdWVGdW5jdGlvbik7XG5cdFx0XHRcdG9iamVjdExpdGVyYWxQcm9wZXJ0aWVzLnB1c2goJ1snICsgSlNPTi5zdHJpbmdpZnkocHJvcGVydHkua2V5KSArICddOicgKyB2YWx1ZUZ1bmN0aW9uICsgJyhzKScpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGhhc0luaGVyaXRlZFByb3BlcnRpZXMpIHtcblx0XHRcdFx0b2JqZWN0TGl0ZXJhbFByb3BlcnRpZXMucHVzaCgnX19wcm90b19fOnRoaXMnKTtcblx0XHRcdH1cblx0XHRcdGxldCB0b09iamVjdCA9IChuZXcgRnVuY3Rpb24oLi4uYXJncywgJ3JldHVybiBmdW5jdGlvbihzKXtyZXR1cm57JyArIG9iamVjdExpdGVyYWxQcm9wZXJ0aWVzLmpvaW4oJywnKSArICd9fScpKS5hcHBseShudWxsLCBwcm9wZXJ0aWVzLm1hcChwcm9wID0+IHByb3AuZ2V0KSk7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAndG9KU09OJywge1xuXHRcdFx0XHR2YWx1ZShvbWl0VW5kZXJzY29yZWRQcm9wZXJ0aWVzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRvT2JqZWN0LmNhbGwodGhpcywgdGhpc1tzb3VyY2VTeW1ib2xdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsICd0b0pTT04nLCB7XG5cdFx0XHRcdHZhbHVlKG9taXRVbmRlcnNjb3JlZFByb3BlcnRpZXMpIHtcblx0XHRcdFx0XHQvLyByZXR1cm4gYW4gZW51bWVyYWJsZSBvYmplY3Qgd2l0aCBvd24gcHJvcGVydGllcyB0byBKU09OIHN0cmluZ2lmeVxuXHRcdFx0XHRcdGxldCByZXNvbHZlZCA9IHt9O1xuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdC8vIFRPRE86IGNoZWNrIGFsd2F5c0xhenlQcm9wZXJ0eVxuXHRcdFx0XHRcdFx0bGV0IGtleSA9IHByb3BlcnRpZXNbaV0ua2V5O1xuXG5cdFx0XHRcdFx0XHRyZXNvbHZlZFtrZXldID0gdGhpc1trZXldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gcmVzb2x2ZWQ7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8vIG5vdCBlbnVtZXJhYmxlIG9yIGFueXRoaW5nXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblx0dmFyIGluc3RhbmNlID0gbmV3IGNvbnN0cnVjdCgpO1xuXHRpbnN0YW5jZVtzb3VyY2VTeW1ib2xdID0ge1xuXHRcdGJ5dGVzOiBzcmMsXG5cdFx0cG9zaXRpb24sXG5cdFx0c3JjU3RyaW5nOiAnJyxcblx0XHRieXRlc0VuZDogc3JjRW5kXG5cdH07XG5cdHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIHRvQ29uc3RhbnQoY29kZSkge1xuXHRzd2l0Y2goY29kZSkge1xuXHRcdGNhc2UgMHhmNjogcmV0dXJuIG51bGw7XG5cdFx0Y2FzZSAweGY3OiByZXR1cm4gdW5kZWZpbmVkO1xuXHRcdGNhc2UgMHhmODogcmV0dXJuIGZhbHNlO1xuXHRcdGNhc2UgMHhmOTogcmV0dXJuIHRydWU7XG5cdH1cblx0dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNvbnN0YW50Jyk7XG59XG5mdW5jdGlvbiB3aXRoU291cmNlKGdldCkge1xuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGdldCh0aGlzW3NvdXJjZVN5bWJvbF0pO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHNhdmVTdGF0ZSgpIHtcblx0aWYgKGN1cnJlbnRTb3VyY2UpIHtcblx0XHRjdXJyZW50U291cmNlLmJ5dGVzID0gVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjdXJyZW50U291cmNlLmJ5dGVzLCBjdXJyZW50U291cmNlLnBvc2l0aW9uLCBjdXJyZW50U291cmNlLmJ5dGVzRW5kKTtcblx0XHRjdXJyZW50U291cmNlLnBvc2l0aW9uID0gMDtcblx0XHRjdXJyZW50U291cmNlLmJ5dGVzRW5kID0gY3VycmVudFNvdXJjZS5ieXRlcy5sZW5ndGg7XG5cdH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVTdHJ1Y3R1cmVzKHN0cnVjdHVyZXMsIHBhY2tyKSB7XG5cdGlmIChwYWNrci50eXBlZFN0cnVjdHMpIHtcblx0XHRsZXQgc3RydWN0TWFwID0gbmV3IE1hcCgpO1xuXHRcdHN0cnVjdE1hcC5zZXQoJ25hbWVkJywgc3RydWN0dXJlcyk7XG5cdFx0c3RydWN0TWFwLnNldCgndHlwZWQnLCBwYWNrci50eXBlZFN0cnVjdHMpO1xuXHRcdHN0cnVjdHVyZXMgPSBzdHJ1Y3RNYXA7XG5cdH1cblx0bGV0IGxhc3RUeXBlZFN0cnVjdHVyZXNMZW5ndGggPSBwYWNrci5sYXN0VHlwZWRTdHJ1Y3R1cmVzTGVuZ3RoIHx8IDA7XG5cdHN0cnVjdHVyZXMuaXNDb21wYXRpYmxlID0gZXhpc3RpbmcgPT4ge1xuXHRcdGxldCBjb21wYXRpYmxlID0gdHJ1ZTtcblx0XHRpZiAoZXhpc3RpbmcgaW5zdGFuY2VvZiBNYXApIHtcblx0XHRcdGxldCBuYW1lZCA9IGV4aXN0aW5nLmdldCgnbmFtZWQnKSB8fCBbXTtcblx0XHRcdGlmIChuYW1lZC5sZW5ndGggIT09IChwYWNrci5sYXN0TmFtZWRTdHJ1Y3R1cmVzTGVuZ3RoIHx8IDApKVxuXHRcdFx0XHRjb21wYXRpYmxlID0gZmFsc2U7XG5cdFx0XHRsZXQgdHlwZWQgPSBleGlzdGluZy5nZXQoJ3R5cGVkJykgfHwgW107XG5cdFx0XHRpZiAodHlwZWQubGVuZ3RoICE9PSBsYXN0VHlwZWRTdHJ1Y3R1cmVzTGVuZ3RoKVxuXHRcdFx0XHRjb21wYXRpYmxlID0gZmFsc2U7XG5cdFx0fSBlbHNlIGlmIChleGlzdGluZyBpbnN0YW5jZW9mIEFycmF5IHx8IEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpKSB7XG5cdFx0XHRpZiAoZXhpc3RpbmcubGVuZ3RoICE9PSAocGFja3IubGFzdE5hbWVkU3RydWN0dXJlc0xlbmd0aCB8fCAwKSlcblx0XHRcdFx0Y29tcGF0aWJsZSA9IGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoIWNvbXBhdGlibGUpXG5cdFx0XHRwYWNrci5fbWVyZ2VTdHJ1Y3R1cmVzKGV4aXN0aW5nKTtcblx0XHRyZXR1cm4gY29tcGF0aWJsZTtcblx0fTtcblx0cGFja3IubGFzdFR5cGVkU3RydWN0dXJlc0xlbmd0aCA9IHBhY2tyLnR5cGVkU3RydWN0cyAmJiBwYWNrci50eXBlZFN0cnVjdHMubGVuZ3RoO1xuXHRyZXR1cm4gc3RydWN0dXJlcztcbn1cblxuc2V0UmVhZFN0cnVjdChyZWFkU3RydWN0LCBvbkxvYWRlZFN0cnVjdHVyZXMsIHNhdmVTdGF0ZSk7XG5cbmNsYXNzIFBhY2tyU3RyZWFtIGV4dGVuZHMgc3RyZWFtLlRyYW5zZm9ybSB7XG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcblx0XHRpZiAoIW9wdGlvbnMpXG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0b3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGUgPSB0cnVlO1xuXHRcdHN1cGVyKG9wdGlvbnMpO1xuXHRcdG9wdGlvbnMuc2VxdWVudGlhbCA9IHRydWU7XG5cdFx0dGhpcy5wYWNrciA9IG9wdGlvbnMucGFja3IgfHwgbmV3IFBhY2tyKG9wdGlvbnMpO1xuXHR9XG5cdF90cmFuc2Zvcm0odmFsdWUsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuXHRcdHRoaXMucHVzaCh0aGlzLnBhY2tyLnBhY2sodmFsdWUpKTtcblx0XHRjYWxsYmFjaygpO1xuXHR9XG59XG5cbmNsYXNzIFVucGFja3JTdHJlYW0gZXh0ZW5kcyBzdHJlYW0uVHJhbnNmb3JtIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdGlmICghb3B0aW9ucylcblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRvcHRpb25zLm9iamVjdE1vZGUgPSB0cnVlO1xuXHRcdHN1cGVyKG9wdGlvbnMpO1xuXHRcdG9wdGlvbnMuc3RydWN0dXJlcyA9IFtdO1xuXHRcdHRoaXMudW5wYWNrciA9IG9wdGlvbnMudW5wYWNrciB8fCBuZXcgVW5wYWNrcihvcHRpb25zKTtcblx0fVxuXHRfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcblx0XHRpZiAodGhpcy5pbmNvbXBsZXRlQnVmZmVyKSB7XG5cdFx0XHRjaHVuayA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuaW5jb21wbGV0ZUJ1ZmZlciwgY2h1bmtdKTtcblx0XHRcdHRoaXMuaW5jb21wbGV0ZUJ1ZmZlciA9IG51bGw7XG5cdFx0fVxuXHRcdGxldCB2YWx1ZXM7XG5cdFx0dHJ5IHtcblx0XHRcdHZhbHVlcyA9IHRoaXMudW5wYWNrci51bnBhY2tNdWx0aXBsZShjaHVuayk7XG5cdFx0fSBjYXRjaChlcnJvcikge1xuXHRcdFx0aWYgKGVycm9yLmluY29tcGxldGUpIHtcblx0XHRcdFx0dGhpcy5pbmNvbXBsZXRlQnVmZmVyID0gY2h1bmsuc2xpY2UoZXJyb3IubGFzdFBvc2l0aW9uKTtcblx0XHRcdFx0dmFsdWVzID0gZXJyb3IudmFsdWVzO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0XHR0aHJvdyBlcnJvclxuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMgfHwgW10pIHtcblx0XHRcdFx0aWYgKHZhbHVlID09PSBudWxsKVxuXHRcdFx0XHRcdHZhbHVlID0gdGhpcy5nZXROdWxsVmFsdWUoKTtcblx0XHRcdFx0dGhpcy5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuXHR9XG5cdGdldE51bGxWYWx1ZSgpIHtcblx0XHRyZXR1cm4gU3ltYm9sLmZvcihudWxsKVxuXHR9XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gSXRlcmFibGUgZmlyc3QgYXJndW1lbnQsIHJldHVybnMgYW4gSXRlcmFibGUgd2hlcmUgZWFjaCB2YWx1ZSBpcyBwYWNrZWQgYXMgYSBCdWZmZXJcbiAqIElmIHRoZSBhcmd1bWVudCBpcyBvbmx5IEFzeW5jIEl0ZXJhYmxlLCB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgYW4gQXN5bmMgSXRlcmFibGUuXG4gKiBAcGFyYW0ge0l0ZXJhYmxlfEl0ZXJhdG9yfEFzeW5jSXRlcmFibGV8QXN5bmNJdGVyYXRvcn0gb2JqZWN0SXRlcmF0b3IgLSBpdGVyYWJsZSBzb3VyY2UsIGxpa2UgYSBSZWFkYWJsZSBvYmplY3Qgc3RyZWFtLCBhbiBhcnJheSwgU2V0LCBvciBjdXN0b20gb2JqZWN0XG4gKiBAcGFyYW0ge29wdGlvbnN9IFtvcHRpb25zXSAtIG1zZ3BhY2tyIHBhY2sgb3B0aW9uc1xuICogQHJldHVybnMge0l0ZXJhYmxlSXRlcmF0b3J8UHJvbWlzZS48QXN5bmNJdGVyYWJsZUl0ZXJhdG9yPn1cbiAqL1xuZnVuY3Rpb24gcGFja0l0ZXIgKG9iamVjdEl0ZXJhdG9yLCBvcHRpb25zID0ge30pIHtcbiAgaWYgKCFvYmplY3RJdGVyYXRvciB8fCB0eXBlb2Ygb2JqZWN0SXRlcmF0b3IgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEl0ZXJhYmxlLCBBc3luYyBJdGVyYWJsZSwgb3IgYSBQcm9taXNlIGZvciBhbiBBc3luYyBJdGVyYWJsZScpXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdEl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcGFja0l0ZXJTeW5jKG9iamVjdEl0ZXJhdG9yLCBvcHRpb25zKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3RJdGVyYXRvci50aGVuID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBvYmplY3RJdGVyYXRvcltTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcGFja0l0ZXJBc3luYyhvYmplY3RJdGVyYXRvciwgb3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gSXRlcmFibGUsIEFzeW5jIEl0ZXJhYmxlLCBJdGVyYXRvciwgQXN5bmMgSXRlcmF0b3IsIG9yIGEgUHJvbWlzZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gKiBwYWNrSXRlclN5bmMgKG9iamVjdEl0ZXJhdG9yLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhY2tyID0gbmV3IFBhY2tyKG9wdGlvbnMpO1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIG9iamVjdEl0ZXJhdG9yKSB7XG4gICAgeWllbGQgcGFja3IucGFjayh2YWx1ZSk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gKiBwYWNrSXRlckFzeW5jIChvYmplY3RJdGVyYXRvciwgb3B0aW9ucykge1xuICBjb25zdCBwYWNrciA9IG5ldyBQYWNrcihvcHRpb25zKTtcbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBvYmplY3RJdGVyYXRvcikge1xuICAgIHlpZWxkIHBhY2tyLnBhY2sodmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYW4gSXRlcmFibGUvSXRlcmF0b3IgaW5wdXQgd2hpY2ggeWllbGRzIGJ1ZmZlcnMsIHJldHVybnMgYW4gSXRlcmFibGVJdGVyYXRvciB3aGljaCB5aWVsZHMgc3luYyBkZWNvZGVkIG9iamVjdHNcbiAqIE9yLCBnaXZlbiBhbiBBc3luYyBJdGVyYWJsZS9JdGVyYXRvciB3aGljaCB5aWVsZHMgcHJvbWlzZXMgcmVzb2x2aW5nIGluIGJ1ZmZlcnMsIHJldHVybnMgYW4gQXN5bmNJdGVyYWJsZUl0ZXJhdG9yLlxuICogQHBhcmFtIHtJdGVyYWJsZXxJdGVyYXRvcnxBc3luY0l0ZXJhYmxlfEFzeW5jSXRlcmFibGVJdGVyYXRvcn0gYnVmZmVySXRlcmF0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSB1bnBhY2tyIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yfFByb21pc2UuPEFzeW5jSXRlcmFibGVJdGVyYXRvcn1cbiAqL1xuZnVuY3Rpb24gdW5wYWNrSXRlciAoYnVmZmVySXRlcmF0b3IsIG9wdGlvbnMgPSB7fSkge1xuICBpZiAoIWJ1ZmZlckl0ZXJhdG9yIHx8IHR5cGVvZiBidWZmZXJJdGVyYXRvciAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gSXRlcmFibGUsIEFzeW5jIEl0ZXJhYmxlLCBJdGVyYXRvciwgQXN5bmMgSXRlcmF0b3IsIG9yIGEgcHJvbWlzZScpXG4gIH1cblxuICBjb25zdCB1bnBhY2tyID0gbmV3IFVucGFja3Iob3B0aW9ucyk7XG4gIGxldCBpbmNvbXBsZXRlO1xuICBjb25zdCBwYXJzZXIgPSAoY2h1bmspID0+IHtcbiAgICBsZXQgeWllbGRzO1xuICAgIC8vIGlmIHRoZXJlJ3MgaW5jb21wbGV0ZSBkYXRhIGZyb20gcHJldmlvdXMgY2h1bmssIGNvbmNhdGluYXRlIGFuZCB0cnkgYWdhaW5cbiAgICBpZiAoaW5jb21wbGV0ZSkge1xuICAgICAgY2h1bmsgPSBCdWZmZXIuY29uY2F0KFtpbmNvbXBsZXRlLCBjaHVua10pO1xuICAgICAgaW5jb21wbGV0ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgeWllbGRzID0gdW5wYWNrci51bnBhY2tNdWx0aXBsZShjaHVuayk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyLmluY29tcGxldGUpIHtcbiAgICAgICAgaW5jb21wbGV0ZSA9IGNodW5rLnNsaWNlKGVyci5sYXN0UG9zaXRpb24pO1xuICAgICAgICB5aWVsZHMgPSBlcnIudmFsdWVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB5aWVsZHNcbiAgfTtcblxuICBpZiAodHlwZW9mIGJ1ZmZlckl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uICogaXRlciAoKSB7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGJ1ZmZlckl0ZXJhdG9yKSB7XG4gICAgICAgIHlpZWxkICogcGFyc2VyKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KSgpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGJ1ZmZlckl0ZXJhdG9yW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiAoYXN5bmMgZnVuY3Rpb24gKiBpdGVyICgpIHtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgYnVmZmVySXRlcmF0b3IpIHtcbiAgICAgICAgeWllbGQgKiBwYXJzZXIodmFsdWUpO1xuICAgICAgfVxuICAgIH0pKClcbiAgfVxufVxuY29uc3QgZGVjb2RlSXRlciA9IHVucGFja0l0ZXI7XG5jb25zdCBlbmNvZGVJdGVyID0gcGFja0l0ZXI7XG5cbmNvbnN0IHVzZVJlY29yZHMgPSBmYWxzZTtcbmNvbnN0IG1hcHNBc09iamVjdHMgPSB0cnVlO1xuXG5jb25zdCBuYXRpdmVBY2NlbGVyYXRpb25EaXNhYmxlZCA9IHByb2Nlc3MuZW52Lk1TR1BBQ0tSX05BVElWRV9BQ0NFTEVSQVRJT05fRElTQUJMRUQgIT09IHVuZGVmaW5lZCAmJiBwcm9jZXNzLmVudi5NU0dQQUNLUl9OQVRJVkVfQUNDRUxFUkFUSU9OX0RJU0FCTEVELnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcblxuaWYgKCFuYXRpdmVBY2NlbGVyYXRpb25EaXNhYmxlZCkge1xuXHRsZXQgZXh0cmFjdG9yO1xuXHR0cnkge1xuXHRcdGlmICh0eXBlb2YgcmVxdWlyZSA9PSAnZnVuY3Rpb24nKVxuXHRcdFx0ZXh0cmFjdG9yID0gcmVxdWlyZSgnbXNncGFja3ItZXh0cmFjdCcpO1xuXHRcdGVsc2Vcblx0XHRcdGV4dHJhY3RvciA9IG1vZHVsZSQxLmNyZWF0ZVJlcXVpcmUoKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgPyBuZXcgKHJlcXVpcmUoJ3UnICsgJ3JsJykuVVJMKSgnZmlsZTonICsgX19maWxlbmFtZSkuaHJlZiA6IChkb2N1bWVudC5jdXJyZW50U2NyaXB0ICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjIHx8IG5ldyBVUkwoJ25vZGUuY2pzJywgZG9jdW1lbnQuYmFzZVVSSSkuaHJlZikpKSgnbXNncGFja3ItZXh0cmFjdCcpO1xuXHRcdGlmIChleHRyYWN0b3IpXG5cdFx0XHRzZXRFeHRyYWN0b3IoZXh0cmFjdG9yLmV4dHJhY3RTdHJpbmdzKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBuYXRpdmUgbW9kdWxlIGlzIG9wdGlvbmFsXG5cdH1cbn1cblxuZXhwb3J0cy5BTFdBWVMgPSBBTFdBWVM7XG5leHBvcnRzLkMxID0gQzE7XG5leHBvcnRzLkRFQ0lNQUxfRklUID0gREVDSU1BTF9GSVQ7XG5leHBvcnRzLkRFQ0lNQUxfUk9VTkQgPSBERUNJTUFMX1JPVU5EO1xuZXhwb3J0cy5EZWNvZGVyID0gRGVjb2RlcjtcbmV4cG9ydHMuRGVjb2RlclN0cmVhbSA9IFVucGFja3JTdHJlYW07XG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuZXhwb3J0cy5FbmNvZGVyU3RyZWFtID0gUGFja3JTdHJlYW07XG5leHBvcnRzLkZMT0FUMzJfT1BUSU9OUyA9IEZMT0FUMzJfT1BUSU9OUztcbmV4cG9ydHMuTkVWRVIgPSBORVZFUjtcbmV4cG9ydHMuUGFja3IgPSBQYWNrcjtcbmV4cG9ydHMuUGFja3JTdHJlYW0gPSBQYWNrclN0cmVhbTtcbmV4cG9ydHMuVW5wYWNrciA9IFVucGFja3I7XG5leHBvcnRzLlVucGFja3JTdHJlYW0gPSBVbnBhY2tyU3RyZWFtO1xuZXhwb3J0cy5hZGRFeHRlbnNpb24gPSBhZGRFeHRlbnNpb247XG5leHBvcnRzLmNsZWFyU291cmNlID0gY2xlYXJTb3VyY2U7XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmV4cG9ydHMuZGVjb2RlSXRlciA9IGRlY29kZUl0ZXI7XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZW5jb2RlSXRlciA9IGVuY29kZUl0ZXI7XG5leHBvcnRzLm1hcHNBc09iamVjdHMgPSBtYXBzQXNPYmplY3RzO1xuZXhwb3J0cy5wYWNrID0gcGFjaztcbmV4cG9ydHMucm91bmRGbG9hdDMyID0gcm91bmRGbG9hdDMyO1xuZXhwb3J0cy51bnBhY2sgPSB1bnBhY2s7XG5leHBvcnRzLnVucGFja011bHRpcGxlID0gdW5wYWNrTXVsdGlwbGU7XG5leHBvcnRzLnVzZVJlY29yZHMgPSB1c2VSZWNvcmRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9kZS5janMubWFwXG4iXSwibmFtZXMiOlsic3RyZWFtIiwicmVxdWlyZSIsIm1vZHVsZSQxIiwiZGVjb2RlciIsIlRleHREZWNvZGVyIiwiZXJyb3IiLCJzcmMiLCJzcmNFbmQiLCJwb3NpdGlvbiQxIiwiRU1QVFlfQVJSQVkiLCJzdHJpbmdzIiwic3RyaW5nUG9zaXRpb24iLCJjdXJyZW50VW5wYWNrciIsImN1cnJlbnRTdHJ1Y3R1cmVzIiwic3JjU3RyaW5nIiwic3JjU3RyaW5nU3RhcnQiLCJzcmNTdHJpbmdFbmQiLCJidW5kbGVkU3RyaW5ncyQxIiwicmVmZXJlbmNlTWFwIiwiY3VycmVudEV4dGVuc2lvbnMiLCJkYXRhVmlldyIsImRlZmF1bHRPcHRpb25zIiwidXNlUmVjb3JkcyIsIm1hcHNBc09iamVjdHMiLCJDMVR5cGUiLCJDMSIsIm5hbWUiLCJzZXF1ZW50aWFsTW9kZSIsImlubGluZU9iamVjdFJlYWRUaHJlc2hvbGQiLCJyZWFkU3RydWN0JDEiLCJvbkxvYWRlZFN0cnVjdHVyZXMkMSIsIm9uU2F2ZVN0YXRlIiwiRnVuY3Rpb24iLCJJbmZpbml0eSIsIlVucGFja3IiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJ1bmRlZmluZWQiLCJzZXF1ZW50aWFsIiwidHJ1c3RlZCIsInN0cnVjdHVyZXMiLCJtYXhTaGFyZWRTdHJ1Y3R1cmVzIiwic2hhcmVkTGVuZ3RoIiwibGVuZ3RoIiwiZ2V0U3RydWN0dXJlcyIsInVuaW5pdGlhbGl6ZWQiLCJpbnQ2NEFzTnVtYmVyIiwiaW50NjRBc1R5cGUiLCJPYmplY3QiLCJhc3NpZ24iLCJ1bnBhY2siLCJzb3VyY2UiLCJzYXZlU3RhdGUkMSIsImNsZWFyU291cmNlIiwicHJvdG90eXBlIiwiY2FsbCIsImJ1ZmZlciIsIkFycmF5QnVmZmVyIiwiQnVmZmVyIiwiZnJvbSIsIlVpbnQ4QXJyYXkiLCJlbmQiLCJzdGFydCIsIkRhdGFWaWV3IiwiYnl0ZU9mZnNldCIsImJ5dGVMZW5ndGgiLCJFcnJvciIsImNoZWNrZWRSZWFkIiwidW5wYWNrTXVsdGlwbGUiLCJmb3JFYWNoIiwidmFsdWVzIiwibGFzdFBvc2l0aW9uIiwic2l6ZSIsInZhbHVlIiwiZGVmYXVsdFVucGFja3IiLCJwdXNoIiwiX21lcmdlU3RydWN0dXJlcyIsImxvYWRlZFN0cnVjdHVyZXMiLCJleGlzdGluZ1N0cnVjdHVyZXMiLCJpc0Zyb3plbiIsIm1hcCIsInN0cnVjdHVyZSIsInNsaWNlIiwiaSIsImwiLCJpc1NoYXJlZCIsImhpZ2hCeXRlIiwiaWQiLCJleGlzdGluZyIsInJlc3RvcmVTdHJ1Y3R1cmVzIiwiZGVjb2RlIiwicmVzdWx0IiwicmFuZG9tQWNjZXNzU3RydWN0dXJlIiwibGF6eSIsInRvSlNPTiIsInJlYWQiLCJwb3N0QnVuZGxlUG9zaXRpb24iLCJqc29uVmlldyIsIkpTT04iLCJzdHJpbmdpZnkiLCJfIiwiUmFuZ2VFcnJvciIsIm1lc3NhZ2UiLCJzdGFydHNXaXRoIiwiaW5jb21wbGV0ZSIsInRva2VuIiwibG9hZFN0cnVjdHVyZXMiLCJjcmVhdGVTdHJ1Y3R1cmVSZWFkZXIiLCJvYmplY3QiLCJrZXkiLCJyZWFkS2V5IiwiTWFwIiwic2V0IiwiYXJyYXkiLCJBcnJheSIsImZyZWV6ZURhdGEiLCJmcmVlemUiLCJzdHJpbmciLCJzaG9ydFN0cmluZ0luSlMiLCJsb25nU3RyaW5nSW5KUyIsInJlYWRGaXhlZFN0cmluZyIsInBvc2l0aW9uMSIsInBvc2l0aW9uMCIsInJlYWRCaW4iLCJnZXRVaW50MTYiLCJnZXRVaW50MzIiLCJyZWFkRXh0IiwiZ2V0RmxvYXQzMiIsInVzZUZsb2F0MzIiLCJtdWx0aXBsaWVyIiwibXVsdDEwIiwiZ2V0RmxvYXQ2NCIsImdldEJpZ1VpbnQ2NCIsInRvU3RyaW5nIiwiQmlnSW50IiwiTnVtYmVyIiwiZ2V0SW50OCIsImdldEludDE2IiwiZ2V0SW50MzIiLCJnZXRCaWdJbnQ2NCIsInJlY29yZERlZmluaXRpb24iLCJleHRlbnNpb24iLCJub0J1ZmZlciIsInN1YmFycmF5IiwicmVhZFN0cmluZzgiLCJyZWFkU3RyaW5nMTYiLCJyZWFkU3RyaW5nMzIiLCJyZWFkQXJyYXkiLCJyZWFkTWFwIiwidmFsaWROYW1lIiwiZmlyc3RJZCIsInJlYWRPYmplY3QiLCJjb3VudCIsInRlc3QiLCJqb2luIiwiY3JlYXRlU2Vjb25kQnl0ZVJlYWRlciIsInJlYWQwIiwicmVhZFN0cmluZ0pTIiwiZXhwb3J0cyIsImlzTmF0aXZlQWNjZWxlcmF0aW9uRW5hYmxlZCIsInNldEV4dHJhY3RvciIsImV4dHJhY3RTdHJpbmdzIiwicmVhZFN0cmluZyIsImhlYWRlckxlbmd0aCIsImV4dHJhY3Rpb24iLCJzcmNTdHJpbmdMZW5ndGgiLCJ1bml0cyIsImJ5dGUxIiwiYnl0ZTIiLCJieXRlMyIsImJ5dGU0IiwidW5pdCIsImZyb21DaGFyQ29kZSIsImFwcGx5IiwiU3RyaW5nIiwiZXhpc3RpbmdTcmMiLCJieXRlcyIsImJ5dGUiLCJhIiwiYiIsImMiLCJkIiwiZSIsImYiLCJnIiwiaCIsImoiLCJrIiwibSIsIm4iLCJvIiwicmVhZE9ubHlKU1N0cmluZyIsImNvcHlCdWZmZXJzIiwidHlwZSIsInJlYWRQb3NpdGlvbiIsImtleUNhY2hlIiwiYXNTYWZlU3RyaW5nIiwiZW50cnkiLCJjaGVja1Bvc2l0aW9uIiwiY2h1bmsiLCJwcm9wZXJ0eSIsImZpcnN0Qnl0ZSIsImV4aXN0aW5nU3RydWN0dXJlIiwiZGF0YSIsImVycm9ycyIsIlR5cGVFcnJvciIsIlJlZmVyZW5jZUVycm9yIiwiY2F1c2UiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJ0YXJnZXQiLCJyZWZFbnRyeSIsInRhcmdldFByb3BlcnRpZXMiLCJ1c2VkIiwiZ2V0IiwiU2V0IiwidHlwZWRBcnJheXMiLCJnbGJsIiwiZ2xvYmFsVGhpcyIsIndpbmRvdyIsInR5cGVDb2RlIiwidHlwZWRBcnJheU5hbWUiLCJhYiIsInU4IiwiUmVnRXhwIiwiVEVNUF9CVU5ETEUiLCJkYXRhU2l6ZSIsImRhdGFQb3NpdGlvbiIsIkRhdGUiLCJjYWxsYmFjayIsInNhdmVkU3JjRW5kIiwic2F2ZWRQb3NpdGlvbiIsInNhdmVkU3RyaW5nUG9zaXRpb24iLCJzYXZlZFNyY1N0cmluZ1N0YXJ0Iiwic2F2ZWRTcmNTdHJpbmdFbmQiLCJzYXZlZFNyY1N0cmluZyIsInNhdmVkU3RyaW5ncyIsInNhdmVkUmVmZXJlbmNlTWFwIiwic2F2ZWRCdW5kbGVkU3RyaW5ncyIsInNhdmVkU3JjIiwic2F2ZWRTdHJ1Y3R1cmVzIiwic2F2ZWRTdHJ1Y3R1cmVzQ29udGVudHMiLCJzYXZlZFBhY2tyIiwic2F2ZWRTZXF1ZW50aWFsTW9kZSIsInNwbGljZSIsImFkZEV4dGVuc2lvbiQxIiwiTWF0aCIsImZsb29yIiwiRGVjb2RlciIsIkZMT0FUMzJfT1BUSU9OUyIsIk5FVkVSIiwiQUxXQVlTIiwiREVDSU1BTF9ST1VORCIsIkRFQ0lNQUxfRklUIiwiZjMyQXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJ1OEFycmF5Iiwicm91bmRGbG9hdDMyIiwiZmxvYXQzMk51bWJlciIsInNldFJlYWRTdHJ1Y3QiLCJ1cGRhdGVkUmVhZFN0cnVjdCIsImxvYWRlZFN0cnVjdHMiLCJzYXZlU3RhdGUiLCJ0ZXh0RW5jb2RlciQxIiwiVGV4dEVuY29kZXIiLCJleHRlbnNpb25zIiwiZXh0ZW5zaW9uQ2xhc3NlcyIsImhhc05vZGVCdWZmZXIkMSIsIkJ5dGVBcnJheUFsbG9jYXRlIiwiYWxsb2NVbnNhZmVTbG93IiwiQnl0ZUFycmF5IiwiTUFYX0JVRkZFUl9TSVpFIiwia2V5c1RhcmdldCIsInRhcmdldFZpZXciLCJwb3NpdGlvbiIsInNhZmVFbmQiLCJidW5kbGVkU3RyaW5ncyIsIndyaXRlU3RydWN0U2xvdHMiLCJNQVhfQlVORExFX1NJWkUiLCJoYXNOb25MYXRpbiIsIlJFQ09SRF9TWU1CT0wiLCJTeW1ib2wiLCJQYWNrciIsIm9mZnNldCIsImhhc1NoYXJlZFVwZGF0ZSIsImVuY29kZVV0ZjgiLCJ1dGY4V3JpdGUiLCJlbmNvZGVJbnRvIiwid3JpdHRlbiIsInBhY2tyIiwiaXNTZXF1ZW50aWFsIiwiaGFzU2hhcmVkU3RydWN0dXJlcyIsInNhdmVTdHJ1Y3R1cmVzIiwibW9yZVR5cGVzIiwibWF4T3duU3RydWN0dXJlcyIsInVzZVR3b0J5dGVSZWNvcmRzIiwic2hhcmVkTGltaXRJZCIsIm1heFN0cnVjdHVyZUlkIiwicmVjb3JkSWRzVG9SZW1vdmUiLCJ0cmFuc2l0aW9uc0NvdW50Iiwic2VyaWFsaXphdGlvbnNTaW5jZVRyYW5zaXRpb25SZWJ1aWxkIiwicGFjayIsImVuY29kZSIsImVuY29kZU9wdGlvbnMiLCJSRVNFUlZFX1NUQVJUX1NQQUNFIiwiYnVuZGxlU3RyaW5ncyIsInRyYW5zaXRpb25zIiwiY3JlYXRlIiwia2V5cyIsIm5leHRUcmFuc2l0aW9uIiwidHJhbnNpdGlvbiIsImxhc3ROYW1lZFN0cnVjdHVyZXNMZW5ndGgiLCJuZXh0SWQiLCJlbmNvZGluZ0Vycm9yIiwid3JpdGVTdHJ1Y3QiLCJsYXN0QnVuZGxlIiwid3JpdGVCdW5kbGVzIiwiaWRzVG9JbnNlcnQiLCJzb3J0IiwiaW5jcmVtZW50UG9zaXRpb24iLCJpbnNlcnRpb25Qb2ludCIsInN0cmluZ3NQb3NpdGlvbiIsInNldFVpbnQzMiIsInByZXZpb3VzIiwibWFrZVJvb20iLCJzZXJpYWxpemVkIiwiaW5zZXJ0SWRzIiwiUkVVU0VfQlVGRkVSX01PREUiLCJyZXNldFN0cnVjdHVyZXMiLCJyZXR1cm5CdWZmZXIiLCJuZXdTaGFyZWREYXRhIiwicHJlcGFyZVN0cnVjdHVyZXMkMSIsImlzQ29tcGF0aWJsZSIsIlJFU0VUX0JVRkZFUl9NT0RFIiwicGFja0FycmF5Iiwic3RyTGVuZ3RoIiwiZXh0U3RhcnQiLCJtYXhCeXRlcyIsInNldFVpbnQxNiIsInR3b0J5dGUiLCJoZWFkZXJTaXplIiwiYzEiLCJjMiIsInN0clBvc2l0aW9uIiwiY2hhckNvZGVBdCIsImNvcHlXaXRoaW4iLCJzZXRJbnQxNiIsInNldEludDMyIiwic2V0RmxvYXQzMiIsInhTaGlmdGVkIiwic2V0RmxvYXQ2NCIsInJlZmVyZWUiLCJ3cml0ZU9iamVjdCIsIm1hcEFzRW1wdHlPYmplY3QiLCJlbnRyeVZhbHVlIiwiZXh0ZW5zaW9uQ2xhc3MiLCJ3cml0ZSIsIndyaXRlUmVzdWx0IiwiaXNBcnJheSIsImN1cnJlbnRUYXJnZXQiLCJjdXJyZW50VGFyZ2V0VmlldyIsImN1cnJlbnRQb3NpdGlvbiIsIndyaXRlRXh0ZW5zaW9uRGF0YSIsImpzb24iLCJ3cml0ZUZ1bmN0aW9uIiwic2V0QmlnSW50NjQiLCJzZXRCaWdVaW50NjQiLCJsYXJnZUJpZ0ludFRvRmxvYXQiLCJsYXJnZUJpZ0ludFRvU3RyaW5nIiwidXNlQmlnSW50RXh0ZW5zaW9uIiwiYWxpZ25lZFNpZ24iLCJlbmNvZGVVbmRlZmluZWRBc05pbCIsIndyaXRlUGxhaW5PYmplY3QiLCJ2YXJpYWJsZU1hcFNpemUiLCJjb2VyY2libGVLZXlBc051bWJlciIsInNraXBWYWx1ZXMiLCJoYXNPd25Qcm9wZXJ0eSIsImluY2x1ZGVzIiwibnVtIiwiaXNOYU4iLCJvYmplY3RPZmZzZXQiLCJ3cml0ZVJlY29yZCIsInByb2dyZXNzaXZlUmVjb3JkcyIsIndyb3RlS2V5cyIsImxhc3RUcmFuc2l0aW9uIiwibmV3VHJhbnNpdGlvbnMiLCJuZXdSZWNvcmQiLCJpbnNlcnROZXdSZWNvcmQiLCJyZWNvcmRJZCIsIl9fa2V5c19fIiwiY2hlY2tVc2VSZWNvcmRzIiwibmV3U2l6ZSIsIm1pbiIsInJvdW5kIiwibWF4IiwibmV3QnVmZmVyIiwiY29weSIsInNob3VsZFNoYXJlU3RydWN0dXJlIiwibmV4dE93bklkIiwic2hpZnQiLCJpbnNlcnRpb25PZmZzZXQiLCJtYWluVGFyZ2V0IiwibWFpblBvc2l0aW9uIiwibWFpblNhZmVFbmQiLCJtYWluU3RhcnQiLCJrZXlzUG9zaXRpb24iLCJuZXdFbmQiLCJpbnNlcnRpb25Qb3NpdGlvbiIsIm5ld1Bvc2l0aW9uIiwibm90aWZ5U2hhcmVkVXBkYXRlIiwic3RhcnRUYXJnZXQiLCJ1c2VCdWZmZXIiLCJjbGVhclNoYXJlZERhdGEiLCJ0eXBlZFN0cnVjdHMiLCJnZXRQcm90b3R5cGVPZiIsImRhdGUiLCJhbGxvY2F0ZUZvcldyaXRlIiwic2Vjb25kcyIsImdldFRpbWUiLCJ1c2VUaW1lc3RhbXAzMiIsImdldE1pbGxpc2Vjb25kcyIsIm9uSW52YWxpZERhdGUiLCJzZXRBc0VtcHR5T2JqZWN0IiwicmVnZXgiLCJmbGFncyIsImFycmF5QnVmZmVyIiwid3JpdGVFeHRCdWZmZXIiLCJ3cml0ZUJ1ZmZlciIsInR5cGVkQXJyYXkiLCJpbmRleE9mIiwiZGlzdGFuY2VUb01vdmUiLCJsYXN0RW5kIiwicG9wIiwid3JpdGVTdHJpbmdzIiwiYWRkRXh0ZW5zaW9uIiwiQ2xhc3MiLCJ1bnNoaWZ0IiwiY29tcGF0aWJsZSIsInNldFdyaXRlU3RydWN0U2xvdHMiLCJ3cml0ZVNsb3RzIiwibWFrZVN0cnVjdHVyZXMiLCJkZWZhdWx0UGFja3IiLCJFbmNvZGVyIiwiQVNDSUkiLCJOVU1CRVIiLCJVVEY4IiwiT0JKRUNUX0RBVEEiLCJEQVRFIiwiVFlQRV9OQU1FUyIsImZsb2F0MzJIZWFkZXJzIiwiZXZhbFN1cHBvcnRlZCIsInVwZGF0ZWRQb3NpdGlvbiIsImhhc05vZGVCdWZmZXIiLCJ0ZXh0RW5jb2RlciIsImN1cnJlbnRTb3VyY2UiLCJwcmVwYXJlU3RydWN0dXJlcyIsImVuY29kaW5nU3RhcnQiLCJyZWZzU3RhcnRQb3NpdGlvbiIsImxhc3RTdHJpbmdTdGFydCIsInJlZk9mZnNldCIsInJlZlBvc2l0aW9uIiwicXVldWVkUmVmZXJlbmNlcyIsInVzZWRBc2NpaTAiLCJrZXlJbmRleCIsInBhcmVudCIsImVudW1lcmF0aW9uT2Zmc2V0IiwiYXNjaWkwIiwiYXNjaWk4IiwibnVtOCIsInN0cmluZzE2Iiwib2JqZWN0MTYiLCJudW0zMiIsImZsb2F0NjQiLCJkYXRlNjQiLCJudW1iZXIiLCJudW02NCIsImNyZWF0ZVR5cGVUcmFuc2l0aW9uIiwiaXNOb3RBc2NpaSIsInN0clN0YXJ0Iiwic3RyaW5nOCIsIl9fdHlwZSIsImFueVR5cGUiLCJwcm9wZXJ0eUluZGV4Iiwib2JqZWN0MzIiLCJfX3NpemUiLCJfX3BhcmVudCIsInJldmVyc2UiLCJzZXRJbnQ4IiwiTmFOIiwidHlwZU5hbWUiLCJuZXdUcmFuc2l0aW9uIiwib25Mb2FkZWRTdHJ1Y3R1cmVzIiwic2hhcmVkRGF0YSIsInR5cGVkIiwibmFtZWQiLCJsYXN0VHlwZWRTdHJ1Y3R1cmVzTGVuZ3RoIiwic291cmNlU3ltYm9sIiwiZm9yIiwicmVhZFN0cnVjdCIsInVucGFja3IiLCJjb25zdHJ1Y3QiLCJMYXp5T2JqZWN0IiwicHJvcGVydGllcyIsImN1cnJlbnRPZmZzZXQiLCJsYXN0UmVmUHJvcGVydHkiLCJkZWZpbml0aW9uIiwiZ2V0UmVmIiwicmVmIiwidG9Db25zdGFudCIsIm5leHQiLCJtdWx0aUdldENvdW50IiwicmVmU3RhcnQiLCJieXRlc0VuZCIsImZWYWx1ZSIsIm9iamVjdExpdGVyYWxQcm9wZXJ0aWVzIiwiYXJncyIsImhhc0luaGVyaXRlZFByb3BlcnRpZXMiLCJhbHdheXNMYXp5UHJvcGVydHkiLCJkZWZpbmVQcm9wZXJ0eSIsIndpdGhTb3VyY2UiLCJlbnVtZXJhYmxlIiwidmFsdWVGdW5jdGlvbiIsInRvT2JqZWN0IiwicHJvcCIsIm9taXRVbmRlcnNjb3JlZFByb3BlcnRpZXMiLCJyZXNvbHZlZCIsImluc3RhbmNlIiwiY29kZSIsInN0cnVjdE1hcCIsIlBhY2tyU3RyZWFtIiwiVHJhbnNmb3JtIiwid3JpdGFibGVPYmplY3RNb2RlIiwiX3RyYW5zZm9ybSIsImVuY29kaW5nIiwiVW5wYWNrclN0cmVhbSIsIm9iamVjdE1vZGUiLCJpbmNvbXBsZXRlQnVmZmVyIiwiY29uY2F0IiwiZ2V0TnVsbFZhbHVlIiwicGFja0l0ZXIiLCJvYmplY3RJdGVyYXRvciIsIml0ZXJhdG9yIiwicGFja0l0ZXJTeW5jIiwidGhlbiIsImFzeW5jSXRlcmF0b3IiLCJwYWNrSXRlckFzeW5jIiwidW5wYWNrSXRlciIsImJ1ZmZlckl0ZXJhdG9yIiwicGFyc2VyIiwieWllbGRzIiwiZXJyIiwiaXRlciIsImRlY29kZUl0ZXIiLCJlbmNvZGVJdGVyIiwibmF0aXZlQWNjZWxlcmF0aW9uRGlzYWJsZWQiLCJwcm9jZXNzIiwiZW52IiwiTVNHUEFDS1JfTkFUSVZFX0FDQ0VMRVJBVElPTl9ESVNBQkxFRCIsInRvTG93ZXJDYXNlIiwiZXh0cmFjdG9yIiwiY3JlYXRlUmVxdWlyZSIsImRvY3VtZW50IiwiVVJMIiwiX19maWxlbmFtZSIsImhyZWYiLCJjdXJyZW50U2NyaXB0IiwiYmFzZVVSSSIsIkRlY29kZXJTdHJlYW0iLCJFbmNvZGVyU3RyZWFtIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/msgpackr/dist/node.cjs\n");

/***/ })

};
;